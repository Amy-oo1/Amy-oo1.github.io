<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amy_blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-03T10:40:57.650Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Amy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>辐射度模型</title>
    <link href="http://example.com/2025/10/01/Radiosity-modle/"/>
    <id>http://example.com/2025/10/01/Radiosity-modle/</id>
    <published>2025-09-30T16:00:59.000Z</published>
    <updated>2024-11-03T10:40:57.650Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="渲染度模型"><a href="#渲染度模型" class="headerlink" title="渲染度模型"></a>渲染度模型</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;渲染度模型&quot;&gt;&lt;a href=&quot;#渲染度模型&quot; class=&quot;headerlink&quot; title=&quot;渲染度模型&quot;&gt;&lt;/a&gt;渲染度模型&lt;/h3&gt;&lt;hr&gt;
</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>文艺平衡树</title>
    <link href="http://example.com/2024/11/13/algorithm-Spaly-tree/"/>
    <id>http://example.com/2024/11/13/algorithm-Spaly-tree/</id>
    <published>2024-11-13T11:53:03.000Z</published>
    <updated>2024-11-13T13:20:13.501Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="https://www.luogu.com.cn/problem/P3391">题目要求</a></p><p>简单来讲，就是旋转长度为$N$序列的任意子序列</p><ul><li>序列数据可以用<strong>二叉搜索树</strong>维护，为每一个元素附上一个表示排位的权值即可</li></ul><p>想要逆转子序列，首先得弄清楚子序列元素的分布，将树上节点映射到数轴上，可以发现</p><ul><li>以子序列双端点的$LCA$的最近公共祖先为节点的子树$T$包含整个子序列(<strong>不是只包含</strong>)，所以只需要遍历重构这个树就能实现翻转</li></ul><p>如果使用查找操作$O(\log N)$平衡树，翻转子序列的复杂度为</p><script type="math/tex; mode=display">O(\log N+2^{\hat{H}(T)})\le O(\log N +N)=O(N)</script><ul><li>$Spaly$重构</li></ul><p>$Splay$树可以改进这个复杂度，它能构造只包含翻转子序列元素的树$T$</p><p>具体的说，有翻转子序列$[L,R]$，其中$L,R$分别是序列端点的索引，将$Node_L$<code>splay</code>到根节点，将$Node_R$<code>splay</code>到根的右节点，此时$T(Node_R.left)+Node_L+Node_R$<strong>刚好</strong>就是翻转子序列元素，有</p><script type="math/tex; mode=display">O(\log N+R-L+1)</script><p>具体证明可以把树上节点映射到数轴上</p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote><p>$tips$ 因为两次旋转等价于没旋转，所以可使用懒惰修改，每次访问到节点都需要<code>pushdown</code></p></blockquote><p><img src="https://s2.loli.net/2024/11/12/XQlYxpZKsonj7mF.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">lass S_tsplay_T &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, Node* parent = <span class="literal">nullptr</span>) :<span class="built_in">val</span>(val), <span class="built_in">parent</span>(parent) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, size = <span class="number">1</span>;</span><br><span class="line">Node* left = <span class="literal">nullptr</span>, * right = <span class="literal">nullptr</span>, * parent;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_is_left_child</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node-&gt;parent-&gt;left == node; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_get_size</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node ? node-&gt;size : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_up_size</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node-&gt;size = <span class="built_in">s_get_size</span>(node-&gt;left) + <span class="built_in">s_get_size</span>(node-&gt;right) + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_set_flag</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">if</span> (node)node-&gt;flag ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_link_X_and_TZ</span><span class="params">(Node* X, Node* Z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Z)</span><br><span class="line">(<span class="built_in">s_is_left_child</span>(X-&gt;parent) ? Z-&gt;left : Z-&gt;right) = X;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = X;</span><br><span class="line">X-&gt;parent = Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_and_TY</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent)</span><br><span class="line">(<span class="built_in">s_is_left_child</span>(X) ? X-&gt;parent-&gt;left : X-&gt;parent-&gt;right) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line">X-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear_X</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">while</span> (X) &#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left)</span><br><span class="line">X = X-&gt;left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (X-&gt;right)</span><br><span class="line">X = X-&gt;right;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node* Y = X-&gt;parent;</span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">delete</span> X;</span><br><span class="line">X = Y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_left</span><span class="params">(Node* Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;right;</span><br><span class="line">Y-&gt;right = X-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left)</span><br><span class="line">X-&gt;left-&gt;parent = Y;</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(X, Y-&gt;parent);</span><br><span class="line">Y-&gt;parent = X;</span><br><span class="line">X-&gt;left = Y;</span><br><span class="line"><span class="built_in">s_up_size</span>(Y);</span><br><span class="line"><span class="built_in">s_up_size</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_right</span><span class="params">(Node* Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;left;</span><br><span class="line">Y-&gt;left = X-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;right)</span><br><span class="line">X-&gt;right-&gt;parent = Y;</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(X, Y-&gt;parent);</span><br><span class="line">Y-&gt;parent = X;</span><br><span class="line">X-&gt;right = Y;</span><br><span class="line"><span class="built_in">s_up_size</span>(Y);</span><br><span class="line"><span class="built_in">s_up_size</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_is_left_child</span>(X) ? <span class="built_in">s_rotate_right</span>(X-&gt;parent) : <span class="built_in">s_rotate_left</span>(X-&gt;parent); &#125;</span><br><span class="line">~<span class="built_in">S_tsplay_T</span>() &#123; <span class="keyword">if</span> (Root)<span class="built_in">s_clear_X</span>(Root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_splay_node_to_Son_of_Y</span><span class="params">(Node* X, Node* Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;parent != Y) &#123;<span class="comment">//Y存在</span></span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent-&gt;parent != Y)</span><br><span class="line"><span class="built_in">s_rotate</span>(<span class="built_in">s_is_left_child</span>(X) == <span class="built_in">s_is_left_child</span>(X-&gt;parent) ? X-&gt;parent : X);</span><br><span class="line"><span class="built_in">s_rotate</span>(X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; self, Node*&amp; X, Node* Y, <span class="type">int</span> L, <span class="type">int</span> R)-&gt;<span class="type">void</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)</span><br><span class="line">X = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (L == R)</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(nums[L], Y);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(nums[M], Y);</span><br><span class="line"><span class="built_in">self</span>(self, X-&gt;left, X, L, M - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">self</span>(self, X-&gt;right, X, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (X)</span><br><span class="line"><span class="built_in">s_up_size</span>(X);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(dfs, Root, <span class="literal">nullptr</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tagtrv</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line"><span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line"><span class="built_in">s_set_flag</span>(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pushdown</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;flag) &#123;</span><br><span class="line"><span class="built_in">tagtrv</span>(X-&gt;left);</span><br><span class="line"><span class="built_in">tagtrv</span>(X-&gt;right);</span><br><span class="line"><span class="built_in">s_set_flag</span>(X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">Node* X = Root;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">pushdown</span>(X);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_size</span>(X-&gt;left) &gt; rank)</span><br><span class="line">X = X-&gt;left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">s_get_size</span>(X-&gt;left) == rank)</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">rank -= <span class="built_in">s_get_size</span>(X-&gt;left) + <span class="number">1</span>;</span><br><span class="line">X = X-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">reserve</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(<span class="built_in">kth</span>(L - <span class="number">1</span>), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(<span class="built_in">kth</span>(R + <span class="number">1</span>), Root);</span><br><span class="line"><span class="built_in">tagtrv</span>(Root-&gt;right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mid_trv</span><span class="params">()</span> -&gt; vector&lt;<span class="type">int</span>&gt; </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; self, Node* X)-&gt;<span class="type">void</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (X) &#123;</span><br><span class="line"><span class="built_in">pushdown</span>(X);</span><br><span class="line"><span class="built_in">self</span>(self, X-&gt;left);</span><br><span class="line">nums.<span class="built_in">emplace_back</span>(X-&gt;val);</span><br><span class="line"><span class="built_in">self</span>(self, X-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(dfs, Root);</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3391&quot;&gt;题目要求&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来讲，就是旋转长度为$N$序列的任意子序列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列数据可以用&lt;strong&gt;二叉搜索树&lt;/strong&gt;维</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
    <category term="Balanced-Tree" scheme="http://example.com/tags/Balanced-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Splay树</title>
    <link href="http://example.com/2024/11/12/Splayiing-tree/"/>
    <id>http://example.com/2024/11/12/Splayiing-tree/</id>
    <published>2024-11-12T11:28:47.000Z</published>
    <updated>2024-11-13T13:18:10.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伸展树（$Splay\ Tree$）是一种自平衡二叉搜索树，它可以在对树进行一系列操作后，通过特定的<strong>展开</strong>操作将最近访问的节点移动到树的根部。这种数据结构的目的是通过局部性原理来优化搜索树的性能，即最近被访问的元素很可能在不久的将来再次被访问</p></blockquote><hr><h4 id="树节点"><a href="#树节点" class="headerlink" title="树节点"></a>树节点</h4><p>定义并初始化维护伸展树根的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>定义<strong>伸展操作</strong>$splay$，这个操作会保证$splay$树的均摊复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_splay_node_to_Son_of_Y</span><span class="params">(Node* X, Node* Y)</span>-&gt;<span class="type">void</span></span></span><br></pre></td></tr></table></figure><p>这个操作使得树节点$X$成为$Y$的儿子节点，定义伸展树根节点的$parent$为$nullptr$，也就是说，这个操作可以实现将最近访问的节点移动到树的根部</p><p>根据定义，在树<strong>节点不重复</strong>的限制下，一颗其节点可以表示为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, Node* parent = <span class="literal">nullptr</span>) :<span class="built_in">val</span>(val), <span class="built_in">parent</span>(parent) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">Node* left = <span class="literal">nullptr</span>, * right = <span class="literal">nullptr</span>, * parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>从理论上讲插入和二叉搜索树无异，只是多了伸展操作。不过这里定义了父节点，可以迭代进行</p><ul><li>把键值$val$插入到根为$X$的伸展树</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_v_to_X</span><span class="params">(Node* X, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">Node* Y = X ? X-&gt;parent : <span class="literal">nullptr</span>, * root_Y = Y;</span><br><span class="line"><span class="keyword">while</span> (X) &#123;</span><br><span class="line">Y = X;</span><br><span class="line">X = (val &lt; X-&gt;val ? X-&gt;left : X-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(val, Y);</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">(val &lt; Y-&gt;val ? Y-&gt;left : Y-&gt;right) = X;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = X;</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(X, root_Y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重用了符号$X$，执行第六行后，这是$val$所在的节点，全程跟踪它的父节点$Y$以建立连接</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>首先对要删除的节点进行$splay$操作，之后和二叉搜索树无异</p><ul><li>把$val$所在的节点从根为$X$的<strong>伸展树</strong>中删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_v_from_X</span><span class="params">(Node* X, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">Node* Y = X-&gt;parent;</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(<span class="built_in">s_serach_v_from_X</span>(X, val), Y);</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">X = (Y-&gt;left &amp;&amp; val == Y-&gt;left-&gt;val ? Y-&gt;left : Y-&gt;right);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">X = Root;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left &amp;&amp; X-&gt;right) &#123;</span><br><span class="line">Node* succ = <span class="built_in">s_min_in_X</span>(X-&gt;right);</span><br><span class="line">X-&gt;val = succ-&gt;val;</span><br><span class="line">X = succ;</span><br><span class="line">&#125;</span><br><span class="line">Node* C = X-&gt;left ? X-&gt;left : X-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (C)</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(C, X-&gt;parent);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">delete</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也重用了符号$X$，执行第四行后，这是要删除的节点</p><ul><li>将$X$直接连接到祖父节点$Z$下（如果父节点已经移除，一定不会破坏树结构）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_link_X_and_TZ</span><span class="params">(Node* X, Node* Z)</span>-&gt;<span class="type">void</span></span></span><br></pre></td></tr></table></figure><h3 id="splay"><a href="#splay" class="headerlink" title="$splay$"></a>$splay$</h3><p>由之前的旋转操作可知，无论左旋右旋，都会使得其中一个子节点的高度增加1，所以只需要一直旋转上去就行，<code>s_rotate（x)</code>就是将节点$X$将其父节点按照预期的方向旋转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_splay_node_to_Son_of_Y</span><span class="params">(Node* X, Node* Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;parent != Y)</span><br><span class="line"><span class="built_in">s_rotate</span>(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种实现不能得到正确的复杂度，在原论文中，作者明确的分类，其中一种$Zig-Zig$和<strong>一直旋转</strong>$X.parent$不同</p><p><img src="https://s2.loli.net/2024/11/12/K21QZ8qWgOmjS9i.png" alt=""></p><p>正确的做法应该考虑<strong>双旋</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_splay_node_to_Son_of_Y</span><span class="params">(Node* X, Node* Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;parent != Y) &#123;<span class="comment">//Y存在</span></span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent-&gt;parent != Y)</span><br><span class="line"><span class="built_in">s_rotate</span>(<span class="built_in">s_is_left_child</span>(X) == <span class="built_in">s_is_left_child</span>(X-&gt;parent) ? X-&gt;parent : X);</span><br><span class="line"><span class="built_in">s_rotate</span>(X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/12/ByqfS2Tsc4XN1iK.png" alt=""></p><p>这是$splay$树自我调整的表现，连续的$zig-zig$出现了不满的节点变满，也就是说，对$splay$树的均摊复杂度必须考虑树结构才能得出有意义的界，本人无法给出具体的良好的渐进界，不过可以构造随机数据观察为什么要这么做</p><p><img src="https://s2.loli.net/2024/11/13/zsaCSA59xUuOWhn.png" alt=""></p><p>这是二叉树结构的简单可视化程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">S_Print_Tree</span>(S_splay_T::Node * root) &#123;</span><br><span class="line"><span class="keyword">auto</span> get_height = [&amp;](<span class="keyword">auto</span>&amp; self, <span class="keyword">auto</span> node)-&gt;<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">self</span>(self, node-&gt;left), <span class="built_in">self</span>(self, node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">get_height</span>(get_height, root);</span><br><span class="line"><span class="type">int</span> m = height + <span class="number">1</span>, n = <span class="built_in">pow</span>(<span class="number">2</span>, height + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;string&gt;(n));</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; self, S_splay_T::Node* node, <span class="type">int</span>  r, <span class="type">int</span> c)-&gt;<span class="type">void</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">ans[r][c] = <span class="built_in">to_string</span>(node-&gt;val);</span><br><span class="line"><span class="built_in">self</span>(self, node-&gt;left, r + <span class="number">1</span>, c - <span class="built_in">pow</span>(<span class="number">2</span>, height - r - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">self</span>(self, node-&gt;right, r + <span class="number">1</span>, c + <span class="built_in">pow</span>(<span class="number">2</span>, height - r - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(dfs, root, <span class="number">0</span>, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p><img src="https://s2.loli.net/2024/11/12/XQlYxpZKsonj7mF.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//splay树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_splay_T</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, Node* parent = <span class="literal">nullptr</span>) :<span class="built_in">val</span>(val), <span class="built_in">parent</span>(parent) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">Node* left = <span class="literal">nullptr</span>, * right = <span class="literal">nullptr</span>, * parent;</span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_is_left_child</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node-&gt;parent-&gt;left == node; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_min_in_X</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;left)</span><br><span class="line">X = X-&gt;left;</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_link_X_and_TZ</span><span class="params">(Node* X, Node* Z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Z)</span><br><span class="line">(<span class="built_in">s_is_left_child</span>(X-&gt;parent) ? Z-&gt;left : Z-&gt;right) = X;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = X;</span><br><span class="line">X-&gt;parent = Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_and_TY</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent)</span><br><span class="line">(<span class="built_in">s_is_left_child</span>(X) ? X-&gt;parent-&gt;left : X-&gt;parent-&gt;right) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line">X-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear_X</span><span class="params">(Node* X)</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">while</span> (X) &#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left)</span><br><span class="line">X = X-&gt;left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (X-&gt;right)</span><br><span class="line">X = X-&gt;right;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node* Y = X-&gt;parent;</span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">delete</span> X;</span><br><span class="line">X = Y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_left</span><span class="params">(Node* Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;right;</span><br><span class="line">Y-&gt;right = X-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left)</span><br><span class="line">X-&gt;left-&gt;parent = Y;</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(X, Y-&gt;parent);</span><br><span class="line">Y-&gt;parent = X;</span><br><span class="line">X-&gt;left = Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_right</span><span class="params">(Node* Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;left;</span><br><span class="line">Y-&gt;left = X-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;right)</span><br><span class="line">X-&gt;right-&gt;parent = Y;</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(X, Y-&gt;parent);</span><br><span class="line">Y-&gt;parent = X;</span><br><span class="line">X-&gt;right = Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_is_left_child</span>(X) ? <span class="built_in">s_rotate_right</span>(X-&gt;parent) : <span class="built_in">s_rotate_left</span>(X-&gt;parent); &#125;</span><br><span class="line">~<span class="built_in">S_splay_T</span>() &#123; <span class="keyword">if</span> (Root)<span class="built_in">s_clear_X</span>(Root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_splay_node_to_Son_of_Y</span><span class="params">(Node* X, Node* Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;parent != Y) &#123;<span class="comment">//Y存在</span></span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent-&gt;parent != Y)</span><br><span class="line"><span class="built_in">s_rotate</span>(<span class="built_in">s_is_left_child</span>(X) == <span class="built_in">s_is_left_child</span>(X-&gt;parent) ? X-&gt;parent : X);</span><br><span class="line"><span class="built_in">s_rotate</span>(X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_v_to_X</span><span class="params">(Node* X, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">Node* Y = X ? X-&gt;parent : <span class="literal">nullptr</span>, * root_Y = Y;</span><br><span class="line"><span class="keyword">while</span> (X) &#123;</span><br><span class="line">Y = X;</span><br><span class="line">X = (val &lt; X-&gt;val ? X-&gt;left : X-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(val, Y);</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">(val &lt; Y-&gt;val ? Y-&gt;left : Y-&gt;right) = X;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Root = X;</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(X, root_Y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_serach_v_from_X</span><span class="params">(Node* X, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;val != val)</span><br><span class="line">X = (val &lt; X-&gt;val ? X-&gt;left : X-&gt;right);</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_v_from_X</span><span class="params">(Node* X, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">Node* Y = X-&gt;parent;</span><br><span class="line"><span class="built_in">s_splay_node_to_Son_of_Y</span>(<span class="built_in">s_serach_v_from_X</span>(X, val), Y);</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">X = (Y-&gt;left &amp;&amp; val == Y-&gt;left-&gt;val ? Y-&gt;left : Y-&gt;right);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">X = Root;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;left &amp;&amp; X-&gt;right) &#123;</span><br><span class="line">Node* succ = <span class="built_in">s_min_in_X</span>(X-&gt;right);</span><br><span class="line">X-&gt;val = succ-&gt;val;</span><br><span class="line">X = succ;</span><br><span class="line">&#125;</span><br><span class="line">Node* C = X-&gt;left ? X-&gt;left : X-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (C)</span><br><span class="line"><span class="built_in">s_link_X_and_TZ</span>(C, X-&gt;parent);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_and_TY</span>(X);</span><br><span class="line"><span class="keyword">delete</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="built_in">s_insert_v_to_X</span>(Root, val); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="built_in">s_erase_v_from_X</span>(Root, val); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;伸展树（$Splay&#92; Tree$）是一种自平衡二叉搜索树，它可以在对树进行一系列操作后，通过特定的&lt;strong&gt;展开&lt;/strong&gt;操作将最近访问的节点移动到树的根部。这种数据结构的目的是通过局部性原理来优化搜索树的性能，即最近被访问的元素很</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Balanced-Tree" scheme="http://example.com/tags/Balanced-Tree/"/>
    
  </entry>
  
  <entry>
    <title>AVL树复杂度分析</title>
    <link href="http://example.com/2024/11/11/AVL-tree/"/>
    <id>http://example.com/2024/11/11/AVL-tree/</id>
    <published>2024-11-11T12:07:42.000Z</published>
    <updated>2024-11-11T14:30:13.040Z</updated>
    
    <content type="html"><![CDATA[<hr><p>$tips$ 前置知识：二叉搜索树$BST$</p><p>二叉搜索树是一种二叉树的树形数据结构，其定义如下：</p><ul><li><p>空树是二叉搜索树。</p></li><li><p>若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。</p></li><li><p>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</p></li><li><p>二叉搜索树的左右子树均为二叉搜索树。</p></li></ul><hr><h4 id="AVL-的结构"><a href="#AVL-的结构" class="headerlink" title="$AVL$的结构"></a>$AVL$的结构</h4><ul><li><strong>平衡因子</strong>：在$AVL$树中，任何节点的两个子树的高度最大差别为$0$，所以它也被称为高度平衡树</li></ul><p><em>定义空树高为</em>$-1$</p><p>$AVL$通过<strong>旋转</strong>实现自平衡,对于不满足平衡因子的树$Y$高一定为<strong>2</strong>，这个是旋转和递归操作决定的，也就是只考虑$Y.height==1$</p><p>$AVL$将其分为四类，其中两种关于$Y$的左右存在镜像关系，这里仅分析以下两种（$Y.left.height&gt;Y.right.height$）就能覆盖所有情况</p><ul><li><p>$X.left.height\ge X.right.height$ 右旋$Y$</p></li><li><p>$X.left.height&lt; X.right.height$ 左旋$X$变换为上一种情况右旋$Y$</p></li></ul><p><img src="https://s2.loli.net/2024/11/11/LNwD1ej7JXVMoyf.png" alt=""></p><p><em>虚线节点为可能存在的节点</em></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_left</span><span class="params">(Node*&amp; Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;right;</span><br><span class="line">Y-&gt;right = X-&gt;left;</span><br><span class="line">X-&gt;left = Y;</span><br><span class="line"><span class="built_in">s_up_height</span>(Y);</span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">Y = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_left</span><span class="params">(Node*&amp; Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;right;</span><br><span class="line">Y-&gt;right = X-&gt;left;</span><br><span class="line">X-&gt;left = Y;</span><br><span class="line"><span class="built_in">s_up_height</span>(Y);</span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">Y = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑各种操作后可以得到纠正破坏<strong>平衡因子</strong>的$AVL$树$Y$的<strong>平衡</strong>操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_blance_X</span><span class="params">(Node*&amp; X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;left) - <span class="built_in">s_get_height</span>(X-&gt;right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;left-&gt;right) &gt; <span class="built_in">s_get_height</span>(X-&gt;left-&gt;left))</span><br><span class="line"><span class="built_in">s_rotate_left</span>(X-&gt;left);</span><br><span class="line"><span class="built_in">s_rotate_right</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;right) - <span class="built_in">s_get_height</span>(X-&gt;left) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;right-&gt;left) &gt; <span class="built_in">s_get_height</span>(X-&gt;right-&gt;right))</span><br><span class="line"><span class="built_in">s_rotate_right</span>(X-&gt;right);</span><br><span class="line"><span class="built_in">s_rotate_left</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>对未破坏平衡因子的树节点调用不存在副作用</em></p><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是递归进行的在递归回升路径上对路径上每个节点做平衡操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_v_to_X</span><span class="params">(Node*&amp; X, <span class="type">int</span> val)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!X)</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_insert_v_to_X</span>(val &lt; X-&gt;val ? X-&gt;left : X-&gt;right, val);</span><br><span class="line"><span class="built_in">s_blance_X</span>(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来证明平衡操作只会<strong>起作用</strong>一次且被平衡的树高为$2$</p><ul><li>插入节点的父节点新高度增加$1$，此时父节点只有一个节点，且高度为$1$<ul><li>插入节点的祖父节点高度增加$1$，它的新高度只可能是（新父节点高度+1）$2$，对祖父节点进行平衡操作，其高度减1</li></ul></li></ul><p>其他情况下路径节点上高度不变，或者破坏平衡因子节点之上的节点高度都不会变化</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_v_from_X</span><span class="params">(Node*&amp; X, <span class="type">int</span> val)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;val != val)</span><br><span class="line"><span class="built_in">s_erase_v_from_X</span>(val &lt; X-&gt;val ? X-&gt;left : X-&gt;right, val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (X-&gt;left &amp;&amp; X-&gt;right) &#123;</span><br><span class="line">Node*&amp; pre = <span class="built_in">s_max_node_in_X</span>(X-&gt;left);</span><br><span class="line">X-&gt;val = pre-&gt;val;</span><br><span class="line"><span class="built_in">s_erase_v_from_X</span>(X-&gt;left, pre-&gt;val);<span class="comment">//路径连续性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> die = X;</span><br><span class="line">X = X-&gt;left ? X-&gt;left : X-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> die;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (X)</span><br><span class="line"><span class="built_in">s_blance_X</span>(X);</span><br></pre></td></tr></table></figure><ul><li><p>删除节点有两个子节点，通过找到前驱/后继化归为不足两个字节点情况</p></li><li><p>有且仅有一个子节点，它的树高为$1$</p></li><li><p>没有子节点，树高为$0$</p></li></ul><p>因为被删除节点的树高只有两种可能$0$和$1$两种可能，参考插入递归的回归路径可证，删除操作能维持平衡因子</p><hr><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>删除和操作时间复杂度都为$O(\log N)$，接下来证明$N$个节点$AVL$的最大树高为$O(\log N)$</p><p>树高为$h$的$AVL$树最少节点数为$n(h)$，则有</p><ul><li>基础情况</li></ul><script type="math/tex; mode=display">n(0)=1,n(1)=2</script><ul><li>归纳</li></ul><script type="math/tex; mode=display">n(h)=n(h-1)+n(h-2)+1</script><p>这是一个斐波那契数，得出一（放缩过）解</p><script type="math/tex; mode=display">h< 1.44\log_2(n(h)+2)-1.32772</script><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_AVL_Tree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val) :<span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, height = <span class="number">0</span>;</span><br><span class="line">Node* left = <span class="literal">nullptr</span>, * right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Node* root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_get_height</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node ? node-&gt;height : <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_up_height</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node-&gt;height = <span class="built_in">max</span>(<span class="built_in">s_get_height</span>(node-&gt;left), <span class="built_in">s_get_height</span>(node-&gt;right)) + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_max_node_in_X</span><span class="params">(Node*&amp; X)</span> -&gt; Node*&amp; </span>&#123; <span class="keyword">return</span> X-&gt;right ? <span class="built_in">s_max_node_in_X</span>(X-&gt;right) : X; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear_X</span><span class="params">(Node*&amp; X)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X) &#123;</span><br><span class="line"><span class="built_in">s_clear_X</span>(X-&gt;left);</span><br><span class="line"><span class="built_in">s_clear_X</span>(X-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> X;</span><br><span class="line">&#125;</span><br><span class="line">X = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_left</span><span class="params">(Node*&amp; Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;right;</span><br><span class="line">Y-&gt;right = X-&gt;left;</span><br><span class="line">X-&gt;left = Y;</span><br><span class="line"><span class="built_in">s_up_height</span>(Y);</span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">Y = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_rotate_right</span><span class="params">(Node*&amp; Y)</span> </span>&#123;</span><br><span class="line">Node* X = Y-&gt;left;</span><br><span class="line">Y-&gt;left = X-&gt;right;</span><br><span class="line">X-&gt;right = Y;</span><br><span class="line"><span class="built_in">s_up_height</span>(Y);</span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">Y = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_blance_X</span><span class="params">(Node*&amp; X)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;left) - <span class="built_in">s_get_height</span>(X-&gt;right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;left-&gt;right) &gt; <span class="built_in">s_get_height</span>(X-&gt;left-&gt;left))</span><br><span class="line"><span class="built_in">s_rotate_left</span>(X-&gt;left);</span><br><span class="line"><span class="built_in">s_rotate_right</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;right) - <span class="built_in">s_get_height</span>(X-&gt;left) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">s_get_height</span>(X-&gt;right-&gt;left) &gt; <span class="built_in">s_get_height</span>(X-&gt;right-&gt;right))</span><br><span class="line"><span class="built_in">s_rotate_right</span>(X-&gt;right);</span><br><span class="line"><span class="built_in">s_rotate_left</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_up_height</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_v_to_X</span><span class="params">(Node*&amp; X, <span class="type">int</span> val)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!X)</span><br><span class="line">X = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_insert_v_to_X</span>(val &lt; X-&gt;val ? X-&gt;left : X-&gt;right, val);</span><br><span class="line"><span class="built_in">s_blance_X</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_v_from_X</span><span class="params">(Node*&amp; X, <span class="type">int</span> val)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;val != val)</span><br><span class="line"><span class="built_in">s_erase_v_from_X</span>(val &lt; X-&gt;val ? X-&gt;left : X-&gt;right, val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (X-&gt;left &amp;&amp; X-&gt;right) &#123;</span><br><span class="line">Node*&amp; pre = <span class="built_in">s_max_node_in_X</span>(X-&gt;left);</span><br><span class="line">X-&gt;val = pre-&gt;val;</span><br><span class="line"><span class="built_in">s_erase_v_from_X</span>(X-&gt;left, pre-&gt;val);<span class="comment">//路径连续性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> die = X;</span><br><span class="line">X = X-&gt;left ? X-&gt;left : X-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> die;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (X)</span><br><span class="line"><span class="built_in">s_blance_X</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">S_AVL_Tree</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">S_AVL_Tree</span>() &#123; <span class="built_in">s_clear_X</span>(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(<span class="keyword">auto</span> val)</span> </span>&#123; <span class="built_in">s_insert_v_to_X</span>(root, val); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">erase</span><span class="params">(<span class="keyword">auto</span> val)</span> </span>&#123; <span class="built_in">s_erase_v_from_X</span>(root, val); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;$tips$ 前置知识：二叉搜索树$BST$&lt;/p&gt;
&lt;p&gt;二叉搜索树是一种二叉树的树形数据结构，其定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;空树是二叉搜索树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Balanced-Tree" scheme="http://example.com/tags/Balanced-Tree/"/>
    
  </entry>
  
  <entry>
    <title>自动机上下文与VAO</title>
    <link href="http://example.com/2024/11/10/VAO-State-Machine/"/>
    <id>http://example.com/2024/11/10/VAO-State-Machine/</id>
    <published>2024-11-10T15:05:18.000Z</published>
    <updated>2024-11-10T16:58:06.241Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$OpenGL$自身是一个巨大的状态机($State-Machine$)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p></blockquote><p><strong>实践中不需要知道自动机是如何运行的，而编码可能会被某些上下文信息迷惑，尤其是在过程式编程中</strong></p><hr><h3 id="buffer-缓冲区"><a href="#buffer-缓冲区" class="headerlink" title="$buffer$缓冲区"></a>$buffer$缓冲区</h3><blockquote><p>在$OpenGL$中，缓冲区（$Buffer$）是用来存储数据的对象，它们位于<strong>显存</strong>中，可以存储顶点数据、索引数据、像素数据等</p></blockquote><p>接下来介绍$GPU$中的$buffer$如何与$CPU$中的$Cpp$程序交互，$OpenGL$使用自动机的<strong>上下文</strong>减少冗余</p><h4 id="glGenBuffer-创建"><a href="#glGenBuffer-创建" class="headerlink" title="$glGenBuffer$创建"></a>$glGenBuffer$创建</h4><ul><li>创建$n$个$buffer$对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glGenBuffers</span><span class="params">(GLsizei n, GLuint* buffers)</span></span></span><br></pre></td></tr></table></figure><p>简单来讲，创建的$VBO$对象就是不为$0$的$GLuint$类型<strong>索引</strong>，$0$映射到<strong>空对象</strong>，在$cpp$程序中使用索引访问不同的缓冲</p><h4 id="glBindBuffer-绑定"><a href="#glBindBuffer-绑定" class="headerlink" title="$glBindBuffer$绑定"></a>$glBindBuffer$绑定</h4><ul><li>将<strong>缓冲区目标</strong>绑定到特定$VBO$对象，这告诉$GPU$如何操作特定缓冲区</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBindBuffer</span><span class="params">(GLenum target, GLuint buffer)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在$OpenGL$中，“缓冲区目标”（$Buffer-Target$）是指$OpenGL$用于指定当前操作的缓冲区类型的一个枚举值。每个缓冲区目标定义了一种特定的缓冲区用途，并且每种用途都有与之相关的特定操作和函数。</p></blockquote><p>比如<code>GL_ARRAY_BUFFER</code>，用于存储顶点的属性数据，如位置、颜色、纹理坐标</p><hr><h3 id="缓冲区操作和-VAO"><a href="#缓冲区操作和-VAO" class="headerlink" title="缓冲区操作和$VAO$"></a>缓冲区操作和$VAO$</h3><ul><li>将$CPU$中$date$数据挪移到缓冲区对象$target$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBufferDate</span><span class="params">(GLenum target, GLsizeiptr size, <span class="type">const</span> <span class="type">void</span>* data, GLenum usage)</span></span></span><br></pre></td></tr></table></figure><p>在这个函数中，没有直接对缓存区对象进行操作，而是通缓冲区目标$targe$间接实现，也就是$targe$的上下文：绑定的$buffer$</p><p>$bind$<em>赋值了一种状态，之后的操作都在这个上下文进行，直到它改变为止，所以在这里使用tab来展示这种关系</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[i]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(Positions), Positions, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>比如此处的<code>glBufferData</code>受<code>glBindBuffer</code>改变的状态影响</p><hr><h4 id="VAO"><a href="#VAO" class="headerlink" title="$VAO$"></a>$VAO$</h4><blockquote><p>$VAO$可以看作是一个对象，它包含了一系列的顶点属性状态，这些状态定义了如何$Buffer$中提取顶点数据。</p></blockquote><p>一个顶点数组对象会储存以下这些内容（状态）</p><ul><li><p><code>glEnableVertexAttribArray</code>和<code>glDisableVertexAttribArray</code>的调用</p></li><li><p>通过<code>glVertexAttribPointer</code>设置的顶点属性配置</p></li><li><p>通过<code>glVertexAttribPointer</code>调用与顶点属性关联的顶点缓冲对象</p></li><li><p><code>void glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer EBO)</code></p></li><li><p>$ect\cdots$</p></li></ul><p>其中第四条会影响*$EBO$的<code>glBindbuffer</code>，因为$EBO$本身就和<code>Attrib</code>相关</p><p>顶点数组对象($Vertex\ Array\ Object$, $VAO$)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个$VAO$中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的$VAO$就行了</p><p>$VAO$相当于是一个储存了某些状态集的对象，当绑定到一个$VAO$时，在这个$vao$状态下的相关状态改变都会被记录保留，再次绑定时状这些状态又会被拿出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(VAO[i]);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[i]);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * (<span class="built_in">sizeof</span>(<span class="type">float</span>)), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO[i]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(Elements_Positiopn), Elements_Positiopn, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最后可能需要转换到$0$空状态，防止记录到不需要的状态更改，$VAObuffer$是特殊的，$VBO,EBO$有隐含的状态关闭</p><h4 id="其他的状态"><a href="#其他的状态" class="headerlink" title="其他的状态"></a>其他的状态</h4><p>参考代码：一次渲染需要特定的顶点数据和$shadingprogram$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(renderingProgram_F);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(renderingProgram_S);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;$OpenGL$自身是一个巨大的状态机($State-Machine$)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="cg-api" scheme="http://example.com/tags/cg-api/"/>
    
  </entry>
  
  <entry>
    <title>多重重要性采样</title>
    <link href="http://example.com/2024/11/09/Multiple-Importance-Sampling/"/>
    <id>http://example.com/2024/11/09/Multiple-Importance-Sampling/</id>
    <published>2024-11-09T04:41:59.000Z</published>
    <updated>2024-11-09T06:09:21.303Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="多重重要性采样-MIS-理论"><a href="#多重重要性采样-MIS-理论" class="headerlink" title="多重重要性采样$MIS$理论"></a>多重重要性采样$MIS$理论</h3><p>$MIS$提供了在在蒙特卡洛积分中将多种采样分布结合起来的无偏估计的方法</p><p>具体的说，有$M$个采样策略，每种采样策略$i$都在<strong>样本空间</strong>内采样，且对应的概率密度函数为$p_i$</p><p>每种采样策略$i$<strong>独立</strong>采样$N_i$个样本，第$i$种采样方法获得的第$j$样本为$x_{ij}$，获得总共$\sum_{i=1}^{M}N_i$个样本，然后使用以下式子进行积分估值：</p><script type="math/tex; mode=display">I=\int_{\Omega}f(x)dx\approx\sum_{i=1}^M\frac{1}{N_i}\sum_{j=1}^{N_i}w_i(x_{ij})\frac{f(x_{ij})}{p_i(x_{ij})}</script><p>其中$w_i$为权重函数，接下来证明它需要满足的条件才能实现无偏估计</p><script type="math/tex; mode=display">\begin{align}E[I] &= E\left[\sum_{i=1}^M\frac{1}{N_i}\sum_{j=1}^{N_i}w_i(x_{ij})\frac{f(x_{ij})}{p_i(x_{ij})}\right]\\\\&= \sum_{i=1}^ME\left[\frac{1}{N_i}\sum_{j=1}^{N_i}w_i(x_{ij})\frac{f(x_{ij})}{p_i(x_{ij})}\right]\\\\&= \sum_{i=1}^ME\left[w_i(\bar{x_i})\frac{f(\bar{x_i})}{p_i(\bar{x_i})}\right]\\\\&= \sum_{i=1}^M\int_{\Omega}w_i(x)\frac{f(x)}{p_i(x)}p_i(x)dx\\\\\&= \int_{\Omega}\sum_{i=1}^Mw_i(x)f(x)dx\end{align}</script><p>若有$\sum_{i=1}^Mw_i(x)=1$，则采样结果为无偏估计</p><hr><h4 id="平衡启发式权重-Balance-heuristic"><a href="#平衡启发式权重-Balance-heuristic" class="headerlink" title="平衡启发式权重$Balance-heuristic$"></a>平衡启发式权重$Balance-heuristic$</h4><script type="math/tex; mode=display">w_i=\frac{n_ip_i}{\sum_{j=1}^Mn_jp_j}</script><h4 id="幂启发式权重-Power-Heuristic"><a href="#幂启发式权重-Power-Heuristic" class="headerlink" title="幂启发式权重$Power-Heuristic$"></a>幂启发式权重$Power-Heuristic$</h4><script type="math/tex; mode=display">w_i=\frac{n_ip_i^\beta}{\sum_{j=1}^Mn_jp_j^\beta}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;多重重要性采样-MIS-理论&quot;&gt;&lt;a href=&quot;#多重重要性采样-MIS-理论&quot; class=&quot;headerlink&quot; title=&quot;多重重要性采样$MIS$理论&quot;&gt;&lt;/a&gt;多重重要性采样$MIS$理论&lt;/h3&gt;&lt;p&gt;$MIS$提供了在在蒙特卡洛积分中</summary>
      
    
    
    
    <category term="概率论" scheme="http://example.com/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>重要性采样</title>
    <link href="http://example.com/2024/11/08/Importance-Sampling/"/>
    <id>http://example.com/2024/11/08/Importance-Sampling/</id>
    <published>2024-11-07T23:49:23.000Z</published>
    <updated>2024-11-10T10:27:18.741Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>设函数$f:S\to R$，随机变量$x\sim p$，根据<strong>大数定理</strong>$\lim_{N\to\infty}\frac{1}{N}\sum_{i=1}^Np(x_i)=1$可以估计函数$f(x)$的期望</p><script type="math/tex; mode=display">E[f(x)]=\int_{x\in S}f(x)p(x)d\mu\approx\frac{1}{N}\sum_{i=1}^Nf(x)</script><p>令$g=fp$，可以得到用求和近似表示$g(x)$的积分</p><script type="math/tex; mode=display">\int_{x\in S}g(x)d\mu\approx\frac{1}{N}\sum_{i=1}^N\frac{g(x)}{p(x)}</script><p>为了得到更好的估计（方差最小）需要$p$和$f$<strong>形状相似</strong></p><h4 id="蒙特卡洛方法的渲染方程"><a href="#蒙特卡洛方法的渲染方程" class="headerlink" title="蒙特卡洛方法的渲染方程"></a>蒙特卡洛方法的渲染方程</h4><p>将蒙特卡洛方法用在渲染方程</p><script type="math/tex; mode=display">L_o(w_r)=\int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)\cos\theta_idw_i</script><p>得到带概率密度函数$p(x)$的蒙特卡洛近似：</p><script type="math/tex; mode=display">L_o(w_r)=\frac{1}{N}\sum_{i=1}^N\frac{\rho(w_i,w_r)L_i(w_i)\cos\theta_i}{p(w_i)}</script><hr><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><blockquote><p>重要性采样（$Importance\ Sampling$）是一种用于估计统计量（如期望值）的蒙特卡洛方法</p></blockquote><p>在光线追踪的蒙特卡洛方法中，为了更小的方程，需要$\rho(w,w_r)L_i(w)\cos\theta_i$正比于$p(w)$</p><hr><h3 id="Cosine-weighted-半球采样"><a href="#Cosine-weighted-半球采样" class="headerlink" title="$Cosine-weighted$半球采样"></a>$Cosine-weighted$半球采样</h3><blockquote><p>这种采样技术用于模拟光线从一个表面向半球方向散射的情况，通常用于计算漫反射（diffuse）或高光（specular）光照的贡献。</p></blockquote><p>$Cosine-weighted$半球采样用于蒙特卡洛方法的渲染方程中，假定$p(w)$正比于$\cos\theta$</p><script type="math/tex; mode=display">\begin{align}\int_{\Omega^+}p(w)dw &= \int_{\theta=0}^\frac{\pi}{2}\int_{\phi=0}^{2\pi}c\cos\theta \sin\theta d\theta\phi\\\\&= \pi c\end{align}</script><p>所以联合概率密度函数$p(w)=\frac{\cos\theta}{\pi},p(\theta,\phi)=\frac{\cos\theta\sin\theta}{\pi}$</p><p>边缘概率密度函数</p><script type="math/tex; mode=display">\begin{align}p(\theta) &= \int_0^{2\pi}p(\theta,\phi)d\phi=\sin 2\theta\\\\p(\phi\vert\theta) &= \frac{p(\theta,\phi)}{p(\theta)}=\frac{1}{2\pi}\end{align}</script><p>边缘累计密度函数</p><script type="math/tex; mode=display">\begin{align}C_\theta(\theta_0) &= \int_0^{\theta_0}p(\theta)d\theta=\sin^2\theta\\\\C_\phi(\phi_0\vert\theta) &= \int_0^{\phi_0}p(\phi\vert\theta)d\theta=\frac{\phi}{2\pi}\end{align}</script><p>求反函数得到随机变量$\delta\in [0,1]$的表达式</p><script type="math/tex; mode=display">\begin{align}\theta=C_\theta^{-1}(\xi_1) &= \sin^{-1}\sqrt{\xi_1}\\\phi=C_\phi^{-1}(\xi_2) &= 2\pi\xi_2\end{align}</script><p>转化为三维空间上单位半球面坐标</p><script type="math/tex; mode=display">\begin{align}x &= \sin\theta\cos\phi=\cos(2\pi\xi_2)\sqrt{\xi_1}\\y &= \sin\theta\sin\phi=\sin(2\pi\xi_2)\sqrt{\xi_1}\\z &= \cos\theta=\sqrt{1-\xi_1}\end{align}</script><hr><h3 id="BRDF-重要性采样"><a href="#BRDF-重要性采样" class="headerlink" title="$BRDF$重要性采样"></a>$BRDF$重要性采样</h3><p>对$BRDF$项采样需要特定的模型，这里考虑$Cook-Torrance$微表面模型</p><script type="math/tex; mode=display">\rho(w_i,w_r)=\frac{k_d}{\pi}+\frac{F(w_i,h)G(w_i,w_r,h)D(h)}{4(w_i\cdot n)(w_r\cdot n)}</script><p>其中</p><ul><li><p>$\frac{k_d}{\pi}$是漫反射项，$k_s\in [0,1]$为半球面方向反射系数$HDFR$</p></li><li><p>$h=\frac{w_r-w_i}{\lVert w_r-w_i\rVert}$为单位半程向量</p></li><li><p>$n$为表面法向量</p></li><li><p>$F(w_i,h)$为菲涅尔项，$G(w_i,w_r,h)$为几何遮蔽项，$G(h)$为法线分布函数</p></li></ul><p>几何遮蔽函数$G$只只返回$0,1$表示是否可见，是不连续的，不对它考虑；为了简化计算也忽略菲涅尔项$F$，这里选用$GGX$法线分布函数</p><script type="math/tex; mode=display">D(h)=\frac{\alpha^2}{\pi((n\cdot h)^2(\alpha^2-1)+1)^2}</script><p>其中$\alpha$是表面的不透明度</p><h4 id="D-h-的采样"><a href="#D-h-的采样" class="headerlink" title="$D(h)$的采样"></a>$D(h)$的采样</h4><p>根据$D(h)$的定义式$D(h)=\frac{dA_h}{dAdh}$可得</p><script type="math/tex; mode=display">\int_{\Omega^+}D(h)dAdh(n\cdot h)=dA</script><p>化简可以得方程</p><script type="math/tex; mode=display">\int_{\Omega^+}(n\cdot h)D(h)dh=1</script><p>可以看出，被积函数正好是概率密度函数，这里还需要把积分项$dh$变换为$dw_i$，一入射角方向为$z$轴根据几何关系得</p><script type="math/tex; mode=display">\begin{align}\frac{dh}{dw_i} &= \frac{\sin\theta_hd\theta_h\ d\phi}{\sin 2\theta_hd2\theta_hd\phi}\\\\&= \frac{\sin\theta_hd\theta_h\ d\phi}{4\sin\theta_{w_h}\cos\theta_hd\theta_hd\phi}\\\\&= \frac{1}{4\cos\theta_h}\\&= \frac{1}{4(w_i\cdot h)}\end{align}</script><p><em>不过由于计算的原因，在最后在做这个变换</em></p><p>代入$GGX$法线分布函数</p><script type="math/tex; mode=display">\begin{align}\int_{\Omega^+}(n\cdot h)GXX(h)dh &= \int_{\Omega^+}\frac{(n\cdot h)\alpha^2}{\pi((n\cdot h)^2(\alpha^2-1)+1)^2}dh\\\\&= \int_{\theta=0}^{\frac{\pi}{2}}\int_{\phi=0}^{2\pi}\frac{\sin\theta\cos\theta\alpha^2}{\pi(\cos^2\theta(\alpha^2-1)+1)^2}d\theta d\phi\\\\\end{align}</script><p>所以对$h$采样的概率密度函数为</p><script type="math/tex; mode=display">p_h(\theta,\phi)=\frac{\sin\theta\cos\theta\alpha^2}{\pi(\cos^2\theta(\alpha^2-1)+1)^2}</script><p>边缘概率密度</p><script type="math/tex; mode=display">\begin{align}p_h(\theta) &= \int_{\phi=0}^{2\pi}p_h(\theta,\phi)=\frac{2\sin\theta\cos\theta\alpha^2}{(\cos^2\theta(\alpha^2-1)+1)^2}\\\\p_h(\phi) &=\frac{p_h(\theta,\phi)}{p_h(\theta)}=\frac{1}{2\pi}\end{align}</script><p>累积密度函数</p><script type="math/tex; mode=display">\begin{align}c_h(\theta_0) &= \int_0^{\theta_0}p_h(\theta)d\theta\\\\&= \int_0^{\theta_0}\frac{2\sin\theta\cos\theta\alpha^2}{(\cos^2\theta(\alpha^2-1)+1)^2}d\theta\\\\&= \alpha^2\int_{\theta_0}^0\frac{d\cos^2\theta}{(\cos^2\theta(\alpha^2-1)+1)^2}\\\\&= \frac{\alpha^2}{\alpha^2-1}\int_{\cos^2\theta_0(\alpha^2-1)+1}^{\alpha^2}\frac{dx}{x^2}\\\\&= \frac{\alpha^2}{\alpha^2-1}(-\frac{1}{x})\vert_{\cos^2\theta_0(\alpha^2-1)+1}^{\alpha^2}\\\\&= \frac{\alpha^2}{\cos^2\theta_0(\alpha^2-1)^2+(\alpha^2-1)}-\frac{1}{\alpha^2-1}\end{align}</script><p>其中，$x=\cos^2\theta(\alpha^2-1)+1$</p><script type="math/tex; mode=display">c_h(\phi_0)=\int_0^{\phi_0}p_h(\phi)d\phi=\frac{\phi_0}{2\pi}</script><p>最后求逆</p><script type="math/tex; mode=display">\begin{align}\theta &= c_h^{-1}(\xi_1)=\cos^{-1}\sqrt{\frac{1-\xi_1}{1+\xi_1(\alpha^2-1)}}\\\\\phi &= c_h^{-1}(\xi_2)=2\pi\xi_2\end{align}</script><p>$c_h(\theta_0)$<em>表达式式很复杂，但是求反只需要简单的变换</em>，令$\cos^2\theta_0=x$</p><script type="math/tex; mode=display">\begin{align}\xi &= \frac{\alpha^2}{x(\alpha^2-1)^2+(\alpha^2-1)}-\frac{1}{\alpha^2-1}\\\\&= \frac{\alpha^2-\left[(\alpha^2-1)x+1\right]}{(\alpha^2-1)\left[(\alpha^2-1)x+1\right]}\\\\&= \frac{(1-\alpha^2)x+(\alpha^2-1)}{(\alpha^2-1)^2x+(\alpha^2-1)}\\\\(\alpha^2-1)x\xi+\xi &= 1-x\\\\\left[(\alpha^2-1)\xi+1\right]x &= 1-\xi\\\\x &= \frac{1-\xi}{(\alpha^2-1)\xi+1}\end{align}</script><p>转换为笛卡尔坐标系</p><script type="math/tex; mode=display">\begin{align}X_h &= \sin\theta\cos\phi=\sqrt{\frac{\xi_1\alpha^2}{1+\xi_1(\alpha^2-1)}}\cos(2\pi\xi_2)\\\\Y_h &= \sin\theta\sin\phi=\sqrt{\frac{\xi_1\alpha^2}{1+\xi_1(\alpha^2-1)}}\sin(2\pi\xi_2)\\\\Z_h &= \cos\theta=\sqrt{\frac{1-\xi_1}{1+\xi_1(\alpha^2-1)}}\end{align}</script><p>最后，这里只是对法线采样，需要转换到入射光线$w_r-w_i=w_h$</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;蒙特卡洛积分&quot;&gt;&lt;a href=&quot;#蒙特卡洛积分&quot; class=&quot;headerlink&quot; title=&quot;蒙特卡洛积分&quot;&gt;&lt;/a&gt;蒙特卡洛积分&lt;/h3&gt;&lt;p&gt;设函数$f:S&#92;to R$，随机变量$x&#92;sim p$，根据&lt;strong&gt;大数定理&lt;/stron</summary>
      
    
    
    
    <category term="概率论" scheme="http://example.com/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>简单采样方法</title>
    <link href="http://example.com/2024/11/07/Sampling/"/>
    <id>http://example.com/2024/11/07/Sampling/</id>
    <published>2024-11-07T12:20:18.000Z</published>
    <updated>2024-11-08T00:49:58.023Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h2><blockquote><p>采样方法是指从概率分布中<strong>生成随机样本</strong>的技术</p></blockquote><p><em>以下的采样方法只能在</em>$t[0,1]^R$<em>的空间中采样</em></p><h4 id="简单随机采样（-Simple-Random-Sampling-）"><a href="#简单随机采样（-Simple-Random-Sampling-）" class="headerlink" title="简单随机采样（$Simple\ Random\ Sampling$）"></a>简单随机采样（$Simple\ Random\ Sampling$）</h4><ul><li><p>每个样本都有相同的被选中的概率</p></li><li><p>可以通过伪随机数生成器来实现</p></li></ul><h4 id="系统采样（-Systematic-Sampling-）"><a href="#系统采样（-Systematic-Sampling-）" class="headerlink" title="系统采样（$Systematic Sampling$）"></a>系统采样（$Systematic Sampling$）</h4><ul><li>从列表中随机选择一个起始点，然后按照固定的间隔选择样本</li></ul><h4 id="分层采样（-Stratified-Sampling-）"><a href="#分层采样（-Stratified-Sampling-）" class="headerlink" title="分层采样（$Stratified\ Sampling$）"></a>分层采样（$Stratified\ Sampling$）</h4><ul><li>将总体分成不同的层，然后从每一层中进行随机采样</li></ul><h3 id="分层采样（Stratified-Sampling）"><a href="#分层采样（Stratified-Sampling）" class="headerlink" title="分层采样（Stratified Sampling）"></a>分层采样（Stratified Sampling）</h3><ul><li>将总体分成不同的层，然后从每一层中进行随机采样。</li></ul><hr><h2 id="选择随机点"><a href="#选择随机点" class="headerlink" title="选择随机点"></a>选择随机点</h2><p>采样方法需要处理非“矩形”空间的采样，它将等分布的点作为输入，输出预期采样空间的一个点集，这个变换满足</p><p><strong>在矩形空间的均匀分布变换为采样空间的均匀分布</strong></p><h3 id="逆-CDF-采样（-Inverse-CDF-Sampling-）"><a href="#逆-CDF-采样（-Inverse-CDF-Sampling-）" class="headerlink" title="逆$CDF$采样（$Inverse\ CDF\ Sampling$）"></a>逆$CDF$采样（$Inverse\ CDF\ Sampling$）</h3><blockquote><p>使用概率分布的<strong>逆</strong>累积分布函数（$CDF$）来生成样本</p></blockquote><p>设概率密度函数$p(x),x_{min}\le x\le x_{max}$，逆$CDF$采样方法从一组随机数$\xi_i\in[0,1]$生成<strong>具有密度</strong>$f$的随机数$\alpha_i$</p><p>累积分布函数$C(x)$</p><script type="math/tex; mode=display">Probability(\alpha< x)\equiv C(x)=\int_{x_{min}}^xp(t)dt</script><p>则有</p><script type="math/tex; mode=display">\alpha_i=C^{-1}(\xi_i)</script><p>其中$C^{-1}$表示$C$的反函数，如果不止一维，需要分解函数</p><p>具体的说，对半径为$R$的圆盘<strong>均匀采样</strong>，$p(\phi,r)=\frac{1}{\pi R^2}$</p><script type="math/tex; mode=display">C(r,\phi)=\int_{r=0}^R\int_0^\phi p(\phi,r)rdrd\phi=\frac{\phi r^2}{2\pi R^2}</script><p>令$f(\phi)=C(\phi)=\frac{\phi}{2\pi},g(r)=C(r\vert\phi)=\frac{r^2}{R^2}$（边缘$CDF$）</p><p>取反函数</p><script type="math/tex; mode=display">\begin{align}f^{-1}(\xi_{i_i}) &=\phi_i=2\pi\xi_{i_1}\\g^{-1}(\xi_{i_2}) &=r=R\sqrt{\xi_{i_2}}\end{align}</script><h3 id="半球面均匀采样"><a href="#半球面均匀采样" class="headerlink" title="半球面均匀采样"></a>半球面均匀采样</h3><p>这里考虑普适性的<strong>单位半球面</strong>有均匀概率密度分布函数$p(w)$</p><script type="math/tex; mode=display">\begin{align}\int_{\Omega^+}p(w)dw &= \int_{\theta=0}^\frac{\pi}{2}\int_{\phi=0}^{2\pi}p(\theta,\phi)\sin\theta d\theta d\phi\\\\&= 2\pi\end{align}</script><p>综上，联合概率密度函数$p(\theta,\phi)=\frac{\sin\theta}{2\pi}$，分解为</p><script type="math/tex; mode=display">\begin{align}p(\theta) &= \int_0^{2\pi}p(\theta,\phi)d\phi=\sin\theta\\\\p(\theta\vert\phi) &= \frac{p(\theta,\phi)}{p(\theta)}=\frac{1}{2\pi}\end{align}</script><p>边缘累计密度函数</p><script type="math/tex; mode=display">\begin{align}C_{\theta}(\theta_0) &=\int_0^{\theta_0} p(\theta)d\theta=1-\cos\theta\\\\C_{\phi}(\phi_0\vert\theta) &= \int_0^{\phi_0} p(\phi\vert\theta)d\phi=\frac{\phi}{2\pi}\end{align}</script><p>使用逆分布取样方法</p><script type="math/tex; mode=display">\begin{align}\theta &= C_{\theta}^{-1}(\xi_1) =\cos^{-1}(1-\xi_1)\\\phi &= C_{\phi}^{-1}(\xi_2)=2\pi\xi_2\end{align}</script><p>转化为三维坐标（单位半球面上的点）</p><script type="math/tex; mode=display">\begin{align}x &= \sin\theta\cos\phi=\cos(2\pi\xi_2)\sqrt{1-(1-\xi_1^2)^2}\\y &= \sin\theta\sin\phi=\sin(2\pi\xi_2)\sqrt{1-(1-\xi_1^2)^2}\\z &= \cos\theta=1-\xi_1\end{align}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;采样方法&quot;&gt;&lt;a href=&quot;#采样方法&quot; class=&quot;headerlink&quot; title=&quot;采样方法&quot;&gt;&lt;/a&gt;采样方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;采样方法是指从概率分布中&lt;strong&gt;生成随机样本&lt;/strong&gt;的技术&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="概率论" scheme="http://example.com/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>体渲染模型</title>
    <link href="http://example.com/2024/11/06/Volume-Rendering/"/>
    <id>http://example.com/2024/11/06/Volume-Rendering/</id>
    <published>2024-11-06T14:58:04.000Z</published>
    <updated>2024-11-07T16:46:33.053Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>体渲染把气体等物质抽象成一团飘忽不定的<strong>粒子群</strong>。光线在穿过这类物体时，其实就是光子在跟粒子发生碰撞的过程</p></blockquote><p>考虑一段<strong>单位体积</strong>中，光子沿<strong>直线</strong>传播，则光子的运动可能会有如下情况</p><ul><li><p><strong>吸收</strong>（$absorption$）：光子被粒子吸收</p></li><li><p><strong>放射</strong>（$emission$）：宏观表现为物体自发光</p></li><li><p><strong>外散射</strong>（$out-scattering$）：光子在撞击到粒子后，可能会发生弹射，导致方向发生偏移,脱离当前定义的光子群</p></li><li><p><strong>内散射</strong>（$in-scattering$）：其他方向的光子在撞到粒子后，可能和当前方向上的光子重合</p></li></ul><p>若有点$P$在$w$方向的入射（辐射）强度$I_i$和出射辐射强度$I_r$，则有</p><p>$I_o-I_i=emission-absorption-scattering_{out}+scattering_{in}$</p><hr><h3 id="吸收（-absorbing-）"><a href="#吸收（-absorbing-）" class="headerlink" title="吸收（$absorbing$）"></a>吸收（$absorbing$）</h3><p>从$I_i$到$I_o$的光路截取一段到点$P$的<strong>距离</strong>为$s$<strong>微元区域</strong>，其垂直于光线的<strong>底面积</strong>为$E$，高为$ds$，单位体积包含的粒子数$\rho(s)$</p><p>则有光子吸收比例等价于：粒子横截面积比例</p><script type="math/tex; mode=display">\frac{\rho(s)\ Eds\ A}{E}=\rho(s)Ads</script><p>其中$A$为粒子最大的横截面积，且值域为$[0,1]$</p><blockquote><p>$tips$ 因为已经取了光路的<strong>横截微元体</strong>，当它切分的足够细，$ds$小到跟粒子直径一样大的时候，可以认为粒子在圆柱体高这个方向上<strong>不会互相重叠</strong></p></blockquote><p>所以在一段$ds$长度的光路中，（<em>只考虑吸收</em>）有</p><script type="math/tex; mode=display">\begin{align}dI &= -\rho(s)Ads\ I(s)\\\frac{dI}{ds}  &=-\rho(s)AI(s)\\&=-\tau_a(s)I(s)\\I(s) &= I_0\ exp\left(-\int_0^s\tau_a(t)dt\right)\end{align}</script><p>此处$I_0$表示常微分方程中的常数项，物理意义上表示光线的起始点处的光总强度$I_i$，即</p><script type="math/tex; mode=display">I_o=I_i\ exp\left(-\int_i^{o}\tau_a(t)dt\right)</script><p>定义<strong>透视比</strong>$T=\frac{I_s}{I_i}=exp\left(-\int_i^{s}\tau_a(t)dt\right)$<strong>反应</strong>光线衰减的幅度</p><p>$\tau_a(s)=\rho(s)A$也被称为<strong>光学厚度</strong>，它的值越小，粒子群越透明</p><hr><h3 id="放射（-emission-）"><a href="#放射（-emission-）" class="headerlink" title="放射（$emission$）"></a>放射（$emission$）</h3><p>假设粒子单位横截面积（距离$s$处）发射一束光的辐射强度为$I_e(s)$，考虑<strong>吸收</strong>后可以建立方程</p><script type="math/tex; mode=display">\begin{align}dI &= \rho(s)AI_e(s)ds\\\frac{dI}{ds} &= \rho(s)AI_e(s)\\&= \tau_a(s) I_e(s)\end{align}</script><hr><h3 id="散射（-scattering-）"><a href="#散射（-scattering-）" class="headerlink" title="散射（$scattering$）"></a>散射（$scattering$）</h3><p>散射和吸收的物理性质不能一概而论，用$\tau_s(s)$来表示外散射对光线的削弱比例</p><h4 id="外散射（-out-scattering-）"><a href="#外散射（-out-scattering-）" class="headerlink" title="外散射（$out-scattering$）"></a>外散射（$out-scattering$）</h4><p>粒子除了吸收光子，也可能会弹射光子，这个过程称为外散射，即光子被弹射出原本的光路，导致光线强度减弱，可以定义为</p><script type="math/tex; mode=display">\frac{dI}{ds}=-\tau_s(s)I(s)</script><h4 id="内散射-（-in-scattering-）"><a href="#内散射-（-in-scattering-）" class="headerlink" title="内散射 （$in-scattering$）"></a>内散射 （$in-scattering$）</h4><p>光子可以被弹射走，自然就有其他光路的光子被弹射到当前光路，这一过程就是内散射。内散射需要考虑其他光路光强，这里用$I_s$表示</p><script type="math/tex; mode=display">\frac{dI}{ds}=\tau_s(s)I_s(s)</script><hr><h3 id="体渲染方程"><a href="#体渲染方程" class="headerlink" title="体渲染方程"></a>体渲染方程</h3><p>综合四种光子运动</p><script type="math/tex; mode=display">\frac{dI}{ds}=-\tau_a(s)I(s)+\tau_a(s)I_e(s)-\tau_s(s)I(s)+\tau_s(s)I_s(s)</script><p>令$\tau_t(s)=\tau_s(s)$，解常微分方程</p><script type="math/tex; mode=display">\begin{align}I(s)=\frac{dI}{ds} &= -\tau_a(s)I(s)+\tau_a(s)I_e(s)-\tau_s(s)I(s)+\tau_s(s)I_s(s)\\\\&= -\tau_t(s)I(s)+\tau_a(s)I_e(s)+\tau_s(s)I_s\\\\&= \int_0^se^{\left(-\int_0^t\tau_t(u)du\right)}(\tau_a(t)I_e(t)+\tau_s(s)I_s(t))+I_0e^{\left(-\int_0^t\tau_t(t)dt\right)}\end{align}</script><p>假设$\tau_t=\tau_a=\tau_a=\sigma$，令$C=I_e+I_s$</p><script type="math/tex; mode=display">\begin{align}I(s) &= \int_0^s e^{\left(-\int_0^t\sigma(u)du\right)}\sigma(t)C(t)dt+I_0e^{\left(-\int_0^s\sigma(t)dt\right)}\\\\&= \int_0^sT(t)\sigma(t)C(t)dt+T(s)I_0\end{align}</script><p>其中</p><script type="math/tex; mode=display">T(t)=e^{\left(-\int_0^t\sigma(u)du\right)}</script><hr><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>将$[0,s]$的光路等距划分为$N$个区间$[t_i,t_{i+1}],0\le i\le N-1$</p><p>令$I[t_i,t_{i+1}]=\int_{t_i}^{t_{i+1}}T(t)C(t)\sigma(t)dt$，再令区间内$\sigma(t)$处处相等，则有</p><script type="math/tex; mode=display">I[t_i,t_{i+1}]=C_i\sigma_i\int_{t_i}^{t_{i+1}}T(t)dt</script><p>$T(t)$是从光路上$0$到$t$的积分，令$T(begin\to end)$是光路上（从$begin$到$end$）路径段的积分</p><script type="math/tex; mode=display">\begin{align}T(t)=T(0\to s) &= e^{\left(-\int_0^t\sigma(u)du\right)}\\\\&= e^{\left(-\int_0^{t_i}\sigma(u)du-\int_{t_i}^t\sigma(u)du\right)}\\\\&= e^{\left(-\int_0^{t_i}\sigma(u)du\right)}e^{\left(-\int_{t_i}^t\sigma(u)du\right)}\\\\&= T(0\to t_i)T(t_i\to t)\end{align}</script><script type="math/tex; mode=display">\begin{align}I[t_i,t_{i+1}] &= C_i\sigma_i\int_{t_i}^{t_{i+1}}T(0\to t)dt\\\\&= C_i\sigma_i\int_{t_i}^{t_{i+1}}T(0\to t_i)T(t_i\to t)dt\\\\&= C_i\sigma_iT(0\to t_i)\int_{t_i}^{t_{i+1}}T(t_i\to t)dt\\\\&= C_i\sigma_iT(0\to t_i)\int_{t_i}^{t_{i+1}}e^{\left(-\sigma(t-t_i)\right)}dt\\\\&= C_iT(0\to t_i)(1-e^{\left(-\sigma(t_{i+1}-t_i)\right)})\end{align}</script><p>令$\delta=t_{i+1}-t_i$，累加各个区间</p><script type="math/tex; mode=display">\begin{align}I(s)&=\int_0^sT(t)\sigma(t)C(t)dt+T(s)I_0\\\\&=\sum_{i=0}^{N-1}I[t_i,t_{i+1}]+T(0\to s)I_0\\\\&=\sum_{i=0}^{N-1}C_iT(0\to t_i)\left(1-e^{(-\sigma(t_NaN-t_i))}\right)+T(0\to s)I_0\\\\&=\sum_{i=0}^{N-1}\left(1-e^{-\sigma(t)\delta_i}\right)C_iT(0\to t_i)+T(0\to s)I_0\end{align}</script><p>$T$积分域都从$0$开始，最后可得体渲染方程</p><script type="math/tex; mode=display">I(s)=\sum_{i=0}^{N-1}(1-e^{-\sigma(t)\delta_i})C_iT(t_i)+T(s)I_0</script><script type="math/tex; mode=display">T(s)=e^{\left(\sum_{j=0}^{t_j={s-1}}\sigma(j)\delta_j\right)}</script><script type="math/tex; mode=display">\delta=t_{i+1}-t_i</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;体渲染把气体等物质抽象成一团飘忽不定的&lt;strong&gt;粒子群&lt;/strong&gt;。光线在穿</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>四元数与旋转</title>
    <link href="http://example.com/2024/11/05/Quaternion-rotation/"/>
    <id>http://example.com/2024/11/05/Quaternion-rotation/</id>
    <published>2024-11-05T01:52:18.000Z</published>
    <updated>2024-11-05T14:33:55.309Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="绕坐标轴旋转"><a href="#绕坐标轴旋转" class="headerlink" title="绕坐标轴旋转"></a>绕坐标轴旋转</h3><p>考虑在$XOY$平面上的二维旋转：$P$沿逆时针旋转$\theta$角度得$P^\prime$</p><p>根据旋转定义</p><script type="math/tex; mode=display">\lVert P\rVert=\lVert P^\prime\rVert\tag{I}</script><p>其中向量$Q(-y_P,x_P)$为$P$逆时针<strong>旋转</strong>$90^\circ$得到，$P$和$Q$正交</p><p>则有$P^\prime=proj_P+proj_Q$，简单来说，$P^\prime$在两个正交基方向上的投影</p><script type="math/tex; mode=display">\begin{align}proj_P &= (\frac{P^\prime\cdot P}{\lVert P\rVert})\frac{P}{\lVert P\rVert}=P\cos\theta\tag{reference I}\\proj_Q &= (\frac{P^\prime\cdot Q}{\lVert Q\rVert})\frac{Q}{\lVert Q\rVert}=Q\sin\theta\tag{reference I}\end{align}</script><p><img src="https://s2.loli.net/2024/11/05/4NBhwj8xWPsu6eb.png" alt=""></p><script type="math/tex; mode=display">\begin{align}P^\prime &= P\cos\theta+Q\sin\theta\\P_x^\prime &= P_x\cos\theta-P_y\sin\theta\\P_y^\prime &= P_y\cos\theta+P_x\sin\theta\\\end{align}</script><p>转换为矩阵</p><script type="math/tex; mode=display">P^\prime=\left[\begin{matrix}\cos\theta & -\sin\theta\\\sin\theta & \cos\theta\end{matrix}\right]P</script><p>将这一结论推广到<strong>笛卡尔坐标系</strong>中<strong>绕坐标轴</strong>的旋转</p><ul><li>绕$X$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_X(P,\theta)=\left[\begin{matrix}1 & 0 &  0\\ 0 &\cos\theta & -\sin\theta\\0 &\sin\theta & \cos\theta\end{matrix}\right]P</script><ul><li>绕$Y$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_Y(P,\theta)=\left[\begin{matrix}0 &\cos\theta & -\sin\theta\\0 & 1 & 0\\0 &\sin\theta & \cos\theta\end{matrix}\right]P</script><ul><li>绕$Z$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_Z(P,\theta)=\left[\begin{matrix}0 &\cos\theta & -\sin\theta\\0 &\sin\theta & \cos\theta\\0 & 0 & 1\end{matrix}\right]P</script><hr><h3 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h3><script type="math/tex; mode=display">Rotate_Q(ai+bj+ck,\theta)=Rotate_Q(ai,\theta)+Rotate_Q(bj,\theta)+Rotate_Q(ck,\theta)\tag{II}</script><p>考虑三维空间中向量$P$绕旋转轴$Q$逆时针旋转$\theta$度得到$P^\prime$</p><p>同二维旋转一样，为$P^\prime$建立正交基</p><script type="math/tex; mode=display">\begin{align}P &= Proj_QP+Perp_QP\\P^\prime &= Rotate_Q(P,\theta)\\&= Rotate_Q(Proj_QP,\theta)+Rotate_Q(Perp_QP,\theta)\tag{reference II}\\&= Proj_QP+Rotate_Q(Perp_QP,\theta)\end{align}</script><p>因为$Perp_QP$向量旋转后的向量在二维平面，且可以用正交基$Q\times P$，$Perp_QP$表示，所有又是一个二维平面旋转问题</p><script type="math/tex; mode=display">\begin{align}\lVert Perp_QP\rVert &= P\sin\alpha =\frac{\lVert Q\times P\rVert}{\lVert Q \rVert}\\\\Rotate_Q(Perp_QP,\theta) &= (Perp_QP)\cos\theta+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\end{align}</script><p>其中</p><script type="math/tex; mode=display">\begin{align}Proj_QP &= (\frac{P\cdot Q}{\lVert Q\rVert})\frac{Q}{\lVert Q\rVert}=(P\cdot\hat{Q})\hat{Q}\\Perj_QP &= P-Prej_QP=P-(P\cdot\hat{Q})\hat{Q}\end{align}</script><p><img src="https://s2.loli.net/2024/11/05/AFPLJTnp8gEWVHC.png" alt=""></p><p>综上</p><script type="math/tex; mode=display">\begin{align}Rotate_Q(P,\theta) &= (P\cdot\hat{Q})\hat{Q}+(P-(P\cdot\hat{Q})\hat{Q})\cos\theta+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\\\\&= P\cos\theta+(1-\cos\theta)(P\cdot\hat{Q})\hat{Q}+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\\\\&= P\cos\theta+(1-\cos\theta)\hat{Q}\hat{Q}^TP+(\hat{Q}\times P)\sin\theta\end{align}</script><blockquote><p>$tips$ $(P\cdot Q)Q=QQ^TP$</p></blockquote><p>转换为矩阵表达$c=\cos\theta,s=sin\theta$</p><script type="math/tex; mode=display">Rotate_Q(P,\theta)=\left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{matrix}\right]cP+\left[\begin{matrix}\hat{Q}_x^2 & \hat{Q}_x\hat{Q}_y & \hat{Q}_x\hat{Q}_z\\\hat{Q}_x\hat{Q}_y & \hat{Q}_y^2 & \hat{Q}_y\hat{Q}_z\\\hat{Q}_x\hat{Q}_z & \hat{Q}_y\hat{Q}_z & \hat{Q}_z^2\end{matrix}\right](1-c)P+\left[\begin{matrix}0 & -\hat{Q}_z & \hat{Q}_y\\\hat{Q}_z & 0 & -\hat{Q}_x\\-\hat{Q}_y & \hat{Q}_x & 0\end{matrix}\right]sP</script><p><em>可以再缩写成一个矩阵，不过没有特征就不再展示</em></p><hr><h3 id="四元数的基本性质"><a href="#四元数的基本性质" class="headerlink" title="四元数的基本性质"></a>四元数的基本性质</h3><blockquote><p>四元数（$Quaternion$）是数学中一种扩展的复数形式，由爱尔兰数学家威廉·卢云·哈密顿在1843年发现。四元数是一种包含四个分量的超复数</p></blockquote><p>四元数$q$通常具有以下形式</p><script type="math/tex; mode=display">q=s+xi+yj+zk=(s,v)</script><p>其中$s,x,y,z$是实数，$i,j,k$为虚数单位，$v$为虚部向量，且有</p><ul><li><p>$i^2=j^2=ijk=-1$</p></li><li><p>$ij=-ji=k$</p></li><li><p>$jk=-kj=i$</p></li><li><p>$ki=-ik=j$</p></li></ul><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><script type="math/tex; mode=display">\begin{align}q_a &= s_a+x_ai+y_aj+z_ak\\q_b &= s_b+x_bi+y_bj+z_bk\\q_a+q_b &=s_a+s_b+(x_a+x_b)i+(y_a+y_b)j+(z_a+z_b)k\end{align}</script><h4 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h4><script type="math/tex; mode=display">\begin{align}q_aq_b &= (s_a+x_ai+y_aj+z_ak)(s_b+x_bi+y_bj+z_bk)\\&= i(s_ax_b+s_bx_a+y_az_b-y_bz_a)\\&+ j(s_ay_b+s_by_a-x_az_b+x_bz_a)\\&+ k(s_az_b+s_bz_a+x_ay_b-x_by_a)\\&+ s_as_b-x_ax_b-y_ay_b-z_az_b\\&= (s_ab_a-q_{av}\cdot q_{bv},q_{av}\times q_{bv}+s_aq_{av}+s_bq_{bv})\end{align}</script><p>标量乘法：$tq=(ts,tv)$</p><h4 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h4><script type="math/tex; mode=display">q^\ast=(s,-v)</script><h4 id="欧几里得范数"><a href="#欧几里得范数" class="headerlink" title="欧几里得范数"></a>欧几里得范数</h4><script type="math/tex; mode=display">\begin{align}\lVert q\rVert &= \sqrt{qq^\ast}=\sqrt{q^\ast q}\\&=\sqrt{s^2+v^2+0i+0j+0k}\\&=\sqrt{s^2+x^2+y^2+z^2}\end{align}</script><p>两个四元数乘积的模等于模的乘积，即</p><script type="math/tex; mode=display">\lVert q_aq_b\rVert=\lVert q_a\rVert \lVert q_b\rVert</script><p><em>直接展开即可证明，因为计算量较大，此处不进一步证明</em></p><h4 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h4><p>定义单位四元数$I$满足$\lVert I\rVert=1$，四元数的逆满足$q^{-1}q=qq^{-1}=I$，则四元数的逆可以表示为</p><script type="math/tex; mode=display">q^{-1}=\frac{q^\ast}{qq^\ast}=\frac{q^\ast}{(\lVert q\rVert)^2}</script><hr><h3 id="用四元数表示旋转"><a href="#用四元数表示旋转" class="headerlink" title="用四元数表示旋转"></a>用四元数表示旋转</h3><h4 id="旋转满足的条件"><a href="#旋转满足的条件" class="headerlink" title="旋转满足的条件"></a>旋转满足的条件</h4><p>对于特定的旋转轴和旋转角度：函数$Rotate_Q(P,\theta)=\phi(P)$映射满足一下条件</p><ul><li>向量长度不变：</li></ul><script type="math/tex; mode=display">\lVert \phi(P)\rVert=\lVert P\rVert\tag{I}</script><ul><li>向量间夹角不变：</li></ul><script type="math/tex; mode=display">\phi(P_1)\cdot\phi(P_2)=P_1\cdot P_2\tag{II}</script><ul><li>惯用手不变：</li></ul><script type="math/tex; mode=display">\phi(P_1)\times\phi(P_2)=P_1\times P_2\tag{III}</script><blockquote><p>$tips$: 惯用手不变的性质保证了旋转的方向，否则向量可能会逆转更大的角度到达目标位置</p></blockquote><p>扩展函数$\phi$使其成为从四元数到自身的映射：</p><script type="math/tex; mode=display">\phi(s+P)=s+\phi(P)\tag{IV}</script><p>利用笛卡尔坐标系中的的向量$P$建立实数部为$0$的四元数$P^\prime=(0,P)$，则可以有</p><script type="math/tex; mode=display">\begin{align}\phi(P_1^\prime P_2^\prime) &= \phi(P_1\times P_2-P_1\cdot P_2)\\&= -P_1\cdot P_2+\phi(P_1\times P_2)\tag{reference IV}\\&= -\phi(P_1)\cdot\phi(P_2)+\phi(P_1)\times\phi(P_2)\tag{reference II and III}\\&= \phi(P_1^\prime)\phi(P_2^\prime)\end{align}</script><p>所以建立条件等式$V$替换$II,III$</p><script type="math/tex; mode=display">\phi(P_1^\prime P_2^\prime)=\phi(P_1^\prime)\phi(P_2^\prime)\tag{V}</script><h4 id="四元数旋转条件证明"><a href="#四元数旋转条件证明" class="headerlink" title="四元数旋转条件证明"></a>四元数旋转条件证明</h4><blockquote><p>$tips$ 有些资料可能会重用$P$表示点$P$的构成的实部为$0$的四元数，这里采用符号$P^\prime$，上面的条件也需要改变</p></blockquote><p>接下来证明函数$\phi_q$满足条件$I,V$</p><script type="math/tex; mode=display">\phi_q(P^\prime)=qP^\prime q^{-1}</script><script type="math/tex; mode=display">\begin{align}I:\lVert\phi_q(P^\prime) \rVert &=\lVert qP^\prime q^{-1}\rVert\\&= \lVert q\rVert\lVert P^\prime\rVert\lVert q^{-1}\rVert\\&= \lVert P^\prime \rVert\lVert qq^{-1}\rVert\\&= \lVert P^\prime\rVert\end{align}</script><script type="math/tex; mode=display">\begin{align}V:\phi_q(P_1^\prime P_2^\prime) &= qP_1^\prime P_2^\prime q^{-1}\\&= qP_1^\prime q^{-1}qP_1^\prime q^{-1}\\&= \phi(P_1^\prime)\phi(P_2^\prime)\end{align}</script><p>只要找到一个$q$对应于绕旋转轴$Q$旋转$\theta$度，则有$Rotate_Q(P,\theta)\equiv\phi_q(P^\prime)$</p><hr><h3 id="解-phi-q-P-prime"><a href="#解-phi-q-P-prime" class="headerlink" title="解$\phi_q(P^\prime)$"></a>解$\phi_q(P^\prime)$</h3><p>设单位四元数（$\lVert q\rVert=1$）$q=(s,V)$，则</p><script type="math/tex; mode=display">\begin{align}\phi_q(P^\prime) &= qP^\prime q^{-1}\\&= (s+V)P^\prime\frac{q^\ast}{(\lVert  q\rVert)^2}\\&= (s+V)P^\prime(s-V)\\&= (-V\cdot P+(V\times P+sP))(s-V)\\&= (-V\cdot P)s-(V\times P+sP)\cdot(-V)\\&+ (V\times P+sP)\times(-V)+(-V\cdot P)(-V)+s(V\times P+sP)\\&= -s(V\cdot P)+(V\times P)\cdot V+s(P\cdot V)\\&- V\times P\times V-s(P\times V)+VV^TP+s(V\times P)+s^2P\\&= -V\times P\times V+2s(V\times P)+VV^TP+s^2P\end{align}</script><p>前面较复杂的部分都是四元数乘法，化简部分较为复杂，下面是需要主要的点</p><ul><li><p>$(P\cdot V)V=VV^TP$</p></li><li><p>$(V\times P)\cdot P=0$</p></li><li><p>$P\times V=-V\times P$</p></li></ul><p>直接对$V\times P\times V$展开</p><script type="math/tex; mode=display">\begin{align}&i\ ((V_y^2+V_z^2)P_x-V_xV_yP_y-V_xV_zP_z)\\&j\ (-V_xV_yP_y+(V_x^2+V_z^2)P_y-V_yV_zP_z)\\&k\ (-V_xV_zP_x-V_yV_zP_y+(V_x^2+V_y^2)P_z)\end{align}</script><p>展开为矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}(\lVert V\rVert)^2 & 0 & 0\\0 & (\lVert V\rVert)^2 & 0\\0 & 0 & (\lVert V\rVert)^2\end{matrix}\right]P-\left[\begin{matrix}V_x^2 & V_xV_y & V_xV_z\\V_xV_y & V_y^2 & V_yV_z\\V_xV_z & V_yV_z & V_z^2\end{matrix}\right]P</script><p>综上，$V\times P\times V=((\lVert V\rVert)^2I-VV^T)P$，其中$I$为单位向量</p><blockquote><p>$tips$ 已经解出了具体表达式，可以直接使用$P$而不用区分$P^\prime$</p></blockquote><p>带回得</p><script type="math/tex; mode=display">\phi_q(P)=(s^2-(\lVert V\rVert)^2)P+2s(V\times P)+2VV^TP</script><hr><h3 id="解-q"><a href="#解-q" class="headerlink" title="解$q$"></a>解$q$</h3><script type="math/tex; mode=display">Rotate_Q(P,\theta)=\cos\theta P+\sin\theta (\hat{Q}\times P)+(1-\cos\theta)\hat{Q}\hat{Q}^TP</script><script type="math/tex; mode=display">\phi_q(P)=(s^2-(\lVert V\rVert)^2)P+2s(V\times P)+2VV^TP</script><p>令$V=t\hat{Q}$($q$是单位四元数不代表$V$是单位向量)，$t$为实数</p><script type="math/tex; mode=display">\begin{align}s^2-t^2 &= \cos\theta\\2st &= \sin\theta\\2t^2 &=1-\cos\theta\end{align}</script><p>解出$s=cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><p>综上，得旋转$T=Rotate_Q(P,\theta)$可以用四元数形式表达为</p><script type="math/tex; mode=display">T=\phi_q(P)=(s^2-t^2)P+2s(t\hat{Q}\times P)+2t^2\hat{Q}\hat{Q}^TP</script><p>其中$s=\cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><hr><h4 id="aq-和-a-（-a-为非0常数）为一种旋转"><a href="#aq-和-a-（-a-为非0常数）为一种旋转" class="headerlink" title="$aq$和$a$（$a$为非0常数）为一种旋转"></a>$aq$和$a$（$a$为非0常数）为一种旋转</h4><script type="math/tex; mode=display">aqP\prime(aq)^{-1}=qP^\prime q^{-1}</script><h4 id="q-1q-2-表示先施加旋转-q-2-，然后-q-1"><a href="#q-1q-2-表示先施加旋转-q-2-，然后-q-1" class="headerlink" title="$q_1q_2$表示先施加旋转$q_2$，然后$q_1$"></a>$q_1q_2$表示先施加旋转$q_2$，然后$q_1$</h4><script type="math/tex; mode=display">q_1(q_2P^\prime q_2^{-1})q_1^{-1}=(q_11_2)P^\prime (p_1p_2)^{-1}</script><blockquote><p>$tips$ 四元数乘法具有结合律，不具有交换律</p></blockquote><hr><h3 id="矩阵表达"><a href="#矩阵表达" class="headerlink" title="矩阵表达"></a>矩阵表达</h3><p>改写$Rotate_Q(P,\theta)$</p><script type="math/tex; mode=display">I:\left[\begin{matrix}(s^2-t^2) & 0 & 0\\0 & (s^2-t^2) & 0\\0 & 0 & (s^2-t^2)\end{matrix}\right]P</script><script type="math/tex; mode=display">II:\left[\begin{matrix}0 & -2st\hat{Q}_z & 2st\hat{Q}_y\\2st\hat{Q}_z & 0 & -2st\hat{Q}_x\\-2st\hat{Q}_y & 2st\hat{Q}_x & 0\end{matrix}\right]P</script><script type="math/tex; mode=display">III:\left[\begin{matrix}2t^2\hat{Q}_x^2 & 2t^2\hat{Q}_x\hat{Q}_y & 2t^2\hat{Q}_x\hat{Q}_z\\2t^2\hat{Q}_x\hat{Q}_y & 2t^2\hat{Q}_y^2 & 2t^2\hat{Q}_y\hat{Q}_z\\2t^2\hat{Q}_x\hat{Q}_z & 2t^2\hat{Q}_y\hat{Q}_z & 2t^2\hat{Q}_z^2\end{matrix}\right]P</script><p>用四元数$q=(s,x,y,z)$改写（<em>之后会得到更为简洁的表达</em>）:</p><script type="math/tex; mode=display">\begin{align}x &= t\hat{Q}_x\\y &= t\hat{Q}_y\\z &= t\hat{Q}_z\\\end{align}</script><script type="math/tex; mode=display">x^2+y^2+z^2=t^2(\lVert\hat{Q}\rVert)^2=t^2</script><p>因为$q=I$（单位四元数），所以$s^2+x^2+y^2+z^2=1$</p><p>替换后可得最终表达</p><script type="math/tex; mode=display">\phi_q(P)=\left[\begin{matrix}1-2y^2-2z^2 & 2xy-2sz & 2xz+2sy\\2xy+2sz & 1-2x^2-2z^2& 2yz-2sx\\2xz-2sy& 2yz+2sx & 1-2x^2-2y^2\end{matrix}\right]</script><p>为了完整性，再补充$s=\cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;绕坐标轴旋转&quot;&gt;&lt;a href=&quot;#绕坐标轴旋转&quot; class=&quot;headerlink&quot; title=&quot;绕坐标轴旋转&quot;&gt;&lt;/a&gt;绕坐标轴旋转&lt;/h3&gt;&lt;p&gt;考虑在$XOY$平面上的二维旋转：$P$沿逆时针旋转$&#92;theta$角度得$P^&#92;prime$&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>环境贴图</title>
    <link href="http://example.com/2024/11/04/environment-Mapping/"/>
    <id>http://example.com/2024/11/04/environment-Mapping/</id>
    <published>2024-11-04T09:17:55.000Z</published>
    <updated>2024-11-04T10:04:05.652Z</updated>
    
    <content type="html"><![CDATA[<p>环境贴图是一种用于模拟光滑表面反射周围环境的技术。它通常用于创建金属、水面、玻璃等材质的反射效果。环境贴图通过将环境映射到一个球体、立方体或其他几何形状上，然后将这些环境信息赋予物体表面，来实现反射效果。</p><hr><h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>天空盒是实现环境贴图的一种技术，它是</p><ul><li><p>在场景中一个立方体对象，每个面内侧都贴有纹理贴图</p></li><li><p>天空盒对象围住场景所有对象，理论上，其顶点离所有对象无限远</p></li></ul><h3 id="在光栅成像中实现"><a href="#在光栅成像中实现" class="headerlink" title="在光栅成像中实现"></a>在光栅成像中实现</h3><p>实现<strong>无限远</strong>只需要在可见性判定上处理</p><ol><li>保证天空盒对象包围住相机</li><li>禁用深度测试并渲染天空盒</li><li>开启深度测试渲染其他对象</li></ol><p>因为深度测试中的初始值为无线深，先渲染的天空盒对于其他物体都是无穷远的</p><h3 id="在光线追踪中实现"><a href="#在光线追踪中实现" class="headerlink" title="在光线追踪中实现"></a>在光线追踪中实现</h3><p>不需要建立对象，使用<strong>背景函数</strong>，它接受光线的方向向量</p><p>若一个对象从视体边界射出，从背景函数中查找对象的$RGBA$</p><hr><h3 id="光泽效果"><a href="#光泽效果" class="headerlink" title="光泽效果"></a>光泽效果</h3><ul><li><p>在光线追踪程序中，增加环境项即可</p></li><li><p>在光栅成像程序中，利用观察方向相对于法线的反射方向去查询环境映射的颜色值，简单来讲，<strong>反射光线求交</strong></p></li></ul><hr><h3 id="穹顶"><a href="#穹顶" class="headerlink" title="穹顶"></a>穹顶</h3><p>相比天空盒，穹顶不会存在边界缝隙，但是可能存在图像扭曲</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境贴图是一种用于模拟光滑表面反射周围环境的技术。它通常用于创建金属、水面、玻璃等材质的反射效果。环境贴图通过将环境映射到一个球体、立方体或其他几何形状上，然后将这些环境信息赋予物体表面，来实现反射效果。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;天空盒&quot;&gt;&lt;a href=&quot;#天空</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>阴影贴图</title>
    <link href="http://example.com/2024/11/04/Shadow-Mapping/"/>
    <id>http://example.com/2024/11/04/Shadow-Mapping/</id>
    <published>2024-11-04T06:55:03.000Z</published>
    <updated>2024-11-04T09:16:43.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阴影贴图是一种用于在三维场景中渲染动态阴影的技术。它基于光线的视角来生成深度信息，这些信息随后用于确定场景中的哪些部分处于阴影中。</p></blockquote><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><blockquote><p>阴影贴图技术是基于这样的认知：直接光照不能覆盖到的区域都在阴影中。这个判定只能产生<strong>硬阴影</strong></p></blockquote><h4 id="光源空间的转换"><a href="#光源空间的转换" class="headerlink" title="光源空间的转换"></a>光源空间的转换</h4><p>从<strong>光源主视角</strong>来观察场景。场景中的所有物体都需要根据光源的位置和方向进行转换，以确定它们在光源视角下的位置。</p><p>也就是说，需要<strong>光源的视图变换矩阵</strong>$V_{Light}$，其中观察方向$G-E$等价于主视角</p><h3 id="深度图的生成"><a href="#深度图的生成" class="headerlink" title="深度图的生成"></a>深度图的生成</h3><p>在光源视角下，渲染器会渲染场景的深度信息， <strong>深度贴图</strong>的每个像素代表了从光源到场景中<strong>最近表面的距离</strong>。<br>这个过程和使用相机渲染唯一的不同</p><ul><li><p>使用$V_{Light}$而非$V_{cerama}$</p></li><li><p>只需要完成可见面判定</p></li></ul><blockquote><p>$tips$ 可见面判定和着色通常一起进行，不过从光源处渲染不需要着色</p></blockquote><h3 id="场景的正常渲染"><a href="#场景的正常渲染" class="headerlink" title="场景的正常渲染"></a>场景的正常渲染</h3><p>渲染器从摄像机视角渲染场景，并在渲染每个像素时执行一个额外的步骤：<strong>确定这个像素在光源视角下的深度</strong>。</p><p>具体的说，如果一个点$(x^\prime,y^\prime,z^\prime,w)$可见，但是还不能直接着色，需要判定<strong>光源是否可见</strong></p><p>而光源是否可见又是一个<strong>可见面判定问题</strong>，再一次对<strong>世界坐标下的点</strong>$(x,y,z)$使用变换$M_L$，然后判定<strong>光源可见</strong></p><script type="math/tex; mode=display">for\ each((x^\prime,y^\prime,z^\prime,w))</script><script type="math/tex; mode=display">if\ Depth_C[(x^\prime,y^\prime,z^\prime,w)]>-z^\prime==false\ continue</script><script type="math/tex; mode=display">Depth_C[(x^\prime,y^\prime,z^\prime,w)]=-z^\prime</script><script type="math/tex; mode=display">if\ Depth_L[M_L\cdot(x,y,z,1)^T]\approx Depth_C[(x^\prime,y^\prime,z^\prime,w)]\ Shadow</script><blockquote><p>最后一行伪代码就是含有阴影贴图的时，相机着色新增的判定</p><p>前三行代码为光源的$Depth_L$生成</p></blockquote><p>多光源时，对于场景中的每个像素，需要为场景中的每个光源执行阴影测试，只要能不被任何光源照到，就会产生阴影</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;阴影贴图是一种用于在三维场景中渲染动态阴影的技术。它基于光线的视角来生成深度信息，这些信息随后用于确定场景中的哪些部分处于阴影中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>齐次空间裁剪[2]</title>
    <link href="http://example.com/2024/11/04/Homogeneous-Space-Clipping-[2]/"/>
    <id>http://example.com/2024/11/04/Homogeneous-Space-Clipping-[2]/</id>
    <published>2024-11-03T16:46:11.000Z</published>
    <updated>2024-11-04T05:25:07.767Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在上半篇中，得出了以下结果：</p><ul><li><p><strong>在齐次空间的标准视体下的流水选位置裁剪</strong></p></li><li><p>快速获取<strong>顶点关于六个视体表面的相对位置</strong></p></li></ul><p>如果简单的把不在视体内的顶点去掉，或者由此引发的，把相关图元去掉，会生成明显的不连续边缘</p><p>这里的统一做法为使用各种<strong>插值方法生成边缘顶点</strong></p><hr><h3 id="裁剪线段"><a href="#裁剪线段" class="headerlink" title="裁剪线段"></a>裁剪线段</h3><p>线段$AB$和标准视体的位置关系可以划分为</p><ol><li>线段完全在视体<strong>内部</strong>：端点$A,B$的都在视体内</li><li>线段完全在实体<strong>外部</strong>：端点$A,B$在视体外且<strong>区域码相同</strong></li><li>线段部分和视体<strong>表面相交</strong></li></ol><p>如果线段$AB$不满足情况$1,2$，则只需要端点$A,B$的特定区域码位不同，就可以断言：线段穿过该区域码对应的视体表面所在的<strong>平面</strong></p><h3 id="Cyus-Beck-裁剪算法"><a href="#Cyus-Beck-裁剪算法" class="headerlink" title="$Cyus-Beck$裁剪算法"></a>$Cyus-Beck$裁剪算法</h3><p>对端点$A(x_A,y_A,z_A,w_A)$和$B(x_B,y_B,z_B,w_B)$组队的线段$AB$有参数线段方程</p><script type="math/tex; mode=display">P(u)=uB+(1-u)A,0\le u\le 1</script><p>展开为</p><script type="math/tex; mode=display">\begin{align}P(u)_x &= ux_B+(1-u)x_A\\P(u)_y &= uy_B+(1-u)y_A\\P(u)_z &= uz_B+(1-u)z_A\\P(u)_w &= uw_B+(1-u)w_A\end{align}</script><p>比如，若线段$AB$已经和视体<strong>右表面</strong>所在的平面$\frac{X}{W}=1$相交，则有方程</p><script type="math/tex; mode=display">\frac{ux_B+(1-u)x_A}{uw_B+(1-u)w_A}=1</script><p>获得交点坐标后，只需要判定<strong>点在平面内部</strong>就可以得到线段未穿过视体表面，得到线段与视体表面的<strong>交点</strong></p><p>在后一种情况，需要裁剪线段，需要用<strong>交点</strong>替换在视体<strong>表面外侧端点</strong></p><p>为了更加简化过程，使用<strong>奇偶规则</strong>把情况$3$划分为：</p><ul><li><p>其中一个端点在视体内：必定裁剪一次</p></li><li><p>两个端点都在外部：一次都不裁剪，或者裁剪两次</p></li></ul><hr><blockquote><p>$tips$ 有处理<strong>凹多边形</strong>裁剪的算法，不过在三维空间中只需要使用一次凹分解</p></blockquote><h2 id="Sutherland-Hodgman-凸多边形裁剪"><a href="#Sutherland-Hodgman-凸多边形裁剪" class="headerlink" title="$Sutherland-Hodgman$凸多边形裁剪"></a>$Sutherland-Hodgman$凸多边形裁剪</h2><blockquote><p>$Sutherland-Hodgman$算法又叫做逐边裁剪算法.该算法的基本思想是逐边处理裁剪窗口和多边形。具体来说，算法将多边形的每条边与裁剪窗口的每条边进行比较，根据边的相对位置关系，决定是否输出顶点或交点。</p></blockquote><p>多边形和视体之间的位置关系可以由线段与视体的位置关系扩展</p><p><strong>依次使用六个视体表面所在的平面切割三角形，保留表面内的部分，最后的保留部分就是所需的凸多边形</strong></p><p>算法的正确性不言而喻，</p><ol><li>切割面是平整的，不会产生<strong>凹角</strong></li><li>六个平面内部构成的封闭空间就是标准视体</li></ol><h3 id="平面裁剪"><a href="#平面裁剪" class="headerlink" title="平面裁剪"></a>平面裁剪</h3><p>可以将多边形表示为有序的顶点序列，在转换为的线段（有序顶点对）序列。若$(P_0,P_1,P_2,P_3)$表示由线段$(P_0,P_1),(P_1,P_2),(P_2,P_3),(P_3,P_0)$构成的凸四边形</p><p>考虑线段$(A,B)$与平面的位置的情况</p><ul><li><p>完全在<strong>平面外侧</strong>：直接去掉</p></li><li><p>和<strong>平面相交</strong>：将外侧点替换为交点，注意点序不可更改</p></li><li><p>完全在<strong>平面</strong>内侧：保留顶点</p></li></ul><blockquote><p>$tips$ 这里是线段与平面求交，而非<strong>表面</strong>，纵使交点不在表面上，可能在另一个视体表面外侧，也保留，因为另一个表面所在的平面会再一次裁剪</p></blockquote><p><img src="https://s2.loli.net/2024/11/04/UsfOgGF8Hl4hNpk.png" alt=""></p><script type="math/tex; mode=display">\begin{align}(P_0,P_1) &\to (P_0^\prime,P_1)\\(P_1,P_2) &\to (P_1,P_2)\\(P_2,P_3) &\to (P_2,P_3^\prime)\\(P_3,P_0) &\to \emptyset\end{align}</script><p>若不相交，则所有线段转化为$\emptyset$</p><h3 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h3><p>切割出的线段序列不能组装成<strong>封闭</strong>多边形，但是切割过程和划分过程保证了</p><p>重组后的多边形：<strong>线段的后一个顶点是下一个线段的前一个顶点</strong>，遍历一次就可以重新组装为</p><script type="math/tex; mode=display">(P_0^\prime,P_1),(P_1,P_2),(P_2,P_3^\prime),(P_3^\prime,P_0^\prime)</script><p>标准的$Sutherland-Hodgman$算法需要区分射入和射出，输入线段，输出顶点序列表示多边形</p><script type="math/tex; mode=display">\begin{align}(P_0,P_1) &\to P_0^\prime\\(P_1,P_2) &\to P_1\\(P_2,P_3) &\to (P_2,P_3^\prime)\\(P_3,P_0) &\to \emptyset\end{align}</script><script type="math/tex; mode=display">(P_0^\prime,P_1,P_2,P_3^\prime)</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在上半篇中，得出了以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在齐次空间的标准视体下的流水选位置裁剪&lt;/stron</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>齐次空间裁剪[1]</title>
    <link href="http://example.com/2024/11/03/Homogeneous-Space-Clipping[1]/"/>
    <id>http://example.com/2024/11/03/Homogeneous-Space-Clipping[1]/</id>
    <published>2024-11-03T11:05:31.000Z</published>
    <updated>2024-11-04T03:58:49.811Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><blockquote><p>裁剪是指在渲染场景之前，将位于摄像机视野之外的物体或者被其他物体遮挡的部分移除的过程。这样可以提高渲染效率，因为不需要绘制最终不会出现在屏幕上的物体。</p></blockquote><p>裁剪需要满足以下条件</p><ul><li><p><strong>确定场景</strong>：不会再发生<strong>顶点变换</strong>，否则可能会把场景内的点裁剪掉</p></li><li><p><strong>确定视域</strong>：引入相机参数后，在投影变换前，它是一个<strong>四棱台</strong>，之后是正方体（<strong>规范化</strong>）</p></li></ul><h3 id="图像流水线"><a href="#图像流水线" class="headerlink" title="图像流水线"></a>图像流水线</h3><p>按照<strong>场景对象</strong>表现形式的不同，图形流水线可以分为三个阶段：世界坐标系，相机坐标系，齐次空间，屏幕空间</p><p><img src="https://s2.loli.net/2024/11/03/f91hQqvpOGxNklR.png" alt=""></p><h4 id="世界坐标系"><a href="#世界坐标系" class="headerlink" title="世界坐标系"></a>世界坐标系</h4><ol><li>模型可以被添加到世界坐标系中，组成场景</li><li>可能会有<strong>顶点变换</strong></li></ol><blockquote><p>$tips$ 虽然只说明了顶点变换，如果模型顶点存在法线，需要做<strong>法线变换</strong></p></blockquote><h4 id="相机坐标系"><a href="#相机坐标系" class="headerlink" title="相机坐标系"></a>相机坐标系</h4><ol><li>将场景的世界坐标转换为相机坐标系的表达</li><li>可能存在<strong>顶点变换</strong></li></ol><blockquote><p>$tips$ 尽管这里场景对象可能没有变换，不过这会是<strong>裁剪</strong>可能发生的位置</p></blockquote><h4 id="齐次空间"><a href="#齐次空间" class="headerlink" title="齐次空间"></a>齐次空间</h4><ol><li>对相机坐标系的场景做投影变换</li><li>规范化</li></ol><h4 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><ol><li>将规范视体投影到屏幕</li><li>可见面判定算法<strong>剔除</strong></li></ol><hr><h3 id="裁剪可能发生的位置"><a href="#裁剪可能发生的位置" class="headerlink" title="裁剪可能发生的位置"></a>裁剪可能发生的位置</h3><blockquote><p>$tips$ 如果保证不在相机坐标系下做<strong>顶点变换</strong>，则可以在世界坐标系下做变换，不过视域需要相机对象，在这个阶段只会有更多限制</p></blockquote><h4 id="相机坐标系-1"><a href="#相机坐标系-1" class="headerlink" title="相机坐标系"></a>相机坐标系</h4><p>在相机坐标系下，做完可能的<strong>顶点变换</strong>，看可以确定视域，它是由以下六个顶点组成的<strong>四棱台</strong></p><script type="math/tex; mode=display">(l,b,-n),(r,b,-n),(l,t,-n),(r,t,-n)</script><script type="math/tex; mode=display">(l,b,-f),(r,b,-f),(l,t,-f),(r,t,-f)</script><p>这六个表明并不规整</p><h4 id="屏幕空间-1"><a href="#屏幕空间-1" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><p>这个阶段得到了规范化视体，可以更简洁的表达视域，不过投影变换会带来问题</p><script type="math/tex; mode=display">Z^\prime=\frac{(n+f)Z+nf}{-Z}</script><p>如果顶点本来就在视域内，$Z^\prime$的推导过程证明不会存在问题</p><p>但是一个可能存在的裁剪点靠近$Z=0$相机所在的$Z$平面时，投影变换会把它会从平面一侧变换到平面另一侧</p><hr><h2 id="齐次空间裁剪"><a href="#齐次空间裁剪" class="headerlink" title="齐次空间裁剪"></a>齐次空间裁剪</h2><p>场景世界坐标$(x,y,z,1)$经过变换$M$后成为齐次形式$(x^\prime,y^\prime,z^\prime,-z)$</p><script type="math/tex; mode=display">\left[\begin{matrix}x^\prime\\\\y^\prime\\\\z^\prime\\\\-z\end{matrix}\right]=M\cdot\left[\begin{matrix}x\\\\y\\\\z\\\\1\end{matrix}\right]</script><p>其中$M$按正确顺序组合<strong>顶点变换，视图变换，投影变换，规范化</strong>的变换矩阵，也就是再对坐标标准化就得到了<strong>屏幕空间</strong></p><blockquote><p>$tips$ 这里的$z\prime$符号可能存在复用，$z^\prime\ne \frac{(n+f)z+nf}{-z},z^\prime=(n+f)z+nf$</p></blockquote><p>齐次空间下的<strong>视域</strong>也需要四维表示，将齐次坐标第四维$-z$定义为$W$， 则特定顶点$(x,y,z,w)$可以得到判定式</p><script type="math/tex; mode=display">\begin{align}-1\le\frac{x}{w}\le 1\\\\-1\le\frac{y}{w}\le 1\\\\-1\le\frac{z}{w}\le 1\end{align}</script><blockquote><p>$tips$ 这里使用的标准视体为$[-1,1]^3$</p></blockquote><p>这里也说明了之前在齐次坐标除$W$后存在的问题，<strong>不能假定</strong>$W$为正（这里排除非法的$w=0$）</p><p>对应的视域为由以下六个顶点组成的<strong>四棱台</strong></p><script type="math/tex; mode=display">(-w,-w,w,w),(-w,w,w,w),(w,-w,w,w),(w,w,w,w)</script><script type="math/tex; mode=display">(-w,-w,-w,w),(-w,w,-w,w),(w,-w,-w,w),(w,w,-w,w)</script><hr><h2 id="三维区域码"><a href="#三维区域码" class="headerlink" title="三维区域码"></a>三维区域码</h2><blockquote><p><strong>三维区域码</strong>表示三维空间中的物体相对于视体位置的一种编码方法。在三维图形的渲染过程中，区域码用于快速判断一个物体或物体的部分是否在视体内</p><p>$tips$ 下面的不太严谨的方位描述都是<strong>相对于相机视角</strong>而言，如图所示</p></blockquote><p>点$(-1,-1,-1),(-1,-1,1),(-1,1,-1),(-1,1,1)$所在平面可能不是<strong>齐次坐标下视体面</strong>所在的平面，因为$w$是未知的，不能假定它的正负</p><p><img src="https://s2.loli.net/2024/11/04/4nuESaMBiq8vUhC.png" alt=""></p><hr><h3 id="构建三维区域码"><a href="#构建三维区域码" class="headerlink" title="构建三维区域码"></a>构建三维区域码</h3><blockquote><p>三维区域面码可以一定程度缓解$w$的不确定性带来的复杂性</p></blockquote><p>忽略点恰好在视体面上的特殊情况，如果只考虑点和视体的关系，则一个点关于一个视体面需要一种<strong>布尔属性</strong>，<strong>是否在表明内一侧</strong></p><blockquote><p>$tips$ 平面的内外通常由平面法线计算的方式决定，不过这里不用考虑太多细节，简单将平面内定义为视体空间一侧</p></blockquote><p>综上，考虑$w&gt;0$可得到一种三维区域码(区域码会因构建的方式有不同的表达)的表示</p><blockquote><p>$tips$ 复用符号$(x,y,z,w)$指顶点的齐次坐标</p></blockquote><script type="math/tex; mode=display">\begin{align}bool_0 &= -w\le x\tag{左}\\bool_1 &= x\le w\tag{右}\\bool_2 &= -w\le y\tag{下}\\bool_3 &= y\le w\tag{上}\\bool_4 &= -w\le z\tag{后}\\bool_4 &= z\le w\tag{前}\\\end{align}</script><p>如果顶点的某一码值为$true$，则表示顶点在这个表明的<strong>内部</strong>，而组合所有码值，就可以表示<strong>被六个视体表面所切割出的</strong>$9\times 3$<strong>个区域</strong></p><p><img src="https://s2.loli.net/2024/11/04/x24vZ5SUJGnDENF.png" alt=""></p><blockquote><p>每一块区域都有唯一的区域码与之对应，可以精确定位顶点的相对位置</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;裁剪&quot;&gt;&lt;a href=&quot;#裁剪&quot; class=&quot;headerlink&quot; title=&quot;裁剪&quot;&gt;&lt;/a&gt;裁剪&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;裁剪是指在渲染场景之前，将位于摄像机视野之外的物体或者被其他物体遮挡的部分移除的过程。这样可以提高渲染效</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契堆</title>
    <link href="http://example.com/2024/11/02/Fibonacci-Heap/"/>
    <id>http://example.com/2024/11/02/Fibonacci-Heap/</id>
    <published>2024-11-02T02:35:34.000Z</published>
    <updated>2024-11-04T15:05:19.543Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><blockquote><p>势能分析是用于分析数据结构操作摊销成本的一种技术。它是一种建立在势能函数基础上的分析方法，通过引入势能函数来跟踪操作的<strong>累积成本</strong>，并将这个累积成本<strong>分摊</strong>到每个操作上，从而得到每个操作的摊销成本</p></blockquote><p><strong>势能</strong>是和整个<strong>数据结构</strong>关联而非特定操作，对数据结构$D$的操作引起势能的变换</p><ul><li><strong>势能函数</strong>$\Phi(D)$：势能函数是一种用来衡量数据结构当前状态的函数。通常，这个函数会根据数据结构中的一些特定属性（如节点的数量、树的深度等）来定义。</li></ul><p>定义对数据结构的每一次操作$i$有：</p><ul><li><p><strong>势能成本</strong>$\Phi(D_i)-\Phi(D_{i-1})$：数据结构在进行操作时的潜在成本，它通常与数据结构的当前状态有关。</p></li><li><p><strong>实际成本</strong>$c_i$：执行一个操作时的即时成本。</p></li><li><p><strong>摊还成本</strong>$\hat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})$：将实际成本和势能变化结合起来</p></li></ul><p>定义初始数据结构$D_0$的势能$\Phi(D_0)=0$，则进行$N$次操作后的总摊还成本</p><script type="math/tex; mode=display">\begin{align}\sum_{i=0}^N\hat{c_i} &= \sum_{i=0}^N(c_i+\Phi(D_i)-\Phi(D_{i-1}))\\\\&= \sum_{i=0}^Nc_i+\Phi(D_N)\end{align}</script><p>因此，只要最后的数据结构势能$\Phi(D_N)$不为负，就可以得到执行$N$次操作代价上界</p><p>更具有普遍性的结论，势能函数满足$\Phi(D)\ge0$</p><hr><h2 id="斐波那契堆结构"><a href="#斐波那契堆结构" class="headerlink" title="斐波那契堆结构"></a>斐波那契堆结构</h2><blockquote><p>一个斐波那契堆是一系列<strong>多叉堆</strong>的集合</p></blockquote><p>为了满足<strong>多分叉，不定分叉</strong>，同二叉堆不同，不使用$left,right$属性将子节点链接，斐波那契节点使用$son$属性链接任意一个子节点，每个节点使用额外的$left,right$链接左右兄弟节点，便于实现，首尾子节点也链接</p><p>直观的讲，<strong>多叉堆</strong>中节点的<strong>子节点使用双链表储存</strong></p><p><img src="https://s2.loli.net/2024/11/02/QGIKjdWsZy7qpHm.png" alt=""></p><p>所以一个斐波那契堆节点$x$具有以下属性</p><ul><li><p>键值对$(val,key)$</p></li><li><p>$son,parent$指针</p></li><li><p>$left,right$左右兄弟节点</p></li><li><p>$mark$<strong>标记</strong>：节点至上一次成为另一个节点的孩子后，是否失去过节点。</p></li><li><p>$degree$度数：节点的子节点数量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><em>后两个属性保持了复杂度度</em></p><p>斐波那契堆维护<strong>父子节点规则</strong></p><script type="math/tex; mode=display">\begin{align}Node\ parent.key\circ Node,key=true\\\\Node.eky\circ each\ Node\ son.key=true\end{align}</script><h3 id="Root-指针"><a href="#Root-指针" class="headerlink" title="$Root$指针"></a>$Root$指针</h3><p>因为<strong>一个斐波那契堆是多叉堆的集合</strong>，为了快速找出所有堆范围下的首序元素，将这些堆根节点也链接起来，$Root$指针指向特定一个根堆</p><script type="math/tex; mode=display">Root.son\circ otehr\ bothers=true</script><p>即$Root$所指节点是多叉堆堆根的首序节点，换句话说，$Root$指向斐波那契堆的首序节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="势能函数"><a href="#势能函数" class="headerlink" title="势能函数"></a>势能函数</h3><p>$def$斐波那契堆$H$的势能函数</p><script type="math/tex; mode=display">\Phi(H)=t(H)+2m(H)</script><p>其中$t(H)$为集合中多叉堆的数量，即$Size(Root.son)$，$m(H)$为<strong>标记节点</strong>的数量</p><h3 id="最大度数"><a href="#最大度数" class="headerlink" title="最大度数"></a>最大度数</h3><p>$def\ D(n)$表示$n$个节点的斐波那契堆中的<strong>任何节点的最大度数</strong></p><p>根据定义保证了$D(n) &lt; n$，不过斐波那契堆的性质会保证$D(n)\le \lfloor\lg n\rfloor$</p><hr><h2 id="斐波那契堆操作"><a href="#斐波那契堆操作" class="headerlink" title="斐波那契堆操作"></a>斐波那契堆操作</h2><h3 id="创建斐波那契堆"><a href="#创建斐波那契堆" class="headerlink" title="创建斐波那契堆"></a>创建斐波那契堆</h3><p>只需要创建一个$Root$指针指向为$nullotr$</p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>在斐波那契堆中的多叉堆集合中加入一个，由单个节点组成的多叉堆</p><p>这也指明了该如何<strong>初始化</strong>斐波那契堆中除了$Root$以外的<strong>节点</strong></p><blockquote><p>$tips$ $mark$标记属性依照定义，初始化为$false$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="插入实现"><a href="#插入实现" class="headerlink" title="插入实现"></a>插入实现</h4><p>多叉堆堆顶无父节点$parent$，并且它的兄弟一定为$Root$指针指向的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_insert_X_to_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root), ++n; &#125;</span><br></pre></td></tr></table></figure><p>其中<code>s_insert_X_to_Y_infer_W</code>表示将<strong>节点</strong>$X$插入为节点$Y$的子节点，$W$为$Y$的其中一个儿子的<strong>引用</strong></p><blockquote><p>$tips$ 下面的代码展示了链表的实现细节，$W$传引用方便更改斐波那契堆属性$Root$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_X_to_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">++Y-&gt;degree;</span><br><span class="line">X-&gt;parent = Y;</span><br><span class="line"><span class="keyword">if</span> (!W) &#123;</span><br><span class="line">W = X;</span><br><span class="line">X-&gt;left = X-&gt;right = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">X-&gt;left = W;</span><br><span class="line">X-&gt;right = W-&gt;right;</span><br><span class="line">W-&gt;right-&gt;left = X;</span><br><span class="line">W-&gt;right = X;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="势能分析-1"><a href="#势能分析-1" class="headerlink" title="势能分析"></a>势能分析</h4><script type="math/tex; mode=display">\begin{align}\hat{c} &=c+\Phi(H^\prime)-\Phi(H)\\\\&=O(1)+(t(H)+1+2m(H))-(t(H)+2m(H))\\\\&=O(1)\end{align}</script><hr><h2 id="弹出首序节点"><a href="#弹出首序节点" class="headerlink" title="弹出首序节点"></a>弹出首序节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* X = Root;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;son)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X-&gt;son-&gt;right, X, X-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line"><span class="built_in">s_erase_X_from_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root);</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">if</span> (Root)</span><br><span class="line"><span class="built_in">s_adjust_pop</span>();</span><br><span class="line"><span class="keyword">return</span> X-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整体步骤分为两步</p><ol><li>抽取$Root$指针所指的多叉堆</li><li>调整得到的斐波那契堆<code>1s_adjust_pop();</code></li></ol><h3 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h3><p>将$Root$指针所指的多叉堆从<strong>多叉堆集合</strong>中搬离出去，再把不该被删除的节点插入回去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**抽取步骤的实际成本**为$T_1=O(D(n))$</span><br><span class="line"></span><br><span class="line">#### 代码细节</span><br><span class="line"></span><br><span class="line">这里$W$传引用依然是为了隐式改变斐波那契堆属性$Root$，在这个中不保证$Root$属性依然指向首序节点，会在调整步骤中保证</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">auto s_erase_X_from_Y_infer_W(Node* X, Node* Y, Node*&amp; W) &#123;</span><br><span class="line">if (Y)</span><br><span class="line">--Y-&gt;degree;</span><br><span class="line">if (W-&gt;right == W)</span><br><span class="line">W = nullptr;</span><br><span class="line">else &#123;</span><br><span class="line">if (W == X)</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">Node* L = X-&gt;left, * R = X-&gt;right;</span><br><span class="line">L-&gt;right = R;</span><br><span class="line">R-&gt;left = L;</span><br><span class="line">&#125;</span><br><span class="line">return X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_adjust_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;Node*&gt; <span class="title">D</span><span class="params">(floor(log10(n))<span class="number">+1</span>, <span class="literal">nullptr</span>)</span>, R</span>;</span><br><span class="line">Node* W = Root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != Root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; Y : R) &#123;</span><br><span class="line"><span class="keyword">while</span> (D[Y-&gt;degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">Node* X = D[Y-&gt;degree];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Y-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">swap</span>(Y, X);</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(X, Y, Y-&gt;son);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line">D[X-&gt;degree] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">D[Y-&gt;degree] = Y;</span><br><span class="line">&#125;</span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : D)</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(r, <span class="literal">nullptr</span>, Root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$tips$ 这里重组时，依照定义，对新的多叉堆根的$mark$属性置$false$</p></blockquote><ul><li><p><strong>第一个循环</strong>：将斐波那契堆中的多叉堆集合中的每一个索引出来</p></li><li><p><strong>第二个循环</strong>：确保了一个性质</p></li></ul><blockquote><p>新的斐波那契堆中的每一个<strong>多叉堆根的度</strong>都是唯一的</p></blockquote><ul><li>要调整的多叉堆数量最多为$O(H(t))+D(n)-1$，因为内部$while$每循环一次，都使得多叉堆数量减$1$</li></ul><p>所以第一个循环和第二个循环总实际代价为$T_2=O(D(n)+t(H))$</p><ul><li><strong>第三个循环</strong> 重构多叉堆集合，实际代价为$T_3=O(D(n))$</li></ul><h4 id="势能分析-2"><a href="#势能分析-2" class="headerlink" title="势能分析"></a>势能分析</h4><script type="math/tex; mode=display">\begin{align}\hat{c} &= c+\Phi(H^\prime)-\Phi(H)\\\\&= O(T_1+T_2+T_3)+(t(H^\prime)+2m(H^\prime))-(t(H)+2m(H))\\\\&= O(D(n)+t(H))+(O(D(n))+1+2m(H))-(t(H)+2m(H))\\\\&= O(D(n))\end{align}</script><hr><h2 id="减小变节点键值"><a href="#减小变节点键值" class="headerlink" title="减小变节点键值"></a>减小变节点键值</h2><p>同二叉堆一样，需要维护新节点的<strong>子父节点关系</strong>，不过这里还需要维护$mark$<strong>标记</strong></p><p>考虑<strong>最小堆</strong>中$key$减小，当它不符合<strong>子父节点关系</strong>时，需要上滤<strong>改变节点</strong></p><ul><li><p>如果它不是多叉堆集合中某个多叉堆的根，将它抽取出来<strong>插入多叉堆集合</strong>，然后进行<strong>级联切除</strong>，检查$Root$指针合理性</p></li><li><p>如果它是多叉堆集合中某个多叉堆的根，需要考虑的只有$Root$指针</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decl</span><span class="params">(Node* X, <span class="type">int</span> new_key)</span> </span>&#123;</span><br><span class="line">X-&gt;key = new_key;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent &amp;&amp; !<span class="built_in">com</span>(X-&gt;parent-&gt;key, new_key))</span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(X, X-&gt;parent);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, new_key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联切除"><a href="#级联切除" class="headerlink" title="级联切除"></a>级联切除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_from_Y</span><span class="params">(Node* X, Node* Y)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X, Y, Y-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;mark == <span class="literal">false</span>)</span><br><span class="line">Y-&gt;mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(Y, Y-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个节点应该被级联切除，它应该至上一次成为另一个节点的孩子后，是否失去了两个字节点，即$mark=false$</p><p>按照$mark$定义，$X$成为多叉堆根节点，置$false$，$Y$不为二叉堆根且正在失去子节点，置$true$</p><h3 id="势能分析-3"><a href="#势能分析-3" class="headerlink" title="势能分析"></a>势能分析</h3><p>记级联切除调用的次数为$s$，除了最后一次调用和切改变节点，都消除了一个$mark=true$的<strong>标记节点</strong>，所以</p><script type="math/tex; mode=display">\begin{align}t(H^\prime) &= t(H)+(s-2)+1\\\\m(H^\prime) &= m(H)-(s-2)\end{align}</script><p>所以摊还代价为</p><script type="math/tex; mode=display">\begin{align}\hat{c} &= c+\Phi(H^\prime)-\Phi(H)\\\\&= O(s)+(t(H)+s-1+2(m(H)-s+2))-(t(H)+2m(H))\\\\&= O(1)\end{align}</script><h2 id="最大度数的界"><a href="#最大度数的界" class="headerlink" title="最大度数的界"></a>最大度数的界</h2><blockquote><p>引理$1$：设节点$x$为斐波那契堆中任意节点，$x.degree=k$，设$y_1,y_2,\cdots,y_k$为$x$的子节点，按照<strong>链入先序</strong>排序,则$y_i.degree\ge i-2$</p></blockquote><ul><li><p>$i\ge 3$，当节点$y_i$链入时，$y_{1,i-1}$已经被链入，此时有$x.degree\ge i-1$，而$adjust$函数要求，只有$x.degree=y_i.degree$时，$y_i$才会被链入，所以有$y_i\ge i-1$</p></li><li><p>$y_i$被链入后最多失去一个节点，$mark$标记和<strong>级联切除</strong>保证了这一性质，否则它将被切除，$x.degree$改变</p></li></ul><blockquote><p>引理$2$：对于斐波那契数列$F_k$($k\ge 0$)，有$F_{k+2}=1+\sum_{i=0}^kF_i$</p></blockquote><p>使用数学归纳法证明</p><p>基础步：$F_{0+2}=1+F_0=F_2$</p><ul><li>归纳步，假设$F_{k+1}=1+\sum_{i=0}^{k+1}F_i$</li></ul><script type="math/tex; mode=display">\begin{align}F_{k+2} &= F_{k-1}+F_k\\\\&= 1+\sum_{i=0}^{k-1}F_i+F_k\\\\&=1+\sum_{i=0}^{k}F_i\end{align}</script><blockquote><p>引理$3$：$F_{k+2}\ge \phi^k,k\ge 0$，其中$\phi$黄金分割率是方程$I\ x^2=x+1$的正根</p></blockquote><p>使用数学归纳法证明</p><ul><li><p>基础步：$F_{0+2}=1=\phi^1$</p></li><li><p>归纳步：假设对于$i=1,2,\cdots,k-1$，有$F_{k+2}\ge \phi^k$</p></li></ul><script type="math/tex; mode=display">\begin{align}F_{k+2} &= F_{k+1}+F_k\\\\&\ge \phi^{k-1}+\phi^{k-2}\\\\&= \phi^{k-2}(\phi+1)\\\\&= \phi^{k-2}\cdot\phi^2\tag{function I}\\\\&= \phi^k\end{align}</script><blockquote><p>引理$4$：设斐波那契堆中任意节点$x,x.degree=k$，有$Size(x)\ge F_{k+2}$，其中$Size(x)$是：斐波那契堆的多叉堆集合中某个多叉堆，它有节点$x$，以$x$为根的子多叉堆的节点数量</p></blockquote><p>设$S_k$为斐波那契堆中度数$x.degree=k$的任意节点$x$的最小可能$Size$，则根据<strong>引理</strong>$1$可得</p><script type="math/tex; mode=display">Size(x) \ge S_k \ge 2+\sum_{i=2}^kS_{i-2}</script><p>使用归纳法证明$S_k\ge F_{k+2}$即可得证</p><ul><li><p>基础步：$S_0=1=F_{0+2}$</p></li><li><p>归纳步：假设对于$k=1,2,3,\dots,k-1$，有$S_k\ge F_{k+2}$成立</p></li></ul><script type="math/tex; mode=display">\begin{align}S_k &\ge 2+\sum_{i=2}^kS_{i-2}\\\\&\ge 2+\sum_{i=2}^kF_i\\\\&= 1+\sum_{i=0}^kF_i\\\\&= F_{k+2}\tag{引理2}\end{align}</script><p>即有</p><script type="math/tex; mode=display">Size(x)\ge F_{k+2}\ge\phi^k\tag{引理3}</script><p>对于有$n$个节点的斐波那契堆</p><script type="math/tex; mode=display">n\ge Size(x)\ge \phi^k</script><p>取对数得到</p><script type="math/tex; mode=display">k\le\log_{\phi}n\le \lg n</script><p>因为$k$为正整数，则$n$个节点的斐波那契中任意节点的最大度数$D(n)$满足</p><script type="math/tex; mode=display">D(n)\le \lfloor\lg n\rfloor</script><hr><h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><p><img src="https://s2.loli.net/2024/11/02/o6xs7BPY3HcaAie.png" alt=""></p><p><img src="https://s2.loli.net/2024/11/04/f5JwM3tCgBkdKNL.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_FIB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">function&lt;<span class="keyword">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear_forest</span><span class="params">(Node* X)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">vector&lt;Node*&gt; R;</span><br><span class="line">Node* W = X;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line"><span class="keyword">if</span> (W-&gt;son)</span><br><span class="line"><span class="built_in">s_clear_forest</span>(W-&gt;son);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != X);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : R)</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S_FIB</span>(function&lt;<span class="built_in">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com) :<span class="built_in">com</span>(com) &#123;&#125;</span><br><span class="line">~<span class="built_in">S_FIB</span>() &#123; <span class="keyword">if</span> (Root)<span class="built_in">s_clear_forest</span>(Root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_X_to_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">++Y-&gt;degree;</span><br><span class="line">X-&gt;parent = Y;</span><br><span class="line"><span class="keyword">if</span> (!W) &#123;</span><br><span class="line">W = X;</span><br><span class="line">X-&gt;left = X-&gt;right = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">X-&gt;left = W;</span><br><span class="line">X-&gt;right = W-&gt;right;</span><br><span class="line">W-&gt;right-&gt;left = X;</span><br><span class="line">W-&gt;right = X;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_X_from_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">--Y-&gt;degree;</span><br><span class="line"><span class="keyword">if</span> (W-&gt;right == W)</span><br><span class="line">W = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (W == X)</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">Node* L = X-&gt;left, * R = X-&gt;right;</span><br><span class="line">L-&gt;right = R;</span><br><span class="line">R-&gt;left = L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_adjust_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;Node*&gt; <span class="title">D</span><span class="params">(floor(log10(n))<span class="number">+1</span>, <span class="literal">nullptr</span>)</span>, R</span>;</span><br><span class="line">Node* W = Root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != Root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; Y : R) &#123;</span><br><span class="line"><span class="keyword">while</span> (D[Y-&gt;degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">Node* X = D[Y-&gt;degree];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Y-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">swap</span>(Y, X);</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(X, Y, Y-&gt;son);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line">D[X-&gt;degree] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">D[Y-&gt;degree] = Y;</span><br><span class="line">&#125;</span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : D)</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(r, <span class="literal">nullptr</span>, Root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_from_Y</span><span class="params">(Node* X, Node* Y)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X, Y, Y-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;mark == <span class="literal">false</span>)</span><br><span class="line">Y-&gt;mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(Y, Y-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_insert_X_to_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root), ++n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* X = Root;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;son)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X-&gt;son-&gt;right, X, X-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line"><span class="built_in">s_erase_X_from_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root);</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">if</span> (Root)</span><br><span class="line"><span class="built_in">s_adjust_pop</span>();</span><br><span class="line"><span class="keyword">return</span> X-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decl</span><span class="params">(Node* X, <span class="type">int</span> new_key)</span> </span>&#123;</span><br><span class="line">X-&gt;key = new_key;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent &amp;&amp; !<span class="built_in">com</span>(X-&gt;parent-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(X, X-&gt;parent);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>$reference$ 算法导论第四版</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;势能分析&quot;&gt;&lt;a href=&quot;#势能分析&quot; class=&quot;headerlink&quot; title=&quot;势能分析&quot;&gt;&lt;/a&gt;势能分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;势能分析是用于分析数据结构操作摊销成本的一种技术。它是一种建立在势能函数基础上的分析方法</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>左式堆</title>
    <link href="http://example.com/2024/11/01/Leftist-Heap/"/>
    <id>http://example.com/2024/11/01/Leftist-Heap/</id>
    <published>2024-11-01T13:53:42.000Z</published>
    <updated>2024-11-03T10:46:29.275Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>$root$： 树根节点</p></li><li><p>$left,right$左右子节点，树 </p></li></ul><blockquote><p>左式堆是一种<strong>可并堆</strong>，在基础的二叉堆操作上，支持快速合并</p></blockquote><p>在左式堆<strong>树形</strong>节点中，除了二叉堆中基础的左右子节点，父节点，和键值对，还需要维护<strong>零路径长</strong>$\alpha$</p><script type="math/tex; mode=display">\begin{align}\alpha(x) &=-1\tag{x is nullptr node}\\\\&= min(\alpha(x.left),\alpha(x.right))+1\tag{others}\end{align}</script><p>即节点的零路径长是从它到到<strong>不具有两个子节点</strong>的<strong>最短下降路径</strong></p><p>左式堆需要维护其每一个非空节点$x$的$\alpha$满足</p><script type="math/tex; mode=display">\alpha(x.left)\ge\alpha(x.right)</script><p>则有</p><script type="math/tex; mode=display">\alpha(x)=\alpha(x.right)+1\tag{x not is nullptr node}</script><p>递归使用这个式子，$\alpha(T.root)$就是左式堆$T$的<strong>最右下降路径长度</strong>（每次下降都选择右子节点）</p><hr><h3 id="核心定理"><a href="#核心定理" class="headerlink" title="核心定理"></a>核心定理</h3><blockquote><p>非空左式堆$T$至少有$2^{\alpha(root)+1}-1$个节点</p></blockquote><p>使用数学归纳法证明</p><ul><li><p>基础条件：$\alpha(root)=0$，右子树为空左式堆$T$非空，成立</p></li><li><p>假设条件：对于$\alpha(root)=1,2,\cdots,n$个节点，定理成立</p></li><li><p>归纳假设：若$\alpha(root)=n+1$,则有</p></li></ul><script type="math/tex; mode=display">\begin{align}NodeSize(T) &= NodeSize(T.left)+NodeSize(T.right)+1\\\\&= 2^{\alpha(T.root.left)+1}-1+2^{\alpha(T.root.right)+1}-1+1\\\\&\ge 2^{\alpha(root)}+2^{\alpha(root)}-1\\\\&\ge 2^{n+2}-1\\\\&\ge 2^{\alpha(root)}-1\end{align}</script><p>根节点代入$\alpha(x)=\alpha(x.right)+1$，得到$\alpha(root.right)$=r的非空左式堆至少有$2^r-1$个节点，即</p><p>$N$个节点的左式堆有以下性质</p><script type="math/tex; mode=display">\alpha(root.right)=\lfloor\log(N+1)\rfloor</script><blockquote><p>$N$个节点的非空左式堆的最右下降路径长度为$\lfloor\log(N+1)\rfloor$</p></blockquote><p>左式堆将排序规则下的首序元素放在根节点上，通过合并操作实现插入和删除，左式堆递归地对右子结点合并来保证时间复杂度</p><h3 id="合并Merge"><a href="#合并Merge" class="headerlink" title="合并Merge"></a>合并Merge</h3><p>$key$键上的排序规则$\circ$，合并两个<strong>不同时为空</strong>左式堆$T_1,T_2$，<strong>返回</strong>合并后的二叉堆根节点$T_{new}$，即</p><script type="math/tex; mode=display">T_{new}=Merge(T_1,T_2)</script><h4 id="递归基"><a href="#递归基" class="headerlink" title="递归基"></a>递归基</h4><p>任意一个左式堆位空，返回原本的非空二叉堆</p><h4 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h4><script type="math/tex; mode=display">\begin{align}T_1.key\circ T_2.key &= true\\\\T_{new}.left &= T_1.left\\\\T_{new}.right &=Merge(T_1.right,T_2)\\\\if\ \alpha(T_{new}.left) &> \alpha(T_{new}.right)\ then\ swap(T_{new}.left,T_{new}.right)\\\\set\  &\alpha (T_{new}.root)\end{align}</script><p><em>因为函数是递归的，只需要保持边界条件和递归步骤过程的性质</em>，就能得到整体的性质</p><ul><li><p>因为递归入口为不同时为空的两个左式堆，而存在空左式堆的函数实例都会直接返回，所有递归每一步中的两个二叉堆不同时为空</p></li><li><p>合并的两个左式堆的左右子堆都满足<strong>非零路径要求</strong>，而交换操作使得每一个递归返回的左式堆也满足</p></li><li><p>每一次<strong>递归调用</strong>都在原始的左式堆(没有交换子树)上进行，并且沿着任意一个左式堆最右下降路径进行，所以$Merge$调用次数用时就是两个二叉堆<strong>最右下降路径总和</strong></p></li></ul><p>$O(\lfloor\log(N_1+1)\rfloor+\lfloor\log(N_2+1)\rfloor)=O(\log N)$</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://s2.loli.net/2024/11/02/5arWwQXiJhSb2ok.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左式堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_L_Heap</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, Node* left = <span class="literal">nullptr</span>, Node* right = <span class="literal">nullptr</span>) :<span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">Node* left, * right;</span><br><span class="line"><span class="type">int</span> val, npl = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Node* root = <span class="literal">nullptr</span>;</span><br><span class="line">function&lt;<span class="keyword">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com = <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear</span><span class="params">(Node* root)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root) &#123;</span><br><span class="line"><span class="built_in">s_clear</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">s_clear</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_npl</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node ? node-&gt;npl : <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">up_date</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_npl</span>(node-&gt;left) &lt; <span class="built_in">get_npl</span>(node-&gt;right))</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_npl</span>(node-&gt;left) &lt; <span class="built_in">get_npl</span>(node-&gt;right))</span><br><span class="line"><span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">node-&gt;npl = <span class="built_in">get_npl</span>(node-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_merge</span><span class="params">(Node* a, Node* b)</span> -&gt; Node* </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> a ? a : b;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(a-&gt;val, b-&gt;val))</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line">a-&gt;right = <span class="built_in">s_merge</span>(a-&gt;right, b);</span><br><span class="line"><span class="built_in">up_date</span>(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">S_L_Heap</span>(function&lt;<span class="built_in">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com = <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()) :<span class="built_in">com</span>(com) &#123;&#125;</span><br><span class="line">~<span class="built_in">S_L_Heap</span>() &#123; <span class="built_in">s_clear</span>(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(<span class="keyword">auto</span> val)</span> </span>&#123; <span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root, <span class="keyword">new</span> <span class="built_in">Node</span>(val)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root-&gt;val; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* old = root;</span><br><span class="line"><span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root-&gt;left, root-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">merge</span><span class="params">(S_L_Heap&amp; heap)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root != heap.root) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root, heap.root);</span><br><span class="line">heap.root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$root$： 树根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$left,right$左右子节点，树 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;左式堆是一种&lt;strong&gt;可并堆&lt;/strong&gt;，在基础的二叉堆操作上，支持快速合并&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>微表面理论</title>
    <link href="http://example.com/2024/11/01/Cook-Torrance/"/>
    <id>http://example.com/2024/11/01/Cook-Torrance/</id>
    <published>2024-11-01T07:14:05.000Z</published>
    <updated>2024-11-08T14:32:22.785Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>微表面理论的核心思想是将物体表面视为由无数微小、朝向各异的<strong>镜面</strong>组成的集合。这些微小镜面被称为微面元，每个微面元都能独立<strong>反射</strong>光线</p></blockquote><p>在微表面模型中，物体表面的<strong>粗糙程度</strong>由微面元的<strong>朝向分布</strong>决定。如果微面元的朝向分布较为集中，则表面看起来更光滑；反之，如果朝向分布分散，则表面看起来更粗糙</p><p>综上，可以解释$Cook-Torrance$将$BRDF$表示为</p><script type="math/tex; mode=display">\rho(w_r,w_i)=k_{difffuse}\cdot f_{lambert}(w_r,w_i)+k_{sepcular}\cdot f_{Cook-Torrance}(w_r,w_i)</script><p>其中第一项是漫反射常数分量，在之前已经证明过</p><hr><h2 id="Cook-Torrance-项组成"><a href="#Cook-Torrance-项组成" class="headerlink" title="$Cook-Torrance$项组成"></a>$Cook-Torrance$项组成</h2><script type="math/tex; mode=display">f_{Cook-Torrance}(w_r,w_i)=\frac{F(w_i,h)D(h)G(w_r,w_i,h)}{4(w_r\cdot n)(w_i\cdot n)}</script><p>其中，$ω_r$是观察方向，$w_i$是入射方向，$n$是表面法线， $h$是半角向量，即$w_i$和$w_r$的中间向量。</p><p>现在解释各项的含义</p><h3 id="菲涅尔项-F-w-i-h"><a href="#菲涅尔项-F-w-i-h" class="headerlink" title="菲涅尔项$F(w_i,h)$"></a>菲涅尔项$F(w_i,h)$</h3><ul><li>描述了光线从一种介质进入另一种介质时，光线在界面上的反射率。</li><li>常用的近似是$Schlick$菲涅尔近似，它简化了精确的菲涅尔方程，便于计算。</li></ul><h3 id="法线分布函数-D-h"><a href="#法线分布函数-D-h" class="headerlink" title="法线分布函数$D(h)$"></a>法线分布函数$D(h)$</h3><ul><li>描述了微面元法线分布的概率密度函数。</li><li>它决定了表面粗糙度，常用的模型有$Blinn-Phong$，$GGX$（$Trowbridge-Reitz$分布）和$Beckmann$分布。</li></ul><h3 id="几何函数-G-w-r-w-i-h"><a href="#几何函数-G-w-r-w-i-h" class="headerlink" title="几何函数$G(w_r,w_i,h)$"></a>几何函数$G(w_r,w_i,h)$</h3><ul><li>描述了微面元之间的自遮挡（$masking$）和遮挡（$shadowing$）效应。</li><li>它考虑了由于表面微观结构引起的直接光照和反射光线的可见性问题。</li><li>常用的近似是$Smith-Schlick-GGX$模型。</li></ul><hr><h2 id="菲涅尔效应"><a href="#菲涅尔效应" class="headerlink" title="菲涅尔效应"></a>菲涅尔效应</h2><blockquote><p>菲涅尔效应（$Fresnel Effect$）是指当光线以非垂直角度入射到介质表面时，反射光和透射光的相对强度如何随入射角的变化而变化。具体来说，当光线垂直入射（即入射角为0度）时，反射率较低，大部分光线会透射进入第二种介质；而当光线以较大角度入射时，反射率会增加，透射率相应减少。</p></blockquote><p>菲涅尔项$F(w_i,h)$可以通过菲涅尔方程来计算，该方程基于电磁理论，考虑了两种介质的折射率$n_1,n_2$对于非导电介质，菲涅尔方程可以表示为</p><script type="math/tex; mode=display">\begin{align}F_{parallel} &= \large(\frac{n_1\cos\theta_i-n_2\cos\theta_t}{n_1\cos\theta_i+n_2\cos\theta_t}\large)^2\\\\F_{perpendicular} &= \large(\frac{n_1\cos\theta_t-n_2\cos\theta_i}{n_1\cos\theta_t+n_2\cos\theta_i}\large)^2\end{align}</script><p>其中，$\theta_i$是入射角，$\theta_t$是透射角。平行和垂直分量分别对应于入射光的偏振方向。</p><h3 id="菲涅尔项的简化"><a href="#菲涅尔项的简化" class="headerlink" title="菲涅尔项的简化"></a>菲涅尔项的简化</h3><p>在实际的计算机图形学应用中，通常使用Schlick的近似来简化菲涅尔项的计算，因为它既快速又足够准确。$Schlick$近似的公式如下</p><script type="math/tex; mode=display">F_{Schlick}(w_i,h)=F_0+(1-F_0)(1-(w_i\cdot h))^5</script><p>其中，$F_0$（$F_0\in [0,1]$）是在垂直入射时的反射率（也称为基础反射率）</p><hr><h2 id="几何遮蔽函数"><a href="#几何遮蔽函数" class="headerlink" title="几何遮蔽函数"></a>几何遮蔽函数</h2><blockquote><p>在微表面理论中，表面被视作由无数微小的镜面组成，每个微面元都能独立反射光线。然而，由于这些微面元之间的相对位置，它们可能会相互遮挡，影响最终的反射光强度。几何遮蔽函数$G(w_r,w_i,h)$就是用来量化这种遮挡效应的。</p></blockquote><p>几何遮蔽函数$G$考虑了两个方向的遮蔽效应：</p><ul><li><p><strong>入射方向</strong>$w_i$的遮蔽：从入射方向$w_i$看来，微面元可能被其他微面元遮挡，导致光线无法到达。</p></li><li><p><strong>出射方向</strong>$w_r$的遮蔽：从出射方向$w_r$看来，微面元可能遮挡了其他微面元的反射光线。</p></li></ul><p>函数$G$通常定义为</p><script type="math/tex; mode=display">G=G_1(w_r,h)\cdot G_1(w_i,h)</script><p>其中，$G_1$是单方向的遮蔽函数，它描述了从特定方向观察时的遮蔽效应。</p><p>常见的视线有$Cook-Torrance$遮蔽函数</p><script type="math/tex; mode=display">G_1(w,h)=\frac{h\cdot w}{(h\cdot w)(1-k)+k}</script><p>其中，$k$，$k\in[0,1]$是与表面粗糙度相关的参数</p><hr><blockquote><p>$tips$ $Cook-Torrance$函数中,菲涅尔项$F(w_i,h)$和几何遮蔽项$G(w_r,w_i,h)$值都$\in [0,1]$，减少了反射光线的数量和强度</p></blockquote><hr><h2 id="法线分布函数"><a href="#法线分布函数" class="headerlink" title="法线分布函数"></a>法线分布函数</h2><blockquote><p>法线分布函数$D(h)$描述了微元面法线在半角方向$h$上的<strong>分布</strong>。</p><p>$tips_2$ <strong>微平面法向量</strong>表示为$w_h$，宏观平面的半角向量表示$h$</p></blockquote><p>$D(h)$<strong>表示每单位表面面积，每单位立体角所有单位法向量为</strong>$h$<strong>的微平面的面积</strong></p><p>非形式化的讲，该函数的意义是：当前点的微表面（$microfacet$）的面积除以宏表面（$macrofacet$）的面积，然后再除以立体角</p><script type="math/tex; mode=display">D(w_h)\equiv\frac{d^2A_h}{dw_hdA}</script><p>根据定义式，可得$D(h)$的实例应该满足</p><script type="math/tex; mode=display">\int_{\Omega^+}D(w_h)dw_hdA(n\cdot w_h)=dA</script><p>根据定义，$D(w_h)dw_hdA$为微表面着色点处所有法向量为$h$的微表面面积，乘以$(n\cdot w_h)$投影至宏观表面，将所有半球面上法线方向$wh$的投影面积积分，还是原来的着色点处的微分面积</p><p>化简可以得到概率密度函数</p><script type="math/tex; mode=display">\int_{\Omega^+}D(w_h)dw_h(n\cdot w_h)=1</script><hr><h3 id="Cook-Torrance-项推导"><a href="#Cook-Torrance-项推导" class="headerlink" title="$Cook-Torrance$项推导"></a>$Cook-Torrance$项推导</h3><p>代入微表面的<strong>辐入照度</strong></p><script type="math/tex; mode=display">\begin{align}d^3\phi_h &\equiv L_i(w_i)dw_id^2A_{h_\bot}\\\\&\equiv L_i(w_i)\cos\theta_{w_h}dw_id^2A_h\\\\&\equiv L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_hdA\end{align}</script><p>假定不受环境遮蔽项和菲姐尔项影响</p><script type="math/tex; mode=display">d^3\phi_h=d^3\phi_r</script><p>代入<strong>辐射出度</strong>定义</p><script type="math/tex; mode=display">\begin{align}dL_r &\equiv \frac{d^3\phi_r}{\cos\theta_rdw_rdA}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_hdA}{\cos\theta_rdw_rdA}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_h}{\cos\theta_rdw_r}\end{align}</script><p>代入$BRDF$定义</p><script type="math/tex; mode=display">\begin{align}\rho(w_r,w_i) &\equiv \frac{dL_r(w_r)}{dE_i}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_h}{\cos\theta_rdw_r}\cdot\frac{1}{L_i(w_i)\cos\theta_idw_i}\\\\&\equiv \frac{\cos\theta_{w_h}D(w_h)dw_h}{\cos\theta_r\cos\theta_idw_r}\end{align}</script><p>取特殊点$w_h$的立体角拆分为$(\theta,\phi)$,则$w_r=(2\theta\ mod\ \pi,\phi)$，则</p><script type="math/tex; mode=display">\begin{align}\frac{dw_h}{dw_r} &= \frac{\sin\theta_{w_h}d\theta_{w_h}\ d\phi}{\sin 2\theta_{w_h}d2\theta_{w_h} d\phi}\\\\&= \frac{\sin\theta_{w_h}d\theta_{w_h}\ d\phi}{4\sin\theta_{w_h}\cos\theta_{w_h}d\theta_{w_h} d\phi}\\\\&= \frac{1}{4\cos\theta_{w_h}}\end{align}</script><p>代回$BRDF$可得</p><script type="math/tex; mode=display">\rho(w_r,w_i)=\frac{D(w_h)}{4\cos\theta_r\cos\theta_i}</script><p>加入<strong>几何遮蔽项和菲涅尔项</strong>可得</p><script type="math/tex; mode=display">f_{Cook-Torrance}(w_r,w_i)=\frac{F(w_i,h)D(h)G(w_r,w_i,h)}{4(w_r\cdot n)(w_i\cdot n)}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;微表面理论的核心思想是将物体表面视为由无数微小、朝向各异的&lt;strong&gt;镜面&lt;/str</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="http://example.com/2024/10/30/2d-heap/"/>
    <id>http://example.com/2024/10/30/2d-heap/</id>
    <published>2024-10-30T14:59:23.000Z</published>
    <updated>2024-11-03T10:45:53.640Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p><strong>堆</strong>是一种树形数据结构，它不按照严格的<strong>排序规则</strong>维护数据，它只维护规则下的<strong>首序元素</strong></p></blockquote><ul><li>支持<strong>动态增删改</strong>节点（元素）</li></ul><p>$tips$ 改操作建立在增删操作，只需要堆内指针和外部元素相互存引用</p><ul><li>获取首序节点</li></ul><hr><h3 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h3><h4 id="排序规则-circ-的限制"><a href="#排序规则-circ-的限制" class="headerlink" title="排序规则$\circ$的限制"></a>排序规则$\circ$的限制</h4><ul><li><p>满足<strong>传递性</strong>：若有$key:A,B,C$且$A\circ B=true,B\circ C=true$，则$A\circ C=true$</p></li><li><p>排序规则对<strong>key</strong>没有影响，<em>这个更多是在程序上的限制</em></p></li></ul><blockquote><p>为了便于分析，只考虑二叉堆，实践中可能会使用更多<strong>幂次分叉</strong>利用缓存</p></blockquote><h4 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h4><ul><li>树<strong>节点</strong>存储<strong>元素</strong>：<strong>键值对</strong>$(key,val)$。所以对元素排序，隐含的意思是在$key$之间使用排序规则</li></ul><blockquote><p>$tips$ 在树的语境下使用节点$node$，在排序的语境下使用元素$key$，两者都是<strong>键值对</strong></p></blockquote><ul><li>子父节点关系：$parent_{key}\circ each\ child_{key}=true$</li></ul><blockquote><p>$tips$ 这里的子节点和父节点都是在树中的<strong>一级邻居点</strong>，简单来讲，不是祖父或者孙子之类的</p></blockquote><p>递归应用这个关系，即可以保证下面的性质</p><ul><li><strong>树根</strong>即这棵树（堆）包含的所有元素，在排序规则下的首序元素，即有$root_{key}\circ other\ node_{key}=true$</li></ul><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>若堆中存在$node$，且$node\ne root$使得$root_{key}\circ node_{key}=false$，则堆<strong>不满足子父节点关系</strong></p><p>$def\ root$到$node$的路径为$(root,T_0,T_1,\cdots,T_{n-1},node)$</p><p>则有</p><script type="math/tex; mode=display">\begin{align}root &\circ T_0=true\\\\T_0 &\circ T_1 =true\\\\T_{n-2} &\circ T_{n-1}=true\\\\T_{n-1} &\circ node=true\\\\\end{align}</script><p><em>省略了角标</em>$key$</p><p>根据排序规则的<strong>传递性</strong>，可得应该有$root_{key}\circ node_{key}=true$</p><p>可见，任意违反了<strong>子父关系</strong>的树都不是堆，只要维护子父关系就可以得到堆</p><hr><h3 id="维护堆性质"><a href="#维护堆性质" class="headerlink" title="维护堆性质"></a>维护堆性质</h3><p>$def\ Adjustment(node)$表示对改变了$key$的<strong>二叉堆堆</strong>中节点$node$进行调整</p><p>下面证明，如果堆中只有这一个改变，则这个操作会重新维持堆性质</p><h4 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h4><p>若$key\circ old\ key=true$，则节点可能往上调整</p><p>重复进行以下调整直至满足<strong>子父节点关系</strong></p><script type="math/tex; mode=display">if\ parnet_{key}\circ node_{key}=false</script><script type="math/tex; mode=display">swap(node,parent)</script><p>利用传递性规则可以证明每一步以$node$为根的堆都满足堆序</p><p>注意，$node$兄弟节点$bother$也会满足堆序，所以不可能有下滤</p><script type="math/tex; mode=display">\begin{align}parent &\circ bother=true\\\\node &\circ parent=true\\\\node &\circ bother=true\end{align}</script><h4 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h4><p>若$key\circ old\ key=false$，则节点可能往上调整</p><p>和上滤不同的是，这里需要<strong>确定所有子节点</strong>的首序元素$maxchild$，这也是叉树不同带来的影响，这里只考虑二叉堆，只需要一次$\circ$操作，如果叉树较大，可以展开为堆或者排序</p><p>总结为重复一下操作</p><script type="math/tex; mode=display">if\ node_{key}\circ maxchild_{key}=false</script><script type="math/tex; mode=display">swap(node,maxchild)</script><p>显然不会做上滤</p><p>综上，任意一次操作只会引起上滤或下滤，在<strong>二叉堆中</strong>，因为是<strong>完全二叉树</strong>，所以<strong>调整操作</strong>的时间复杂度度为$O(h)=O(\log^{n-1})$</p><hr><h4 id="初始化复杂度紧确界"><a href="#初始化复杂度紧确界" class="headerlink" title="初始化复杂度紧确界"></a>初始化复杂度紧确界</h4><p>因为任何堆的子树也是堆，所以从树叶到树根进行<strong>下滤</strong>操作可以获得这棵树元素组成的堆，时间复杂度为$O(N\log N)$，其中$N$为节点数量 ，但是这个界不是紧确的</p><ul><li><p>有$n$个节点的非空二叉堆的高度为$\lfloor\log(n)\rfloor$，可以根据$2^{h}-1\le n&lt;2^{h+1}-1$推导</p></li><li><p>在$n$个节点的二叉堆中，高度为$h$的堆节点最多有$\lceil\frac{n}{2^{h+1}} \rceil$个</p></li></ul><p><em>这里的高节是叶节点</em></p><p>则有时间复杂度</p><script type="math/tex; mode=display">\begin{align}\sum_{h=0}^{\lfloor\log n\rfloor}\lceil\frac{n}{2^{h+1}} \rceil O(h) &= O(n\sum_{h=0}^{\lfloor\log n\rfloor}\frac{h}{2^h})\\\\\sum_{h=0}^{\infty}\frac{h}{h^2} &= \frac{\frac{1}{2}}{(1-\frac{1}{2})^2}=2\\\\O(n\sum_{h=0}^{\lfloor\log n\rfloor}\frac{h}{2^h}) &= O(n\sum_{h=0}^{\infty}\frac{h}{h^2})=O(n)\end{align}</script><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="正确性验证"><a href="#正确性验证" class="headerlink" title="正确性验证"></a>正确性验证</h4><p><img src="https://s2.loli.net/2024/10/31/uvsP24cUCzNHZ6K.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Binary_Heap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line">vector&lt;T&gt; Heap;</span><br><span class="line"><span class="type">const</span> function&lt;<span class="keyword">auto</span>(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)-&gt;<span class="type">bool</span>&gt; op;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fa</span><span class="params">(<span class="type">size_t</span> idx)</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> (idx - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sa</span><span class="params">(<span class="type">size_t</span> idx)</span> -&gt; <span class="type">size_t</span> </span>&#123; </span><br><span class="line"><span class="type">size_t</span> sL = (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sL<span class="number">+1</span> == size)</span><br><span class="line"><span class="keyword">return</span> sL;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op</span>(Heap[sL], Heap[sL + <span class="number">1</span>]) ? sL : sL + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">up</span><span class="params">(<span class="type">size_t</span> hole)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> val = Heap[hole];</span><br><span class="line"><span class="keyword">for</span> (; hole &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">op</span>(Heap[<span class="built_in">fa</span>(hole)], val); hole = <span class="built_in">fa</span>(hole))</span><br><span class="line">Heap[hole] = Heap[<span class="built_in">fa</span>(hole)];</span><br><span class="line">Heap[hole] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">down</span><span class="params">(<span class="type">size_t</span> hole)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> val = Heap[hole];</span><br><span class="line"><span class="keyword">for</span> (; (hole &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt; size &amp;&amp; !<span class="built_in">op</span>(val, Heap[<span class="built_in">sa</span>(hole)]); hole = <span class="built_in">sa</span>(hole))</span><br><span class="line">Heap[hole] = Heap[<span class="built_in">sa</span>(hole)];</span><br><span class="line">Heap[hole] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Binary_Heap</span>(vector&lt;T&gt;::const_iterator begin, vector&lt;T&gt;::const_iterator end, <span class="type">const</span> function&lt;<span class="built_in">auto</span>(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)-&gt;<span class="type">bool</span>&gt; op)</span><br><span class="line">:<span class="built_in">Heap</span>(begin, end), <span class="built_in">size</span>(<span class="built_in">distance</span>(begin, end)), <span class="built_in">op</span>(op) &#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">1</span>) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">fa</span>(size - <span class="number">1</span>); i != <span class="number">0</span>; --i)</span><br><span class="line"><span class="built_in">down</span>(i);</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">top</span><span class="params">()</span> -&gt; T </span>&#123; <span class="keyword">return</span> Heap.<span class="built_in">front</span>(); &#125;<span class="comment">//返回值，请勿直接更改</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span>-&gt;<span class="type">void</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == Heap.<span class="built_in">size</span>())</span><br><span class="line">Heap.<span class="built_in">resize</span>((size &lt;&lt; <span class="number">1</span>) + <span class="number">16</span>);</span><br><span class="line">Heap[size] = val;</span><br><span class="line"><span class="built_in">up</span>(size++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">Heap.<span class="built_in">front</span>() = Heap[--size];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;是一种树形数据结构，它不按照严格的&lt;strong&gt;排序规则&lt;/str</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>蒙特卡洛路径追踪</title>
    <link href="http://example.com/2024/10/30/Monte-Carlo-path-tracing/"/>
    <id>http://example.com/2024/10/30/Monte-Carlo-path-tracing/</id>
    <published>2024-10-30T10:54:59.000Z</published>
    <updated>2024-11-03T10:41:03.019Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="从-BRDF-到渲染方程"><a href="#从-BRDF-到渲染方程" class="headerlink" title="从$BRDF$到渲染方程"></a>从$BRDF$到渲染方程</h4><p>$BRDF$定义下的反射方程为</p><script type="math/tex; mode=display">L_r(w_r)=\int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i</script><ul><li><p>这个方程是递归定义的，方程式左右两边都有辐射度$L(w)$，可以实现物体间的反射</p></li><li><p>引入物体的自发辐射度$L_e(w)$，<em>属于出射辐射度</em></p></li><li><p>引入表面法向量，则有$\cos\theta=n\cdot w$</p></li></ul><p>得到渲染方程</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)(n\cdot w_i)dw_i</script><p>表示像素$P$沿$w_r$方向的<strong>出射辐射度</strong>为：沿$w_r$的自发辐射度，和各个正球面立体角角接收到的<strong>衰减</strong>后的入射辐射度$\rho(w_i,w_r)\cdot L_i(w_i)$的加和</p><h4 id="渲染方程的解"><a href="#渲染方程的解" class="headerlink" title="渲染方程的解"></a>渲染方程的解</h4><p>渲染方程中$L_e(w_r),\rho(w_i,w_j)$和表面材质相关，所以他们是已知的，方程的未知项只有$L_i(w_i)$</p><script type="math/tex; mode=display">def\ K(w_i,w_r)=\rho(w_i,w_r)L_i(w_i)(n\cdot w_i)</script><p>$n$<em>法向和像素相关，这个方程使用对象是每个像素，所有</em>$n$<em>隐含其中</em>，则可以得到参数化的方程组</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\int_{\Omega^+}K(w_i,w_r)L_i(w_i)dw_i</script><p>这个方程的属于<strong>第二类弗雷德霍姆积分方程</strong>，目前实践中使用<strong>近似求解</strong></p><hr><h3 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h3><blockquote><p>蒙特卡洛积分（Monte Carlo Integration）是一种数值方法，用于求解难以通过解析方式得到的定积分。其基本思想是对函数值进行多次<strong>随机采样</strong>（这也是和黎曼积分的区别）然后求这些采样值的平均值作为积分的近似</p></blockquote><p>积分函数$f(x)$在采样分布$P(x)$的前提下，采样$N$个<strong>样点</strong>的蒙特卡洛积分值$MF_N$可以这样计算</p><script type="math/tex; mode=display">\begin{align}F &= \int_a^bf(x)dx\tag{Integral function}\\\\X &\equiv p(x_i)\tag{Probability density function}\\\\MF_N &=\frac{1}{N}\sum_{i=1}^N\frac{f(x_i)}{p(x_i)}\tag{Monte Carlo Integration}\end{align}</script><p>接下来证明分布函数$P(x)$对积分的影响</p><script type="math/tex; mode=display">\begin{align} \frac{1}{N}\sum_{i=1}^N\frac{f(x_i)}{p(x_i)} &= E(\frac{f(x_i)}{p(x_i)})\\\\E(\frac{f(x_i)}{p(x_i)}) &=\int_a^b(\frac{f(x_i)}{p(x_i)}p(x_i)+0\ast(1-p(x_i)))dx\\\\&= \int_a^bf(x_i)dx\end{align}</script><p>将蒙特卡洛采样用于渲染方程可得</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\frac{1}{N}\sum_{i=1}^{N}\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}</script><hr><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><blockquote><p>蒙特卡洛方法理论上是一种无偏估计，但是$N$值在复杂度增长会出现$N^N$的增长，路径追踪只考虑其中一条反射光线</p></blockquote><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}</script><p>此时，每个像素无论弹射多少次，只会有一条光线在场景中反射，解决方法是在更高层次(像素)增加采样率</p><p>若每个像素发出$M$条光线，则有渲染方程</p><script type="math/tex; mode=display">\begin{align}L_p &= \sum_{j=0}^M\alpha(j)L_j\\\\L_r(w_r) &= L_e(w_r)+\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}\end{align}</script><blockquote><p>$tips$ 这个方程对于单个像素不再是纯递归的</p></blockquote><p>形式化的讲，原本的渲染方程</p><script type="math/tex; mode=display">for\ each\ Pixel\ call\ L_p=shader(Ray_p)</script><p>在像素级别增加采样率后</p><script type="math/tex; mode=display">for\ each\ Pixel\ call\ L_p=merge(P)</script><script type="math/tex; mode=display">merge:</script><script type="math/tex; mode=display">for\ i=1\ to M\ call\ L_p+=shader(Ray_i)</script><hr><h3 id="俄罗斯轮盘赌-Russian-Roulette"><a href="#俄罗斯轮盘赌-Russian-Roulette" class="headerlink" title="俄罗斯轮盘赌($Russian\ Roulette$)"></a>俄罗斯轮盘赌($Russian\ Roulette$)</h3><p>除了遇到光源的递归基外，还需要组合边界条件防止无线递归，比如弹射次数，能量衰减</p><p>蒙特卡洛路径追踪标准方法采用<strong>随机方法</strong>俄罗斯轮盘赌($Russian\ Roulette$)</p><p>除了递归入口外，对每一步递归函数实例过程做动态判断，它是否为还应递归下去</p><p>形式化的讲</p><ul><li><p>每一个$shader(Ray)$都关联一个随机数$P\in[0,1]$，$P_d$的值从$1$随着递归变深减小</p></li><li><p>若一个$shader$函数实例没有到达显示的递归基(射向光源，场景边界)，则需要生成随机数$p\in (0,1]$</p></li><li><p>若有$p\le P$，则返回$0$，<em>这个像素采样点映射的物体没有被光源照射</em></p></li></ul><h4 id="贡献分配"><a href="#贡献分配" class="headerlink" title="贡献分配"></a>贡献分配</h4><blockquote><p>当应用俄罗斯轮盘赌策略时，如果一条光线被决定继续其路径，它的贡献值需要通过除以$P_d$来放大，这一过程是为了补偿那些按照规则被提前终止的光线可能带来的贡献</p></blockquote><p>形式化的讲</p><script type="math/tex; mode=display">E=\sum_{d=1}^{maxD}(P_d(L_d/P_d)+((1-P_d)\ast 0))=\sum_{d=0}^{maxD}L_d=L_p</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;从-BRDF-到渲染方程&quot;&gt;&lt;a href=&quot;#从-BRDF-到渲染方程&quot; class=&quot;headerlink&quot; title=&quot;从$BRDF$到渲染方程&quot;&gt;&lt;/a&gt;从$BRDF$到渲染方程&lt;/h4&gt;&lt;p&gt;$BRDF$定义下的反射方程为&lt;/p&gt;
&lt;scri</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>辐射度量</title>
    <link href="http://example.com/2024/10/30/Radiometry/"/>
    <id>http://example.com/2024/10/30/Radiometry/</id>
    <published>2024-10-30T05:01:40.000Z</published>
    <updated>2024-11-08T13:52:48.957Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="光与颜色"><a href="#光与颜色" class="headerlink" title="光与颜色"></a>光与颜色</h3><h4 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h4><p>电磁频谱是指电磁辐射按照<strong>频率</strong>$f$或<strong>波长</strong>$T$的顺序排列所形成的连续范围。它涵盖了从极低频的无线电波到极高频的伽马射线</p><ul><li><p>$T$（$s$）是电磁波上相继的两个具有相同<strong>振幅</strong>的点之间的时间，<strong>频率</strong>$f=\frac{1}{T}$（$s^{-1}$）</p></li><li><p>电磁波在单个周期中<strong>传播距离</strong>$\lambda=\frac{c}{f}$</p></li><li><p>在真空中，光速$c=3\times 10^8ms^{-1}$</p></li></ul><blockquote><p>$tips$ 波长的国际单位是$nm,1nm=10^{-9}m$</p></blockquote><p>在电磁辐射的<strong>波动</strong>模型中，光被描述为在空间中横向振荡传播的电场和磁场</p><p><strong>可见光</strong>（$Visible\ light$）：波长范围大约从$750nm$到$400nm$，这是人类眼睛能够感知的电磁辐射范围，每一种<strong>波长</strong>对应一<strong>光谱颜色</strong></p><hr><h4 id="颜色心理学特征"><a href="#颜色心理学特征" class="headerlink" title="颜色心理学特征"></a>颜色心理学特征</h4><p>人对光的感知主要由以下因素影响</p><ul><li><p><strong>主频率</strong>：人眼接收光波的主要可见光频率段</p></li><li><p><strong>亮度</strong>：人眼接收到的光能量，这会在<strong>辐射度量</strong>中详细介绍</p></li><li><p><strong>饱和度</strong>：色彩理论术语，这里只考虑光中包含的波长范围较窄，实际还有很多影响因素，比如对比度，亮度</p></li></ul><hr><h3 id="辐射度量光照模型"><a href="#辐射度量光照模型" class="headerlink" title="辐射度量光照模型"></a>辐射度量光照模型</h3><p>基本的光照模型利用经验来近似光照效果，而辐射度光照模型以<strong>辐射度量学</strong>定量分析光的传播</p><p>尽管后序的渲染还需要对这一过程做近似处理</p><p>这里简单将<strong>辐射</strong>定义为：<strong>大量光子的集合</strong></p><hr><h2 id="辐射度量术语"><a href="#辐射度量术语" class="headerlink" title="辐射度量术语"></a>辐射度量术语</h2><h3 id="辐射能量（-Radiant-Energy-）"><a href="#辐射能量（-Radiant-Energy-）" class="headerlink" title="辐射能量（$Radiant\ Energy$）"></a>辐射能量（$Radiant\ Energy$）</h3><p><em>可以用符号</em>$E$或$Q$<em>表示，避免符号冲突，这里用</em>$Q$</p><p>在光的量子模型中，光的<strong>辐射能量</strong>由<strong>光子</strong>携带，由普朗克-爱因斯坦关系式，可得频率为$f$的<strong>光子能量</strong>$e=h\frac{c}{\lambda}$</p><p>其中$h$为普朗克常量$6.6262\times 10^{-34}Js^{-1}$</p><p>则<strong>辐射能量</strong>可以表示为</p><script type="math/tex; mode=display">Q\equiv\sum_{\lambda}h\frac{c}{\lambda}</script><p>特定波长的<strong>光谱能量</strong>为$E_{\lambda}\frac{dQ}{d\lambda}$，<em>名字具有误导性，它是一个密度函数</em></p><blockquote><p>$tips$ 之后的各种计量都可以把各种波长分开做成<strong>频谱</strong>来分析</p></blockquote><h3 id="辐射通量（-Radiant-Flux-）"><a href="#辐射通量（-Radiant-Flux-）" class="headerlink" title="辐射通量（$Radiant\ Flux$）"></a>辐射通量（$Radiant\ Flux$）</h3><ul><li>单位时间传递的辐射能量，也叫<strong>光通量</strong></li></ul><blockquote><p>其单位为$W$，出现在照明产品的说明书上，度量光源（产品）的发光能力</p></blockquote><script type="math/tex; mode=display">\phi\equiv\frac{dQ}{dt}</script><h3 id="辐射强度（-Radiant-Intensity-）"><a href="#辐射强度（-Radiant-Intensity-）" class="headerlink" title="辐射强度（$Radiant\ Intensity$）"></a>辐射强度（$Radiant\ Intensity$）</h3><ul><li>点辐射源在某一方向上单位立体角内传送的辐射通量，用$I$表示</li></ul><blockquote><p>度量光源在某个方向上的发出的辐射通量，通常用来计算表面的辐照度</p></blockquote><script type="math/tex; mode=display">I(w)\equiv\frac{d\phi}{dw}</script><blockquote><p>辐射强度不止和光源本身属性相关，和<strong>立体角</strong>$w$相关，所以这个函数有额外的输入$w$</p></blockquote><hr><h4 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h4><p>立体角是三维空间的角，参考二维平面上角的定义$\theta\equiv\frac{l}{r}$，其中$l$是圆弧，$r$是原半径</p><p>可以得到立体角定义</p><script type="math/tex; mode=display">\Omega\equiv\frac{A}{r^2}</script><p>下面是对立体角积分$dw$的推导</p><script type="math/tex; mode=display">\begin{align}dA &= (rd\theta)(r\sin\theta d\phi)=r^2\sin\theta\ d\theta\ d\phi\\\\dw &= \frac{dA}{r^2}=\sin\theta\ d\theta\ d\phi\end{align}</script><p><em>为了使表达更直观，符号乘法之间有间隙，但是意思没变</em></p><hr><h3 id="辐照度（-Irradiance-）"><a href="#辐照度（-Irradiance-）" class="headerlink" title="辐照度（$Irradiance$）"></a>辐照度（$Irradiance$）</h3><ul><li>单位面积上离开表面的辐射通量，这个量也称为<strong>辐出度</strong>（$H$）</li></ul><blockquote><p>$tips$ 这里不用射入来定义，因为当表示为”辐入度“时，隐含的是光线和表明垂直的标准化亮度</p><p>表现场景中表面的光照效果</p></blockquote><script type="math/tex; mode=display">E\equiv\frac{d\phi}{\cos\theta\ dA}</script><h3 id="辐射度（-Radiance-）"><a href="#辐射度（-Radiance-）" class="headerlink" title="辐射度（$Radiance$）"></a>辐射度（$Radiance$）</h3><ul><li>每单位立体角，每单位<strong>垂直</strong>面积的辐射强度</li></ul><blockquote><p>辐射度是一个描述面辐射源上某点在特定方向上辐射特性的物理量。它不仅考虑了辐射源的强度，还考虑了辐射在空间中的分布情况</p></blockquote><script type="math/tex; mode=display">L(w)\equiv\frac{d\phi^2}{\cos\theta\ dw\ dA}\equiv\frac{dE}{\cos\theta\ dw}</script><p>其中$\theta$为点$P$的法线和$-Ray$的夹角，若为负，则是内表面，定义为$0$</p><p>因为<strong>辐射能量的接收量会因入射角的不同而变化</strong>，所以需要矫正为<strong>标准化亮度</strong>，即垂直方向的面积</p><p>这里区分辐照度和辐出度</p><script type="math/tex; mode=display">L_{i}(w)\equiv\frac{dE}{\cos\theta\ dw}</script><script type="math/tex; mode=display">L_{r}(w)\equiv\frac{dH}{\cos\theta\ dw}</script><p>$L_{in}$表示表面的输入辐射率，$L_{out}$表示表面输出的辐射率</p><p>下面的推导证明了辐射度在光源和场景表面的桥梁关系</p><script type="math/tex; mode=display">\begin{align}L(w) &\equiv \frac{dE}{\cos\theta\ dw}\\\\dE(w) &\equiv L(w)\cos\theta\ dw\\\\E &\equiv \int_{\Omega^+}L(w)\cos\theta\ dw\end{align}</script><p>其中，最后一步积分是对所有来自表面上方的方向的辐射强度积分，则可以把立体角转换为上半球面坐标</p><p>代入立体角积分$dw=\sin\theta\  d\theta\  d\phi$</p><script type="math/tex; mode=display">E\equiv\int_{\theta=0}^{\frac{\pi}{2}}\int_{\phi=0}^{2\pi}L(w)\sin\theta\ \cos\theta\ d\theta\ d\phi</script><p>如果假设表面在各个方向接收到的入射辐射通量相同，即</p><script type="math/tex; mode=display">L(w)=L</script><p>那么可以直接积分得</p><script type="math/tex; mode=display">E=\pi L</script><hr><h2 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数($BRDF$)"></a>双向反射分布函数($BRDF$)</h2><blockquote><p>双向反射分布函数（Bidirectional Reflectance Distribution Function，简称BRDF）是一个用于描述表面如何反射光线的数学函数</p></blockquote><p>简单来讲，任何来自入射方向$w_i$的入射光线，都有一部分反射在反射方向$w_r$方向附近的立体角内</p><p>$BRDF$描述这样一个过程：表面元接受到某一方向辐射照度（$dE$）之后，向不同方向把能量辐射出去（$dL_r$）,这个过程的能量比值，即</p><blockquote><p>关于为什么这么定义，而不是$\frac{dL_i(w_i)}{dL_r(w_r)}$，是因为它所属的学科：辐射<strong>度量</strong>学：</p><ul><li>使用一个固定方向的点光源照射一块面积，测量一段时间该表面的能量变换$\Delta Q$。就有$E=\frac{\Delta Q}{\Delta t\Delta A}$</li><li>用同样的方法同时测量某个反射方向的表面，有$\Delta L_r(w_r)$</li></ul></blockquote><script type="math/tex; mode=display">\rho(w_i,w_r)\equiv\frac{dL_r(w_r)}{dE_i}\equiv\frac{dL_r(w_r)}{L_i(w_i)\cos\theta\ dw_i}</script><p>从中可以推导<strong>反射方程</strong></p><script type="math/tex; mode=display">\begin{align}dL_r(w_r) &= \rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i\\\\L_r(w_r) &= \int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i\end{align}</script><p>反射方程表明，某一方向上的的反射光，是由所有不同方向上入射光线的辐射度贡献得到的</p><hr><h2 id="半球面方向反射系数-HDFR"><a href="#半球面方向反射系数-HDFR" class="headerlink" title="半球面方向反射系数$(HDFR)$"></a>半球面方向反射系数$(HDFR)$</h2><blockquote><p>半球面方向反射系数$R$（$Hemispherical\ Directional\ Reflectance\ Factor$），通常简称为$HDRF$，是描述表面在半球面上所有方向反射光能力的物理量。它是表面反射特性的一个度量，用来量化材料表面在受到光照时，向所有可能方向反射光的比例。</p></blockquote><p>根据定义和能量守恒，有$0\le R\le 1$</p><ul><li><p>$R=1$：理想的黑色体，吸收了所有光</p></li><li><p>$R=0$：理想的白色体，反射所有入射光</p></li></ul><p>在<strong>计算机图形学</strong>中，通常研究的变量是入射光方向</p><script type="math/tex; mode=display">R(w_i)\equiv\frac{E}{H_i}\equiv\int_{\Omega^+}\rho(w_i,w_r)\cos\theta_r dw_r</script><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><script type="math/tex; mode=display">\begin{align}L_r(w_r) &\equiv \frac{dE}{\cos\theta_rdw_r}\\\\\rho(w_i,w_r) &\equiv \frac{L_r(w_r)}{H_i}\\\\H_i\rho(w_i,w_r) &\equiv \frac{dE}{\cos\theta_rdw_r}\\\\\frac{dE}{H_i} &\equiv \rho(w_i,w_r)cos\theta_rdw_r\\\\\frac{E}{H_i} &\equiv \int_{\Omega^+}\rho(w_i,w_r)\cos\theta_r dw_r\end{align}</script><hr><h2 id="理想的漫反射-BRDF"><a href="#理想的漫反射-BRDF" class="headerlink" title="理想的漫反射$BRDF$"></a>理想的漫反射$BRDF$</h2><blockquote><p>理想的漫反射表面即为朗伯表面：$BRDF\rho(w_i,w_r)$为常量</p></blockquote><p>下面推导其$HDFR$特征</p><script type="math/tex; mode=display">\begin{align}R(w_i) &= \int_{\Omega^+}\rho\cos\theta_r dw_r\\\\&= \int_{\theta_r=0}^{\frac{\pi}{2}}\int_{\phi_r=0}^{2\pi}\rho\sin\theta_r\cos\theta_rd\theta_rd\phi_r\\\\&= \rho\pi\end{align}</script><p>所以有关于朗伯表面的结论</p><script type="math/tex; mode=display">\rho=\frac{R}{\pi}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;光与颜色&quot;&gt;&lt;a href=&quot;#光与颜色&quot; class=&quot;headerlink&quot; title=&quot;光与颜色&quot;&gt;&lt;/a&gt;光与颜色&lt;/h3&gt;&lt;h4 id=&quot;电磁频谱&quot;&gt;&lt;a href=&quot;#电磁频谱&quot; class=&quot;headerlink&quot; title=&quot;电磁频谱</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
</feed>
