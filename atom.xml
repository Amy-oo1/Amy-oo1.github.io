<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amy_blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-12T08:26:31.527Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Amy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速傅里叶变换[2]</title>
    <link href="http://example.com/2024/10/12/FFT-2/"/>
    <id>http://example.com/2024/10/12/FFT-2/</id>
    <published>2024-10-12T02:32:23.000Z</published>
    <updated>2024-10-12T08:26:31.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="朴素的算法"><a href="#朴素的算法" class="headerlink" title="朴素的算法"></a>朴素的算法</h2><p>一个$n$次多项式的点值表达式变换需要的工作就是计算项集：</p><script type="math/tex; mode=display">\lbrace (x_i,y_i)\lvert 0\le i\le n-1 ,y_i=\sum_{j=0}^{j=n-1}a_jx_i^j \rbrace</script><p>使用朴素方法需要$\log (n^2)$的时间<br>用矩阵的逆(<strong>UL分解</strong>)求解逆变换需要$\log (n^3)$时间，即便使用拉格朗日公式也需要$\log (n^2)$的时间，<br>整体上多项式乘法乘法并没有得到改进</p><h2 id="折半原理"><a href="#折半原理" class="headerlink" title="折半原理"></a>折半原理</h2><p>定义<strong>主单位复数根</strong>：</p><script type="math/tex; mode=display">W_n=e^{\frac{2\pi i}{n}} \tag{1}</script><p>使得</p><script type="math/tex; mode=display">(W_n^k)^n=1</script><p>而$W_n^{(k)}$称为<strong>n次单位复数根</strong>,这一类复数有着特殊的性质:<br>根据公式(1)可得<strong>消去原理</strong>：</p><script type="math/tex; mode=display">W_{2n}^{2k}=\left (e\frac{2\pi}{2n} \right) ^{2k}=\left( e\frac{2\pi}{n} \right)^k=W_n^k \tag{2}</script><p>使用公式(2)对于$n$为偶数的主单位复数根，有<strong>折半原理</strong>：</p><script type="math/tex; mode=display">\left( W_n^k \right)^2=\left( W_n^{k+n/2} \right)^2= W_{n/2}^k \tag{3}</script><p>这表明<strong>n次单位复数根的平方集合等价于n/2次单位复数集等价</strong>，</p><h2 id="DFT"><a href="#DFT" class="headerlink" title="$DFT$"></a>$DFT$</h2><p>考虑将$n$次单位复数根用在n次多项式点值表达式求值:</p><script type="math/tex; mode=display">y_k=A(W_n^k)=\sum_{j=0}^{j=n-1} a_j(W_n^k)^j</script><p>向量$y=(y_0,y_1,y_2,\cdots,y_n-1)$就是系数向量$a=(a_0,a_1,a_2,\cdots,a_n-1)$的<strong>离散傅里叶变换</strong>(Discrete Fourier transform,<strong>DFT</strong>),记为</p><script type="math/tex; mode=display">y=DFT_n(a)</script><h2 id="FFT"><a href="#FFT" class="headerlink" title="$FFT$"></a>$FFT$</h2><p>对于$n$(n为2的幂)次次多项式，采用偶/奇数项系数，构造n/2次数多项式：</p><script type="math/tex; mode=display">A_{even}(x)=a_o+a_2x^1+a_4x^2+\cdots+a_{n-2}x^{(n/2-1)}</script><script type="math/tex; mode=display">A_{odd}(x)=a_1+a_3x^1+a_4x^3+\cdots+a_{n-1}^{(n/2-1)}</script><p>则有</p><script type="math/tex; mode=display">A(x)=A_{even}(x^2)+xA_{odd}^{x^2}</script><p>代入折半原理(3)左边两项</p><script type="math/tex; mode=display">\begin{align} Y_k &= A(W_n^k) \\\\ &= A_{even}(W_n^{2k})+W_n^kA_{odd}(W_n^{2k}) \\\\ &=A_{even}(W_{n/2}^{k})+W_n^kA_{odd}(W_{n/2}^{k}) \tag{消去原理} \\\\ &=y_{even_k}+W_n^ky_{odd_k} \end{align}</script><script type="math/tex; mode=display">\begin{align}Y_{n/2+k} &=A(W_n^{n/2+k)}) \\\\ &= A_{even}({W_n^{n+2k}})++W_n^{n/2+k}A_{odd}(W_n^{n+2k}) \\\\ &= A_{even}({W_n^{2k}})-W_n^{k}A_{odd}(W_n^{2k})  \tag{3} \\\\ &= y_{even_k} -W_n^ky_{odd_k} \tag{消去原理}\end{align}</script><p>3式可以通过欧拉公式 $e^{ui}=\cos(u)+i\sin{u}$得出  </p><p>根据以上结果，我们可以递归计算奇偶项系数组成多项式的DFT，递归基为$n=1$,此时$y=a$</p><h2 id="DFT-n-1"><a href="#DFT-n-1" class="headerlink" title="$DFT_n^{-1}$"></a>$DFT_n^{-1}$</h2><p><strong>逆离散傅里叶变换</strong>同样从矩阵乘法找思路，把DFT写成矩阵乘积</p><script type="math/tex; mode=display">y=V_na</script><p>此时的逆矩阵并不需要<strong>UL分解</strong>这样的技术，我们只抛出结论</p><script type="math/tex; mode=display">V_n^{-1}[j][k]=\frac{W_n^{-kj}}{n}</script><p>可以推出$DFT_n^{-1}(y)$：</p><script type="math/tex; mode=display">a_j=\frac{1}{n}\sum_{k=0}^{k=n-1}y_kW_n^{-kj}</script><p>综上所述，我们用$DFT_n$处理单位根的倒数，最后除$n$即可实现$DFT_n^{-1}$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">S_FFT</span><span class="params">(vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; A_T, <span class="type">int</span> re_T=<span class="number">1</span>)</span> -&gt; vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; </span>&#123;<span class="comment">//长度为2的幂</span></span><br><span class="line"><span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> sub_fft = [&amp;pi](<span class="keyword">auto</span> &amp;self,vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; A, <span class="type">int</span> re = <span class="number">1</span>)-&gt;vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; &#123;</span><br><span class="line"><span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">Wn</span><span class="params">(cos(<span class="number">2.0</span> * pi / <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(n)), sin(<span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(re) * <span class="number">2.0</span> * pi / <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(n)))</span>, <span class="title">W</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">A_even</span>(n &gt;&gt; <span class="number">1</span>), <span class="built_in">A_odd</span>(n &gt;&gt; <span class="number">1</span>), <span class="built_in">Y</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">A_even[i &gt;&gt; <span class="number">1</span>] = A[i];</span><br><span class="line">A_odd[i &gt;&gt; <span class="number">1</span>] = A[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> y_even = <span class="built_in">self</span>(self, A_even, re);</span><br><span class="line"><span class="keyword">auto</span> y_odd = <span class="built_in">self</span>(self, A_odd, re);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n &gt;&gt; <span class="number">1</span>); ++i) &#123;</span><br><span class="line">Y[i] = y_even[i] + W * y_odd[i];</span><br><span class="line">Y[i + (n &gt;&gt; <span class="number">1</span>)] = y_even[i] - W * y_odd[i];</span><br><span class="line">W *= Wn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> T_Y = <span class="built_in">sub_fft</span>(sub_fft,A_T, re_T);</span><br><span class="line"><span class="keyword">if</span> (re_T == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; y : T_Y)</span><br><span class="line">y /= complex&lt;<span class="type">double</span>&gt;&#123;<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(A_T.<span class="built_in">size</span>()), <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> T_Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未完成的工作"><a href="#未完成的工作" class="headerlink" title="未完成的工作"></a>未完成的工作</h2><p>FFT还有各种优化，比如蝶形优化优化递归，并行计算$\cdots$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;朴素的算法&quot;&gt;&lt;a href=&quot;#朴素的算法&quot; class=&quot;headerlink&quot; title=&quot;朴素的算法&quot;&gt;&lt;/a&gt;朴素的算法&lt;/h2&gt;&lt;p&gt;一个$n$次多项式的点值表达式变换需要的工作就是计算项集：&lt;/p&gt;
&lt;script type=&quot;math/tex; </summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="优化" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>快速傅里叶变换[1]</title>
    <link href="http://example.com/2024/10/12/FFT_1/"/>
    <id>http://example.com/2024/10/12/FFT_1/</id>
    <published>2024-10-11T17:22:21.000Z</published>
    <updated>2024-10-12T08:12:59.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速傅里叶可以做什么"><a href="#快速傅里叶可以做什么" class="headerlink" title="快速傅里叶可以做什么"></a>快速傅里叶可以做什么</h2><p><strong>快速傅里叶变换</strong>（Fast Fourier transform ,<strong>FFT</strong>）可以用来加算多项式乘法 ，音频信号处理等</p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h3><p>次数界为$n$的多项式表示为：  </p><script type="math/tex; mode=display">A(x)=\sum_{i=0}^{i=n-1}a_iX^i</script><p>若  </p><script type="math/tex; mode=display">B(x)=\sum_{i=0}^{i=n-1}b_iX^i,C(x)=\sum_{i=0}^{i=2n-2}c_iX^i</script><p>且$C(x)$为多项式$A(x)$和$B(x)$的乘积，则  </p><script type="math/tex; mode=display">ci=\sum_{j=0}^{j=i}a^ib^{i-j}</script><p>朴素多项式乘积算法时间复杂度为$\log(n^2)$</p><h3 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h3><p>使用<strong>霍纳规则</strong>，累乘$x$项，可以在<strong>$\log(n)$</strong>时间完成多项式加法：  </p><script type="math/tex; mode=display">A(x)=a_o+x(a_1+x(a_2\cdots+xa_n\cdots))</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Horner</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; nums)</span>-&gt;<span class="type">int</span> </span>&#123;<span class="comment">//nums正序</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">y = nums[i] + x * y;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点值表达式"><a href="#点值表达式" class="headerlink" title="点值表达式"></a>点值表达式</h2><h3 id="点值表达式的转换"><a href="#点值表达式的转换" class="headerlink" title="点值表达式的转换"></a>点值表达式的转换</h3><p>一个多项式依靠各项的系数区分，一个$n$次多项式的<strong>系数表达式</strong>为：  </p><script type="math/tex; mode=display">a=(a_0,a_1,a_2,\cdots,a_{n-1})</script><p><strong>点值表达式</strong>为n个点值对组成的集合：  </p><script type="math/tex; mode=display">\{(x_o,y_o),(x_1,y_1),(x_2,y_2),\cdots,(x_{n-1},y_{n-1})\}</script><p>使得$x_i$互不相同，且  </p><script type="math/tex; mode=display">y_i=A(x_i)</script><p>对于任一点值表达式，对应的系数表达式唯一可以通过矩阵表示证明：</p><script type="math/tex; mode=display">\left[  \begin{matrix}1 & x_0 & x_0^2 & \cdots & x_0^{n-1} \\\\1 & x_1 & x_1^2 & \cdots & x_1^{n-1} \\\\\vdots & \vdots & \vdots & \ddots & \vdots \\\\1 & x_{n-1} & x_{n-1}^2 & \cdots & x_{n-1}^{n-1} \\\\\end{matrix} \right]                                    \left[  \begin{matrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \vdots \\\\ a_{n-1} \end{matrix} \right]  =  \left[  \begin{matrix} y_o \\\\ y_1 \\\\ y_2 \\\\ \vdots \\\\ y_{n-1}     \end{matrix} \right]</script><p>点值表达式所选点构成了方程最左边的<strong>范德蒙矩阵</strong>$V$，若   </p><script type="math/tex; mode=display">\det(V)=\prod_{0\le i\le j\le n-1}(x_j-x_i) \neq 0</script><p>则多项式唯一。</p><p><strong>即任意多项式，系数表达式可以对应多个点值表达式，<br>合法（满足$x_i$项互不相同）的点值表达式，对应唯一的系数表达式</strong></p><h3 id="点值表达式的特殊性"><a href="#点值表达式的特殊性" class="headerlink" title="点值表达式的特殊性"></a>点值表达式的特殊性</h3><p>多项式在系数表达式的形式上进行运算的时间复杂度没有突破，我们可以把目光放在点值表达式上，这也是我们进行转换的初衷。<br>对于$n$次多项式$A$的某一点值表示</p><script type="math/tex; mode=display">\{(x_0,y_{o_a}),(x_1,y_{1_a}),(x_2,y_{2_a}).\cdots,(x_{n-1},y_{n-1{a}}) \}</script><p>且$n$次多项式特定的（点值项第一项集合相同）的点值表示</p><script type="math/tex; mode=display">\{(x_0,y_{o_b}),(x_1,y_{1_b}),(x_2,y_{2_b}).\cdots,(x_{n-1},y_{n-1{b}}) \}</script><p>则有多项式$C(x)=A(x)+B(X)$，它的某一点值多项表示为：</p><script type="math/tex; mode=display">\{(x_0,y_{o_a}+y_{o_b}), (x_1,y_{1_a}+y_{1_b}),(x_2,y_{2_a}+y_{2_b}),\cdots,(x_{n-1},y_{n-1{a}}+y_{n-1{b}}) \}</script><p>类似的，若对多项式$A,B$扩展到$2n$，则有多项式$C(x)=A(x)B(X)$，它的某一点值多项表示为：</p><script type="math/tex; mode=display">\{(x_0,y_{o_a}y_{o_b}), (x_1,y_{1_a}y_{1_b}),(x_2,y_{2_a}y_{2_b}),\cdots,(x_{n-1},y_{n-1{a}}y_{n-1{b}}) \}</script><p><em>将每一个$y_i$展开便可以证明</em></p><p>综上，<strong>点值表达式进行乘法运算只需要$\log(n)$的时间复杂度</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速傅里叶可以做什么&quot;&gt;&lt;a href=&quot;#快速傅里叶可以做什么&quot; class=&quot;headerlink&quot; title=&quot;快速傅里叶可以做什么&quot;&gt;&lt;/a&gt;快速傅里叶可以做什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;快速傅里叶变换&lt;/strong&gt;（Fast Fourier </summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="优化" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
