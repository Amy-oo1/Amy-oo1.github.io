<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amy_blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-28T04:26:33.656Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Amy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>样条曲线</title>
    <link href="http://example.com/2024/10/28/Spline/"/>
    <id>http://example.com/2024/10/28/Spline/</id>
    <published>2024-10-27T23:49:30.000Z</published>
    <updated>2024-10-28T04:26:33.656Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>样条</strong>（$Spline$）在数学和图形学中指的是一种通过一系列<strong>控制点</strong>来生成平滑<strong>曲线</strong>或<strong>曲面</strong>的方法</p></blockquote><hr><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p><strong>分段定义</strong>：样条曲线通常由多个数学上<strong>多项式函数</strong>的<strong>曲线段</strong>组成，每一段曲线在其定义的区间内都是光滑的，且在控制点处与相邻的曲线段相接</p></li><li><p><strong>平滑性</strong>：样条曲线在控制点处具有连续的一阶甚至高阶导数，满足特定的连续性条件</p></li><li><p><strong>范围</strong>：大多数样条曲线在控制点形成的<strong>凸壳</strong>内</p></li></ul><hr><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p><strong>连续性</strong>可以定量分析曲线的平滑程度，简单来说，满足高阶的连续性条件的曲线更加平滑</p><blockquote><p>$tips$：高阶连续性建立在底阶连续性之上，满足高阶连续性的曲线一定也满足低阶连续性</p></blockquote><h4 id="参数连续性"><a href="#参数连续性" class="headerlink" title="参数连续性"></a>参数连续性</h4><blockquote><p><strong>参数连续性</strong>条件涉及到曲线或曲面在<strong>参数空间</strong>中的连续性，通常用$C^n$来表示，其中$n$是连续性的阶数</p></blockquote><ul><li><p>$C^0$<strong>连续性</strong>：相邻分段曲线/面段在它们的公共边界上具有相同的函数值。这个是最基本的，分段连接条件</p></li><li><p>$C^1$<strong>连续性</strong>：<strong>切向量</strong>的连续性，端点处的函数一阶导数值相同</p></li><li><p>$C^2$<strong>连续性</strong>：<strong>曲率</strong>的连续性，端点处的的函数二阶导数相同</p></li></ul><h4 id="几何连续性"><a href="#几何连续性" class="headerlink" title="几何连续性"></a>几何连续性</h4><blockquote><p><strong>几何连续性</strong>条件涉及到曲线或曲面在<strong>欧几里得空间</strong>中的连续性,通常用$G^n$来表示</p></blockquote><ul><li>$G^0$<strong>连续性</strong>：等同于$C^0$连续性，即位置连续性</li></ul><p>其他的高阶几何连续性只要求相交处的<strong>参数导数成比例</strong>，这为实际运用给出了更为宽松的条件</p><hr><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>插值样条</strong>：线精确地<strong>通过</strong>每一个控制点</p></li><li><p><strong>逼近样条</strong>：曲线不必精确地通过所有数据点，但需要在某种意义上尽可能地<strong>接近</strong>控制点</p></li></ul><hr><h2 id="样条表示"><a href="#样条表示" class="headerlink" title="样条表示"></a>样条表示</h2><ul><li>假设用最高<strong>次数</strong>为$4$，定义域为$0\le u\le1$的多项式</li></ul><script type="math/tex; mode=display">P(u)=au^3+cu^2+cu+d</script><p>其中$P$为曲线上的点，$a,b,c,d$是<strong>多项式参数</strong>，需要用样条的控制点和<strong>边界条件</strong>生成</p><p>转化为矩阵表达</p><script type="math/tex; mode=display">P(u)=\left[\begin{matrix}u^3 && u^2 && u && 1\end{matrix}\right]\left[\begin{matrix}a\\\\b\\\\ c\\\\d\end{matrix}\right]</script><blockquote><p>$tips$ 这里是用的向量表达，若把$x,y$坐标拆开，需要八个边界条件，不过一般来说边界条件也是用点来表示的</p></blockquote><ul><li>假设曲线由两个控制点$P_0\ ,\ P_1$控制，这里为了方便说明，引入额外条件：曲线在控制点处的斜率$D_{P_0}\ ,\ D_{P_1}$(这条曲线满足过端点的前提) 。则有边界条件</li></ul><script type="math/tex; mode=display">\begin{align}P(0) &= P(0)\\\\P(1) &= P(1)\\\\D_{P_0} &= P^\prime(0)\\\\D_{P_1} &= P^\prime(1)\\\\\end{align}</script><p>现在就可以得到方程组</p><script type="math/tex; mode=display">\left[\begin{matrix}P_0\\\\P_1\\\\D_{P_0}\\\\D_{P_1}\end{matrix}\right]=\left[\begin{matrix}0 & 0 & 0 & 1\\\\1 & 1 & 1 & 1\\\\0 & 0 & 1 & 0\\\\3 & 2 & 1 & 0\end{matrix}\right]\left[\begin{matrix}a\\\\b\\\\c\\\\d\end{matrix}\right]</script><p>求解</p><script type="math/tex; mode=display">\left[\begin{matrix}a\\\\b\\\\c\\\\d\end{matrix}\right]=\left[\begin{matrix}2 & -2 & 1 & 1\\\\-3 & 3 & -2 & -1\\\\0 & 0 & 1 & 0\\\\1 & 0 & 0 & 0\end{matrix}\right]\left[\begin{matrix}P_0\\\\P_1\\\\D_{P_0}\\\\D_{P_1}\end{matrix}\right]</script><blockquote><p>$tips$ 这个样条就是$Hermite$插值样条</p></blockquote><p>这样就得到了$n$次多项式表达曲线的矩阵形式</p><script type="math/tex; mode=display">P(u)=U_{1,n}\cdot M_{n,n}\cdot N_{1,n}</script><blockquote><p>$tips$ 矩阵表达可以实现样条曲线的多项式函数转换</p></blockquote><p>若边界条件全部由控制点坐标位置得到，则可以转化成更为工整的形式</p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^{n}P_iBF_i(u)</script><p>其中$BF_i$一般称为<strong>基函数</strong></p><p>此处的样条边界条件使用了额外的条件（$D_{p}$），无法使用$\sum$符号，使用基函数的常见表达有<strong>贝塞尔曲线</strong></p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^{n}P_iB_n^k(u)\ ,\ 0\le u\le 1</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;样条&lt;/strong&gt;（$Spline$）在数学和图形学中指的是一种通过一系列&lt;stro</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="几何" scheme="http://example.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线</title>
    <link href="http://example.com/2024/10/27/beisier/"/>
    <id>http://example.com/2024/10/27/beisier/</id>
    <published>2024-10-27T05:24:16.000Z</published>
    <updated>2024-10-27T23:23:55.780Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="贝塞尔曲线多项式"><a href="#贝塞尔曲线多项式" class="headerlink" title="贝塞尔曲线多项式"></a>贝塞尔曲线多项式</h4><p>$n+1$个<strong>控制点</strong>序列$(P_0\ ,\ P_1\ ,\ \cdots\ ,\ P_{n})$定义的$n$次贝塞尔曲线多项式函数</p><script type="math/tex; mode=display">\begin{align}P(u) &= \sum_{i=0}^{n}P_iB_n(i\ ,\ u)\\\\B_n(i\ ,\ u) &= \bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}\end{align}</script><hr><h4 id="伯恩斯坦多项式"><a href="#伯恩斯坦多项式" class="headerlink" title="伯恩斯坦多项式"></a>伯恩斯坦多项式</h4><p><strong>伯恩斯坦多项式</strong>（Bernstein polynomial）就是贝塞尔曲线定义式中的函数</p><script type="math/tex; mode=display">B_n(i\ ,\ u)=\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}</script><p>其中$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)$为组合数$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)=\frac{n!}{i!(n-i)!}$，有递归式$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)=\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)\frac{n-k+1}{k}$</p><p>它具有以下性质</p><ul><li><strong>归一性</strong> 对于任意的$u$，有$\sum_{i=0}^{n}B_n(i\ ,\ u)=1$</li></ul><p>使用<strong>数学归纳法证明</strong></p><ul><li><p><strong>基础步骤</strong> $\bigl(\begin{smallmatrix}n\\\\ 0\end{smallmatrix}\bigr)(u)^0(1-u)^{0}=1$</p></li><li><p><strong>归纳假设</strong> 假设对于任意的$u$，有$\sum_{i=0}^{n}B_n(i\ ,\ u)=1$</p></li><li><p><strong>归纳证明</strong> 对于$n+1$的情形</p></li></ul><script type="math/tex; mode=display">\begin{align}B_{n+1}(i\ ,\ u) &= \bigl(\begin{smallmatrix}n+1\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i+1}\\\\&= \biggl(\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)+\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)\biggr)u^i(1-u)^{n-i+1}\\\\&= (1-u)\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}+u\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)u^{i-1}(1-u)^{n-i+1}\\\\&=(1-u)B_n(i\ ,\ u)+uB_n(i-1\ ,\ u)\end{align}</script><p><em>将假设代入即可证明</em></p><blockquote><p>这个性质证明了曲线上任意一点都是不同权重的控制点线性组合成</p></blockquote><ul><li><strong>非负性</strong> $B_n(i\ ,\ u)\ge 0$</li></ul><blockquote><p>这个性质进一步证明了曲线上任意一点都在控制点的<strong>凸集</strong>内（或边上）</p></blockquote><hr><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p>为了证明贝塞尔曲线由控制点定义，并通过这些点生成<strong>平滑的曲线</strong>，需要证明贝塞尔曲线多项式函数在定义域$[0\ ,\ 1]$连续</p><ul><li><p>伯恩斯坦多项式的连续性：幂函数的积连续</p></li><li><p>多项式和的连续性：求和连续</p></li><li><p>控制点的影响：常数对连续性无影响</p></li></ul><hr><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>在$n+1$个<strong>控制点</strong>序列$(P_0\ ,\ P_1\ ,\ \cdots\ ,\ P_{n})$定义的$n$次贝塞尔曲线中，将控制点定义为<strong>0阶过程点</strong>$P_i^0=P_0$</p><p>则有$k+1$阶过程点$P_i^{k+1}=(1-u)P_i^k+uP_{i+1}^k$，第$n-1$阶过程点只有一个，它对应贝塞尔曲线多项式系数为$u$生成的点</p><blockquote><p>$tips$ 这里$u$是被生成过程点到线段左端点的比例，这里的$u$和$1-u$换位了，不过不影响结果</p></blockquote><p><em>证明需要解n阶多项式方程</em></p><p>这个式子的几何意义可以理解为，使用低阶过程点和统一参数$u$的<strong>参数线段方程</strong>生成高阶过程点</p><p><img src="https://s2.loli.net/2024/10/27/JesLCygMrh3u6xK.png" alt=""></p><p>这是一条$4$个控制点生成的贝塞尔曲线图示（$u$可能有偏差），因为曲线上的点不可能超过越过线段，所有证明了<strong>凹包包围</strong></p><p>同时，$P(u)=P_0\ ,\ P(1)=P_1$<strong>曲线上的点过控制点两端</strong></p><hr><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>贝塞尔曲线是贝斯尔曲面的三维扩展，它<strong>使用一个方向的控制点作为另一个方向的控制点</strong>，这样就综合了所有控制点</p><p>在笛卡尔坐标系中，定义$n+1&gt;3$为$x$方向上的控制点个数，有$m+1&gt;3$列($y$)这样的控制点（每一列都有$n+1$个控制点，虽然没有也能做）</p><p>则曲面上的点</p><script type="math/tex; mode=display">P(u\ ,\ v)=\sum_{i=0}^{n}\sum_{j=0}^{m}P_{ij}B_n(i\ ,\ u)B_m(j\ ,\ v)</script><p>其中$0\le u\le 1\ ,\ 0\le v\le 1\ ,\ P_{ij}$为坐标系中第$i$第$j$个元素</p><blockquote><p>$tips$ 这里把点放在二维坐标系中只是为了定义他们的相对顺序（空间序列），这对去曲线生成有影响，实际上控制点都是在三维空间的</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;贝塞尔曲线多项式&quot;&gt;&lt;a href=&quot;#贝塞尔曲线多项式&quot; class=&quot;headerlink&quot; title=&quot;贝塞尔曲线多项式&quot;&gt;&lt;/a&gt;贝塞尔曲线多项式&lt;/h4&gt;&lt;p&gt;$n+1$个&lt;strong&gt;控制点&lt;/strong&gt;序列$(P_0&#92; ,&#92; P_1</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="几何" scheme="http://example.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ST表</title>
    <link href="http://example.com/2024/10/26/ST-table/"/>
    <id>http://example.com/2024/10/26/ST-table/</id>
    <published>2024-10-26T13:44:03.000Z</published>
    <updated>2024-10-27T23:20:01.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>$tips$ $ST$表是一个离线的算法，他不止能做RMQ问题，比如序列$gcd$</p></blockquote><p>定义运算元素集$(a\ ,\ b\ ,\ c\ ,\ \cdots)$在其上的运算$*$存在以下性质</p><ul><li><p>$(a<em>a)^n\ ,\ n\ge1$，<em>*可重复贡献</em></em></p></li><li><p>$a<em>b=b</em>a$，满足<strong>交换律</strong></p></li></ul><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>定义运算元素序列$nums=(a_1\ ,\ a_2\ ,\ \cdots\ ,\ a_{n-1})$和运算符$DP$和$F$（这里使用两种符号是因为接下来要递归分析）</p><p>$DP$作用于区间，表示为$DP[i\ ,\ j]$，代表着对序列$nums$区间$[i\ ,\ i+2^j-1]$内的元素至少做一次运算$DP$后产生的结果</p><p>特别的，当$DP$作用于两个元素时，使用符号$F(a\ ,\ b)$区分</p><p>则有递归式</p><ul><li><p>$DP[i\ ,\ j]=F(DP[i][j-1]\ ,\ DP[i+2^{j-1}][j-1])$</p></li><li><p>基准情况$F(a\ ,\ a)$视运算规则</p></li></ul><p><em>把上面的区间规则代入就能证明</em></p><h4 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h4><p>因为$i\ ,\ j$都是正整数，储存$DP$后就能快速查找长度为$2^j$的序列$F$运算结果</p><p>想要查询<strong>任意长度</strong>，需要再次利用可重复贡献的规则，若查询的序列区间为$[L\ ,\ R]$，将它表示为两个区间的组合，当然，中间可能会产生重叠</p><ul><li>使用区间长度计算$j$，$R-L+1=2^j\to j=\log_2(R-L+1)$</li></ul><p>这里不能保证$j$为整数（能保证也就没有说明的必要了），使用取整后的结果$j^\prime=\lfloor\log_2(R-L+1)\rfloor$，之后将会证明两个区间不会有间隙</p><ul><li><p>左区间为$L$，那么左区间的运算结果为$DP[L][j^\prime]$，右区间的右端点为$R$，那么右区间的左端点为$R-j^\prime+1$，右区间的运算结果为$DP[R-j^\prime+1][j^\prime]$</p></li><li><p>综上所叙$F(ange_{nums}[L,R])=F(DP[L][j^\prime]\ ,\ DP[R-j^\prime+1][j^\prime])$，其中$j^\prime=\lfloor\log_2(R-L+1)\rfloor$</p></li></ul><p>要证明没有漏元素，只需要证明<strong>左区间的右端点不在右区间左端点的左边</strong></p><p>即</p><script type="math/tex; mode=display">R-j^\prime+1>L+2^{j\prime}-1\to R\ge L</script><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>实现中，元素为$int$，运算规则为$max$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Log2;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; DP;</span><br><span class="line"><span class="built_in">ST</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) :<span class="built_in">n</span>(nums.<span class="built_in">size</span>()), <span class="built_in">Log2</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>), <span class="built_in">DP</span>(nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">Log2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">Log2[i] = Log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">DP[i].<span class="built_in">resize</span>(Log2[n - i] + <span class="number">1</span>);</span><br><span class="line">DP[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Log2[n]; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="built_in">pow</span>(<span class="number">2</span>, j); ++i)</span><br><span class="line">DP[i][j] = <span class="built_in">max</span>(DP[i][j - <span class="number">1</span>], DP[i + <span class="built_in">pow</span>(<span class="number">2</span>, j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Q</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> j = Log2[right - left + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(DP[left][j], DP[right - <span class="built_in">pow</span>(<span class="number">2</span>, j) + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;$tips$ $ST$表是一个离线的算法，他不止能做RMQ问题，比如序列$gcd$&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="RMQ" scheme="http://example.com/tags/RMQ/"/>
    
  </entry>
  
  <entry>
    <title>线性插值</title>
    <link href="http://example.com/2024/10/25/Linear-Interpolation/"/>
    <id>http://example.com/2024/10/25/Linear-Interpolation/</id>
    <published>2024-10-25T04:35:35.000Z</published>
    <updated>2024-10-27T23:29:50.311Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="插值方法"><a href="#插值方法" class="headerlink" title="插值方法"></a>插值方法</h3><blockquote><p>插值方法是一类数学工具，用于估计函数在未知点上的值，基于该函数在已知点上的值。简单来说，插值就是在一系列离散的数据点之间找到一条连续的曲线或函数，使得这条曲线或函数能够尽可能地反映数据的特征</p></blockquote><p>简单来说，<strong>插值</strong>操作就是利用函数和已知点<strong>算</strong>出未知点，在计算机图形学中，常常会出现采样数据不够的情况，通过<strong>插值</strong>预估出样点，达到<strong>反走样</strong>的效果</p><h3 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h3><blockquote><p><strong>线性插值</strong>假设在两个已知点之间，<strong>变量的变化率是恒定的</strong>，因此可以用一条直线来近似这两个点之间的值</p></blockquote><p>在计算机图形学中，有些变化率即使不是恒定的，通常是<strong>复杂的</strong>，也会在使用<strong>线性插值</strong>，比如<strong>插值法线，颜色值</strong></p><p><strong>多项式（样条）</strong>插值主要用来生成<strong>曲线</strong></p><hr><h3 id="线性插值算法"><a href="#线性插值算法" class="headerlink" title="线性插值算法"></a>线性插值算法</h3><h3 id="使用方向"><a href="#使用方向" class="headerlink" title="使用方向"></a>使用方向</h3><p>定义线段上两个端点$A\ ,\ B$，线段上点可以表示为</p><script type="math/tex; mode=display">P(s)=A+s(B-A)</script><p>其中$0\le s\le 1\ ,\ s=\frac{\vert P(s)A\vert}{\vert AB\vert}$</p><p>假设现在要插值点$P$的一个<strong>颜色属性</strong>$Light_P$，使用附近的点$A\ ,\ B$来生成，（虽然现在已经可以利用位置算出所需参数，但是在计算机图形学中，要插值的点不是随便取的，通常会插值<strong>连续间隔点</strong>）和参数$s$</p><p>则</p><script type="math/tex; mode=display">Light_p=(1-s)Light_A+sLight_B</script><p>在<strong>三维空间</strong>中，通常使用<strong>重心坐标系</strong>，使用三角形顶点$ABC$，为三角形内部的点$P$插值</p><script type="math/tex; mode=display">P(\alpha\ ,\ \beta\ ,\ \gamma)=\alpha A+\beta B+\gamma C</script><hr><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><blockquote><p>在接下来的讨论中，使用<strong>参考点</strong>来描述上述的点$A\ ,\ B$或三角形$ABC$，他们决定了插值出的属性优劣</p></blockquote><p>使用光照模型模型时，可能会使用<strong>顶点法线</strong>插值内部点的法线属性，这时参考点就是插值点所在的三角形顶点</p><blockquote><p>$tips$ 顶点法线可能通过模型提供，也可能使用周围平面法线加权平均获得</p></blockquote><p>要获得<strong>纹理图</strong>中的属性$Attribute$（可能是颜色值，也可能是法线）只有<strong>显示器像素正好映射在纹理像素正中心</strong>，即整数坐标时，属性才是已知的，在<a href="https://amy-oo1.github.io/2024/10/24/basic-Texture-Mapping/">之前</a>，使用了简单的舍入</p><p>而双线性插值充分考虑映射点最近的四个像素，通过这四个参考点插值出映射点的纹理属性</p><p>若某个表面像素持有纹理坐标$(u\ ,\ v)$，对应纹理图大小为$(W\times H)$，则表面像素映射在纹理图上的点为</p><script type="math/tex; mode=display">P=(uW,vH)</script><p>（参考点）最近的四个点的坐标为</p><script type="math/tex; mode=display">\begin{align}LB &= (\lfloor uW\rfloor\ ,\ \lfloor vH\rfloor)\\\\RB &= (\lceil uW\rceil\ ,\ \lfloor vH\rfloor)\\\\LT &= (\lfloor uW\rfloor\ ,\ \lceil vH\rceil)\\\\LT &= (\lceil uW\rceil\ ,\ \lceil vH\rceil)\\\\\end{align}</script><blockquote><p>$tips$ 不考虑边界处理，在贴图的边界缝处理还需要别的技术支持</p></blockquote><p><img src="https://s2.loli.net/2024/10/25/xCENedpZbMOm8VU.png" alt=""></p><blockquote><p>后面的计算结果或证明插值的顺序没有影响，即可以先使用竖着的两条线段插值</p></blockquote><p>若先使用$(LB\ ,\ RB)$和$(LT\ ,\ RT)$分别插值出$Attribute_A\ ,\ Attribute_B$，则有</p><script type="math/tex; mode=display">\begin{align}Attribute_A &= (1-s_U)Attribute_{LB}+s_UAAttribute_{RB}\\\\Attribute_B &= (1-s_U)Attribute_{LT}+s_UAAttribute_{RT}\\\\Attribute_P &= (1-s_V)Attribute_{A}+s_VAAttribute_{B}\\\\\end{align}</script><p>其中</p><script type="math/tex; mode=display">\begin{align}s_U &= uW-\lfloor uW\rfloor\\\\s_V &= vH-\lfloor vH\rfloor\end{align}</script><blockquote><p>$tips$ 因为纹理图像上的像素都在整数坐标上，因此可以截断小数轻松获得参数$s$</p></blockquote><p>整合可得</p><script type="math/tex; mode=display">\begin{align}A_P &=(1-s_V)(1-s_U)A_{LB}\\\\&= (1-s_V)s_UA_{RB}\\\\\&= s_V(1-s_U)A_{LT}\\\\\&= s_Vs_UA_{RT}\end{align}</script><blockquote><p>$tips$ 这个式子对正好处于图像像素中心或者图像像素中心连线的点依然有效</p></blockquote><hr><h4 id="埃尔米特插值"><a href="#埃尔米特插值" class="headerlink" title="埃尔米特插值"></a>埃尔米特插值</h4><p>二次线性插值处理后的图像可能会产生模糊，埃尔米特插值（Hermite interpolation）是一种多项式插值方法，若使用这种技术处理纹理，只需要以下改变</p><p>用$s_U\prime$和$s_V\prime$替换$s_U$和$S_V$，其中</p><script type="math/tex; mode=display">\begin{align}s_U\prime &= 3(s_U)^2-2(s_U)^3\\\\s_V\prime &= 3(s_V)^2-2(s_V)^3\end{align}</script><hr><h3 id="三维纹理上的插值"><a href="#三维纹理上的插值" class="headerlink" title="三维纹理上的插值"></a>三维纹理上的插值</h3><p>双线性插值可以推广到三维纹理上，只需要增加两个$Z$方向上的参考点</p><hr><h2 id="透视矫正插值"><a href="#透视矫正插值" class="headerlink" title="透视矫正插值"></a>透视矫正插值</h2><p>若要对一个表面进行插值纹理属性，那么表面一定经过了投影变换这一步骤，否则我们不可能知道表明对应的显示像素，也无法将他们映射到纹理上</p><p>接下来的分析会从数学角度出发奇次项坐标放缩对插值的影响</p><p>设投影前的三角形$ABC$和经过变换$M$后得到三角形$A^\prime B^\prime C^\prime $，则有三角形内的一点</p><script type="math/tex; mode=display">\begin{align}P &= \alpha A+\beta B+\gamma C\\\\P^\prime &= \alpha^\prime A^\prime+\beta^\prime B^\prime+\gamma^\prime C^\prime\\\\\end{align}</script><p>其中</p><script type="math/tex; mode=display">1=\alpha +\beta +\gamma</script><blockquote><p>$tips$ 变换后的系数不能得到这个结论，因为假定变换会对插值产生影响</p></blockquote><p>设变换后齐次项坐标系数为$W\ ,\ W\ne 0$，则有</p><script type="math/tex; mode=display">\left[\begin{matrix}A^\prime W_a\\\\W_a\end{matrix}\right]=M\left[\begin{matrix}A\\\\1\end{matrix}\right]</script><script type="math/tex; mode=display">\left[\begin{matrix}B^\prime W_b\\\\W_b\end{matrix}\right]=M\left[\begin{matrix}B\\\\1\end{matrix}\right]</script><script type="math/tex; mode=display">\left[\begin{matrix}C^\prime W_b\\\\W_c\end{matrix}\right]=M\left[\begin{matrix}C\\\\1\end{matrix}\right]</script><script type="math/tex; mode=display">\left[\begin{matrix}P^\prime W_b\\\\W_p\end{matrix}\right]=M\left[\begin{matrix}P\\\\1\end{matrix}\right]</script><p>将非齐次项坐标替换为奇次项坐标</p><script type="math/tex; mode=display">\begin{align}\bigl( \begin{smallmatrix} P \\ 1 \end{smallmatrix} \bigr) &= \alpha\bigl( \begin{smallmatrix} A \\ 1 \end{smallmatrix} \bigr)+\beta\bigl( \begin{smallmatrix} B \\ 1 \end{smallmatrix} \bigr)+\gamma\bigl( \begin{smallmatrix} C \\ 1 \end{smallmatrix} \bigr)\\\\M\bigl( \begin{smallmatrix} P \\ 1 \end{smallmatrix} \bigr)&= M\alpha\bigl( \begin{smallmatrix} A \\ 1 \end{smallmatrix} \bigr)+M\beta\bigl( \begin{smallmatrix} B \\ 1 \end{smallmatrix} \bigr)+M\gamma\bigl( \begin{smallmatrix} C \\ 1 \end{smallmatrix} \bigr)\end{align}</script><p>带入$M$的表达式</p><script type="math/tex; mode=display">\begin{align}P^\prime W_p &= \alpha A^\prime W_a+\beta B^\prime W_b+\gamma C^\prime W_c\\\\W_p &= \alpha W_a+\beta W_b+\gamma W_c\\\\\end{align}</script><p>联立得</p><script type="math/tex; mode=display">\begin{align}P^\prime &= \frac{\alpha A^\prime W_a+\beta B^\prime W_b+\gamma C^\prime W_c}{\alpha W_a+\beta W_b+\gamma W_c}\\\\&= A^\prime\frac{\alpha W_a}{\alpha W_a+\beta W_b+\gamma W_c}+B^\prime\frac{\beta W_b}{\alpha W_a+\beta W_b+\gamma W_c}+C^\prime\frac{\gamma W_c}{\alpha W_a+\beta W_b+\gamma W_c}\end{align}</script><p>代入表达式</p><script type="math/tex; mode=display">P^\prime = \alpha^\prime A^\prime+\beta^\prime B^\prime+\gamma^\prime C^\prime</script><p>可得</p><script type="math/tex; mode=display">\begin{align}\alpha^\prime &= \frac{\alpha W_a}{\alpha W_a+\beta W_b+\gamma W_c}\\\\\beta^\prime &=\frac{\beta W_b}{\alpha W_a+\beta W_b+\gamma W_c}\\\\\gamma^\prime &=\frac{\gamma W_c}{\alpha W_a+\beta W_b+\gamma W_c}\end{align}</script><p>为了使用$1=\alpha +\beta +\gamma$这个式子，需要提取变换前的系数，但是分母可以不做改动，最后统一放在等式另一边</p><script type="math/tex; mode=display">\begin{align}\alpha &= \frac{\alpha^\prime}{W_a(\alpha W_a+\beta W_b+\gamma W_c)}\\\\\beta &=\frac{\beta^\prime}{W_b(\alpha W_a+\beta W_b+\gamma W_c)}\\\\\gamma &=\frac{\gamma^\prime}{W_c(\alpha W_a+\beta W_b+\gamma W_c)}\\\\\alpha W_a+\beta W_b+\gamma W_c &=\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}+\frac{\gamma^\prime}{W_c}\end{align}</script><p>最后这个式子是之前重心坐标系系数关系式子的分母，代入后就可以从$\alpha\to\alpha^\prime\ or\ \alpha^\prime\to\alpha$</p><p>到这里可以证明<strong>透视</strong>变换会对插值产生影响，如果想要在透视后的空间做插值，需要$\alpha^\prime \to\alpha$的表达式，即</p><script type="math/tex; mode=display">\begin{align}\alpha &= \frac{\frac{\alpha^\prime}{W_a}}{\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}+\frac{\gamma^\prime}{W_c}}\\\\\beta &=\frac{\frac{\beta^\prime}{W_b}}{\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}+\frac{\gamma^\prime}{W_c}}\\\\\gamma &=\frac{\frac{\gamma^\prime}{W_c}}{\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}+\frac{\gamma^\prime}{W_c}}\end{align}</script><p>这个式子有一定规律，如果将二维的线性插值进行一点变换</p><script type="math/tex; mode=display">\begin{align}P &=B+\alpha (A-B)\\\\P &=\alpha A+(1-\alpha)B\\\\P &=\alpha A+\beta B\end{align}</script><p>其中$\alpha+\beta =1$，可得</p><script type="math/tex; mode=display">\begin{align}\alpha &=\frac{\frac{\alpha^\prime}{W_a}}{\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}}\\\\\beta &=\frac{\frac{\beta^\prime}{W_b}}{\frac{\alpha^\prime}{W_a}+\frac{\beta^\prime}{W_b}}\end{align}</script><blockquote><p>$tips$ 透视纠正插值会存在精度问题，能在透视前插值就尽量插值而不要在透视后插值</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;插值方法&quot;&gt;&lt;a href=&quot;#插值方法&quot; class=&quot;headerlink&quot; title=&quot;插值方法&quot;&gt;&lt;/a&gt;插值方法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;插值方法是一类数学工具，用于估计函数在未知点上的值，基于该函数在已知点上的值。简单来说，</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>基本的纹理映射</title>
    <link href="http://example.com/2024/10/24/basic-Texture-Mapping/"/>
    <id>http://example.com/2024/10/24/basic-Texture-Mapping/</id>
    <published>2024-10-24T13:40:33.000Z</published>
    <updated>2024-10-25T14:22:15.525Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="纹理映射的需求"><a href="#纹理映射的需求" class="headerlink" title="纹理映射的需求"></a>纹理映射的需求</h3><p>之前用<strong>局部光照</strong>的经验模型模拟光照效果，因为对光线（全局光照）的计算耗费资源巨大</p><p>而绝大部分<strong>物体表面的反射率变化快</strong>，视觉表现为颜色艳丽丰富，这也是有巨大复杂性的问题，而<strong>纹理映射使用纹理图像或函数改变物体的外观</strong></p><blockquote><p>$tips$ 这里仅考虑使用纹理图像的纹理映射</p></blockquote><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p><strong>纹理（图像）</strong> 通常指二维矩形图像，这里使用<strong>分辨率</strong>$(w,h)$这一属性，即每行每列的像素数量</p></li><li><p><strong>纹理坐标（UV Coordinates）</strong> 是在三维模型表面上指定纹理图像如何贴合的坐标系统。U和V通常是介于0和1之间的参数，代表纹理图像的横纵比例位置。</p></li><li><p>$UV$坐标系统：</p><ul><li>$U$轴：通常表示纹理图像的水平方向，类似于二维坐标系统中的X轴。</li><li>$V$轴：通常表示纹理图像的垂直方向，类似于二维坐标系统中的Y轴。</li></ul></li></ul><p>有些表面展开不是矩阵，或者不能<strong>等比例</strong>展开为二维图像，<strong>UV坐标系统</strong>就是纹理图像和三表面的中介，产生</p><ul><li><strong>变形与扭曲</strong>：UV坐标的设置可以影响纹理在模型上的拉伸和扭曲程度。合理的UV布局可以避免不自然的变形，而不恰当的UV布局可能导致纹理看起来很不自然。</li></ul><p>并且，$UV$坐标系统及其<strong>标准化</strong>的引入，可以方便的<strong>更换纹理图像</strong>，不用更改每一个顶点</p><hr><h3 id="纹理坐标的使用"><a href="#纹理坐标的使用" class="headerlink" title="纹理坐标的使用"></a>纹理坐标的使用</h3><p>简单来讲，每个表面顶点会在模型中绑定一个$UV$坐标（有可能会大于1，这时可以截断获得一个表面映射多个同一个纹理来铺满表面的效果），这里只考虑$U&lt;0\ ,\ V&lt;0$，如果不使用插值算法</p><p>则若一个表面被纹理$A(W,H)$映射，表面上一个顶点$P$绑定的纹理坐标为$(u\ ,\ v)$，则顶点$P$在映射到屏幕上的像素获得的<strong>纹理分量</strong>为</p><script type="math/tex; mode=display">A(\lfloor uW\rfloor \ , \lfloor vH\rfloor)</script><blockquote><p>$tips$ 纹理图可能储存的是某个颜色模型值，比如$RGBA$</p></blockquote><hr><h3 id="映射问题"><a href="#映射问题" class="headerlink" title="映射问题"></a>映射问题</h3><p>$uW$和$vH$将<strong>显示器像素</strong>绑定到纹理图上一<strong>点</strong>，上面的方法只是使用了<strong>取整偏移到具体图像像素</strong></p><blockquote><p>$tips$ 一下像素分辨率都是相对于显示器分辨率而言的</p></blockquote><ul><li>如果<strong>图像分辨率太低</strong>，那么会有<strong>多个显示器像素落在同一个图像像素矩形内</strong>,生成的图像会产生<strong>锯齿</strong></li></ul><p>而这些<strong>显示器像素点在图像像素矩形内仍旧有位置区别</strong>，<strong>线性插值</strong>利用这个信息，考虑周围的<strong>图像像素</strong>矩形，每个<strong>图像像素点</strong>赋予显示器像素一个颜色权重，这个权重和<strong>距离</strong>有关</p><ul><li>图像<strong>分辨率过高也会有问题</strong>，这时相邻的显示器像素会映射到较远的图像像素，生成的图像会产生<strong>摩尔纹</strong></li></ul><p>这个问题会在<strong>表面距离投影面</strong>很远时发生，这时表面只能用少量的像素点显示</p><hr><h3 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h3><p>这里简单介绍一些纹理映射相关的算法：</p><blockquote><p>$Mipmap$（多级渐远纹理）通过<strong>预先存储一系列递减分辨率的纹理图像</strong>,每一级Mipmap都是前一级纹理大小的一半，形成一个纹理图像的层级结</p><p>各向异性过滤（Anisotropic Filtering）是一种高级的纹理采样技术，用于在三维图形渲染中提高纹理在不同角度和距离下的清晰度  </p><p>在三维空间中，一个纹理映射到三维模型上时，由于视角和观察距离的变化，纹理在屏幕上的投影可能会呈现不同的形状和大小。当纹理不是正对着摄像机时（即斜视角观察），纹理的线性过滤和Mipmap技术可能会产生模糊效果，因为它们假设纹理在所有方向上的分辨率降低是一致的</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;纹理映射的需求&quot;&gt;&lt;a href=&quot;#纹理映射的需求&quot; class=&quot;headerlink&quot; title=&quot;纹理映射的需求&quot;&gt;&lt;/a&gt;纹理映射的需求&lt;/h3&gt;&lt;p&gt;之前用&lt;strong&gt;局部光照&lt;/strong&gt;的经验模型模拟光照效果，因为对光线（全局光</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>分割多边形</title>
    <link href="http://example.com/2024/10/23/Polyon-Partion/"/>
    <id>http://example.com/2024/10/23/Polyon-Partion/</id>
    <published>2024-10-23T08:16:33.000Z</published>
    <updated>2024-10-24T04:27:02.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$tips_1$ 此处的多边形的边之间无交叉，即<strong>简单多边形</strong></p><p>$tips_2$ 输入为多边形的所有顶点，输入相邻的点构连边，特别的，首尾输入顶点也连边</p><p>$tips_3$ 假设点逆时针排序</p></blockquote><hr><h4 id="识别凹多边形"><a href="#识别凹多边形" class="headerlink" title="识别凹多边形"></a>识别凹多边形</h4><p>凸多边形的任意<strong>内角</strong>（相邻边形成的，多边形边界内的角）<strong>均小于</strong>$180^\circ$，可以用<strong>叉积</strong>检测凹多边形</p><hr><h3 id="分解凹多边形"><a href="#分解凹多边形" class="headerlink" title="分解凹多边形"></a>分解凹多边形</h3><p>$tips_1$ 分解凹多边形的算法有<strong>全局刨分</strong>和<strong>局部刨分</strong>，此处的算法是局部刨分，这一类算法拆分出的效果通常没有全局刨分优秀，而最基本的算法会给出几乎最差的多边形数量，还可能产生相对<strong>极小的三角形</strong>，如果精度不够，会直接<strong>退化</strong>为线段或点</p><p>$tips_2$ 给定简单多边形，拆分为最少数量的凸多边形算法不是<em>N-P</em>问题</p><hr><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><blockquote><p>一个顶点形成凹角：顶点处两条邻边的内角和$\le 180^\circ$，不考虑多边形存在<strong>退化</strong>，即三个相邻顶点共线</p></blockquote><p>算法<strong>顺序（逆时针）</strong>遍历所有顶点，若当前顶点形成<strong>凹角</strong>，从左<strong>邻点到凹点连一条射线</strong>，射线最先遇到的点<strong>（切割点）</strong>和凹点组成的<strong>切割线</strong>，将多边形拆分为两个 （<strong>切割边逆时针方向为左多边形</strong>），对产生的多边形<strong>递归</strong>处理</p><blockquote><p>基准条件是隐性的，即顺序遍历找不到<strong>凹角</strong></p></blockquote><hr><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>因为射线是从多边形内部打出，所有它一定会遇到多边形的边界，而凹点右邻点在<strong>切割边右侧</strong>，一定在右多边形中，右多边形没有退化</p><p>算法每一个分割<strong>一定会消去一个凹点</strong></p><ul><li><p>原本的<strong>凹点（公共点）不会再次形成凹点</strong>，它在左多边形中<strong>退化</strong>，右多边形中，凹点新的右邻点不会在切割边左侧，所以不会产生新的凹点</p></li><li><p>切割点不会从<strong>凸点转化为凹点</strong>，</p><ul><li>若切割点打在原本的顶点上，切割线一定在它领边中间，而不会是邻边的一侧，这是<strong>射线从内部发出，达到的第一个点</strong>决定的，这样，它就不会增大内角，形成新的凹角</li><li>若切割点打到边上，被切割开的两条边分别和切割边形成角，一定不会$&gt; 180^\circ$</li></ul></li></ul><p>至此，有$N$个凹点的多边形会在最多$N$次分割后成为多个凸多边形，因为一个$N$边形最后有$N-2$个凹角，所以时间复杂度</p><script type="math/tex; mode=display">Max\ O((N-2)*N)=O(N^2)</script><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="built_in">Vec2</span>(<span class="type">double</span> a, <span class="type">double</span> b) :<span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>==(Point P) &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x == P.x &amp;&amp; <span class="keyword">this</span>-&gt;y == P.y; &#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(Point S) &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>(<span class="keyword">this</span>-&gt;x - S.x, <span class="keyword">this</span>-&gt;y - S.y); &#125;</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="built_in">Edge</span>(Point S, Point T) :<span class="built_in">S</span>(S), <span class="built_in">T</span>(T) &#123;&#125;</span><br><span class="line">Point S, T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Det_Vec2</span><span class="params">(Vec2 A, Vec2 B)</span> </span>&#123; <span class="keyword">return</span> A.a * B.b - A.b * B.a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Explode_concave_polygons</span><span class="params">(vector&lt;Point&gt; P)</span>-&gt; vector&lt;vector&lt;Point&gt;&gt; </span>&#123;</span><br><span class="line"><span class="type">int</span> N = P.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//特判三角</span></span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; Left_P, Right_P;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; ans;</span><br><span class="line"><span class="comment">//寻找凹角</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="type">int</span> left = (i - <span class="number">1</span> + N) % N, right = (i + <span class="number">1</span>) % N;</span><br><span class="line"><span class="comment">//找到凹点并重组</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Det_Vec2</span>(P[i] - P[left], P[right] - P[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找切割点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = right; j &lt; N; j = (j + <span class="number">1</span>) % N) &#123;</span><br><span class="line"><span class="comment">//线段</span></span><br><span class="line">Point A = P[j], B = P[(j + <span class="number">1</span>) % N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//射线</span></span><br><span class="line">Vec2 d = P[i] - P[left];</span><br><span class="line"></span><br><span class="line"><span class="comment">//克莱姆法则解线性方程组</span></span><br><span class="line"><span class="type">double</span> C_Det_A = <span class="built_in">Det_Vec2</span>(d, <span class="built_in">Vec2</span>(B - A));</span><br><span class="line">Vec2 C_B = A - P[i];</span><br><span class="line"><span class="keyword">if</span> (C_Det_A == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断解</span></span><br><span class="line"><span class="type">double</span> s = <span class="built_in">Det_Vec2</span>(C_B, <span class="built_in">Vec2</span>(B - A)) / C_Det_A;</span><br><span class="line"><span class="type">double</span> t = <span class="built_in">Det_Vec2</span>(d, C_B) / C_Det_A;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span> || t &lt; <span class="number">0</span> || t&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割，可能会出现精度问题</span></span><br><span class="line"><span class="function">Point <span class="title">T</span><span class="params">(P[i].x + t * d.a, P[i].y + t * d.b)</span></span>;</span><br><span class="line">Left_P.<span class="built_in">assign</span>(P.<span class="built_in">begin</span>() + i, P.<span class="built_in">begin</span>() + j - i + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (T != A)</span><br><span class="line">Left_P.<span class="built_in">emplace_back</span>(T);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; j; j = (j - <span class="number">1</span> + <span class="number">1</span>) % N)</span><br><span class="line">Right_P.<span class="built_in">emplace_back</span>(P[k]);</span><br><span class="line"><span class="keyword">if</span> (T != B)</span><br><span class="line">Right_P.<span class="built_in">emplace_back</span>(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否重组</span></span><br><span class="line"><span class="keyword">if</span> (!Left_P.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回</span></span><br><span class="line"><span class="keyword">if</span> (!Left_P.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">ans.<span class="built_in">emplace_back</span>(<span class="built_in">Explode_concave_polygons</span>(Left_P));</span><br><span class="line">ans.<span class="built_in">emplace_back</span>(<span class="built_in">Explode_concave_polygons</span>(Right_P));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans.<span class="built_in">emplace_back</span>(P);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="分解为三角形"><a href="#分解为三角形" class="headerlink" title="分解为三角形"></a>分解为三角形</h4><p>顺序遍历<strong>凸多边形</strong>顶点，每间隔一个顶点就将之标记，最后将相邻标记的顶点连接，并和他们之间唯一一个未标记的顶点组成三角形，递归进行至多边形的顶点只有3个</p><p><strong>凸边形</strong>保证每<strong>条连接边都在多边形内部</strong>，保证切割出的三角形不会有多边形之外的部分</p><p>凸边形每切割出一个三角形就少一个顶点，所有算法一定能够终止，时间复杂度为$O(N)$，其中，$n$为凸多边形顶点数目</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;$tips_1$ 此处的多边形的边之间无交叉，即&lt;strong&gt;简单多边形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$tips_2$ 输入为多边形的所有顶点，输入相邻的点构连边，特别的，首尾输入顶点也连边&lt;/p&gt;
&lt;p&gt;$tips_3$ 假设点逆时针排序&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="计算几何" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>基本的光线追踪算法[2]</title>
    <link href="http://example.com/2024/10/22/Ray-Tracing-principe-2/"/>
    <id>http://example.com/2024/10/22/Ray-Tracing-principe-2/</id>
    <published>2024-10-22T04:38:20.000Z</published>
    <updated>2024-10-23T08:10:38.704Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="光线追踪的时间复杂度"><a href="#光线追踪的时间复杂度" class="headerlink" title="光线追踪的时间复杂度"></a>光线追踪的时间复杂度</h4><p>考虑在大小为$(W,H)$的<strong>显示设备</strong>，采样距离为每个<strong>像素</strong>，<strong>光线追踪树最大深度d</strong>前提下运行<strong>光线追踪算法</strong>，若<strong>场景</strong>中有$N个<strong>表面对象</strong>，则<strong>最坏</strong>时间复杂度为</p><script type="math/tex; mode=display">max\ O(WH(2^d+1)N)</script><blockquote><p>$tips_1$ <strong>光线追踪树</strong>:每个节点是<strong>光线对象</strong>，子节点是<strong>反射</strong>和<strong>透射</strong>现象产生的光线</p></blockquote><p>这里考虑最坏的<strong>满二叉树</strong>，即一颗深度为<strong>d</strong>的满二叉树有$2^d+1$个节点，因此，复杂度中，分量$WHD(2^d+1)$是总的光线数量</p><p>实际情况下，光线强度<strong>损耗</strong>到一定程度就可以终止，所有只有处理大量<strong>光滑表面</strong>的场景中有近似复杂度</p><p>而整个算法需要在算法的每一帧运行，对于<strong>场景复杂</strong>的渲染开销巨大</p><hr><h3 id="次线性相交判定"><a href="#次线性相交判定" class="headerlink" title="次线性相交判定"></a>次线性相交判定</h3><p>这种技术可以<strong>包围盒</strong>减少复杂度中的$N$值，即<strong>光线和场景表面</strong>的判定。该方法的原理是场景表面呈现聚集式分步，可以通过判定整块区域避免不必要的判定。</p><p>主要有以下两种形式</p><ul><li><strong>表面包围盒</strong>：递归地将当前表面用<strong>包围盒</strong>划分，在同一<strong>层次中</strong>，任意表面只属于当前层次的一个包围盒</li><li><strong>空间包围盒</strong>：递归地将当前空间<strong>切割</strong>，同一层次表面可能同时在多个空间中</li></ul><p>让光线和包围盒做相交判定,若相交则判定所以子节点，将这一过程递归至底和<strong>叶节点</strong>内所有表明做相交测试</p><hr><h3 id="其他效果"><a href="#其他效果" class="headerlink" title="其他效果"></a>其他效果</h3><p>相比光栅化，光线追踪能获得更好的模拟<strong>阴影</strong>效果，能够模拟相机的聚焦效果</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;光线追踪的时间复杂度&quot;&gt;&lt;a href=&quot;#光线追踪的时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;光线追踪的时间复杂度&quot;&gt;&lt;/a&gt;光线追踪的时间复杂度&lt;/h4&gt;&lt;p&gt;考虑在大小为$(W,H)$的&lt;strong&gt;显示设备&lt;/stron</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Ray-Tracing" scheme="http://example.com/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>基本的光线追踪算法[1]</title>
    <link href="http://example.com/2024/10/21/Ray-Tracing-principle-1/"/>
    <id>http://example.com/2024/10/21/Ray-Tracing-principle-1/</id>
    <published>2024-10-21T12:03:37.000Z</published>
    <updated>2024-10-22T16:29:10.185Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="光线追踪的特点"><a href="#光线追踪的特点" class="headerlink" title="光线追踪的特点"></a>光线追踪的特点</h4><blockquote><p>光线追踪（Ray Tracing）是一种图像渲染技术，它通过<strong>模拟光线的传播路径</strong>来生成逼真的图像</p></blockquote><p><strong>光线追踪</strong>由以下步骤组成</p><ol><li><strong>光线发射</strong>：从<strong>视点发射出无数条光线</strong>，穿过虚拟场景。</li><li><strong>光线交点计算</strong>：计算这些光线与场景中物体的<strong>交点</strong>。</li><li><strong>着色计算</strong>：在交点处根据物体的材质、光源信息以及周围环境进行着色。</li><li><strong>反射与折射</strong>：在交点处可能发生光线<strong>反射和折射</strong>，这时需要继续追踪反射和折射光线。</li><li><strong>图像合成</strong>：将所有光线的着色结果<strong>合成</strong>，形成最终的图像</li></ol><p><strong>光栅化</strong>由以下步骤组成</p><ol><li><strong>投影变换</strong>：将$3D$模型投影到$2D$裁剪空间。</li><li><strong>三角形遍历和绘制</strong>：分解三角形并确定覆盖的像素。</li><li><strong>片段处理</strong>：对像素进行着色，包括纹理、光照、阴影和颜色混合。</li><li><strong>输出合并</strong>：将像素信息写入帧缓冲区，完成图像合成。</li></ol><hr><p>这两种<strong>渲染</strong>方法<strong>共同特点</strong></p><ul><li><strong>矩阵变换</strong>：都需要对模型进行<strong>模型变换</strong>和<strong>视图变换</strong></li><li><strong>图像合成</strong>：主要是像素之间的<strong>连续</strong></li></ul><p><strong>差异</strong></p><ul><li>线追踪不需要<strong>投影变换</strong>，它通过调整<strong>光线束结构</strong>模拟透视的效果</li><li>光线追踪根据<strong>光路</strong>上的物体计算<strong>颜色强度贡献</strong>，光栅化根据<strong>深度缓存</strong>计算颜色强度贡献</li><li><strong>光照模型</strong>的不同<ul><li>光栅化采用<strong>局部光照</strong>：只考虑<strong>从光源直接射向对象</strong>的光和对象的化学性质，使用<strong>经验模型</strong>补偿</li><li>光线追踪在理论上使用<strong>全局光照</strong>：除了光源直接照向对象的光，还考虑因<strong>折射，反射</strong>产生的，<strong>间接从象照向对象的光</strong></li></ul></li><li>光线追踪计算大，效果<strong>逼真</strong></li></ul><hr><h3 id="模拟光线"><a href="#模拟光线" class="headerlink" title="模拟光线"></a>模拟光线</h3><p>光线追踪需要光在对象之间的反射信息，但是有无穷的光线散射，并且绝多数都没有进入人眼，因此，从<strong>视点</strong>跟踪光线的反向路径，所以在光线追踪中，光线就是<strong>从视点发出</strong>$(E)$<strong>有向三维直线</strong></p><blockquote><p>$tips$：因为光线是在<strong>模型之间</strong>散射，所以使用<strong>世界坐标系</strong></p></blockquote><p><img src="https://s2.loli.net/2024/10/21/SEYWADe9pzIQgfv.png" alt=""></p><blockquote><p>$tips$：如果采样率不够，还可以在一个<strong>像素点内均匀发出多条光线</strong></p></blockquote><p>若光线的另一个点为$S$，则<strong>光线的隐式三维直线方程为</strong></p><script type="math/tex; mode=display">P(t)=E+(S-E)</script><hr><h4 id="像素投影"><a href="#像素投影" class="headerlink" title="像素投影"></a>像素投影</h4><p>在相<strong>机坐标系</strong>中，将$(W,H)$的显示器像素坐标$(P_x \ ,\ P_y)$映射在$(L\ ,\ B)\to(R\ ,\ T)$<strong>近裁剪平面</strong>上</p><script type="math/tex; mode=display">\left[\begin{matrix}S_{u}\\\\S_{v}\\\\1\end{matrix}\right]=\left[\begin{matrix}1 & 0 & L\\\\0 & 1 & R\\\\0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}\frac{R-L}{W} & 0 & 0\\\\0 & \frac{T-B}{H} & 0\\\\0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & -\frac{1}{2}\\\\0 & 1 & -\frac{2}{1}\\\\0 & 0 & 1\end{matrix}\right]\left]\begin{matrix}P_u\\\\P_v\\\\1\end{matrix}\right]</script><p>且</p><script type="math/tex; mode=display">S_{w}=-n</script><blockquote><p>$tips_1$：$n$为进裁剪平面到相机的<strong>无向</strong>距离</p><p>$tips_2$：假设像素在整数坐标且覆盖范围$[-2/1,2/1]^2$区域，则屏幕上的点范围:$[-2/1,-2/1] \to[W-2/1,H-2/1]$</p></blockquote><hr><h4 id="转换为世界坐标系-笛卡尔坐标系"><a href="#转换为世界坐标系-笛卡尔坐标系" class="headerlink" title="转换为世界坐标系(笛卡尔坐标系)"></a><strong>转换为世界坐标系(笛卡尔坐标系)</strong></h4><script type="math/tex; mode=display">S=E+S_{u}\cdot \hat{U}+S_{v}\cdot \hat{V}+S_{w}\cdot \hat{W}</script><script type="math/tex; mode=display">\left[\begin{matrix}S_x\\\\S_y\\\\S_z\\\\1\end{matrix}\right]=\left[\begin{matrix}1 & 0 & 0 & E_x\\\\0 & 1 & 0 & E_y\\\\0 & 0 & 1 & E_z\\\\0 & 0 & 0 & 1\end{matrix}\right]\left[ \begin{matrix}U_x & V_x & W_x & 0\\\\U_y & V_y & W_y & 0\\\\U_z & V_z & W_z & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}S_{u}\\\\S_{y}\\\\S_{w}\\\\1\end{matrix}\right]</script><p>其中向量</p><script type="math/tex; mode=display">U=(U_x\ ,\ U_y\ ,\ U_z\ ,\ 0)</script><script type="math/tex; mode=display">V=(V_x\ ,\ V_y\ ,\ V_z\ ,\ 0)</script><script type="math/tex; mode=display">W=(W_x\ ,\ W_y\ ,\ W_z\ ,\ 0)</script><p>是在世界坐标系下得到的<strong>相机坐标系基向量</strong></p><blockquote><p>$tips$：整个变换矩阵可以用<strong>视角变换矩阵求逆</strong>获得</p></blockquote><hr><h3 id="光线与表面求交"><a href="#光线与表面求交" class="headerlink" title="光线与表面求交"></a>光线与表面求交</h3><p><strong>光线求交</strong>的完整描述是：给定一条光线$P(t)=E+tD$和物体表面的隐式表达式$F_n(P)=0$，求出</p><script type="math/tex; mode=display">q=min(\{t\lvert F_i(P(t))=0\ ,\ t>=0\})</script><p>但是实际情况会有</p><ul><li>光线不与<strong>场景中</strong>任何平面相交</li><li>光线达到一个不发生反射的<strong>光源</strong></li><li>光线到达表面$F_i(q)$</li></ul><hr><h4 id="光线与球面相交"><a href="#光线与球面相交" class="headerlink" title="光线与球面相交"></a>光线与球面相交</h4><p>圆心为$C(C_x\ ,\ C_y\ ,\ C_z)$，半径为$R$球面上一点<script type="math/tex">P(P_x\ ,\ P_y\ ,\ P_z)</script>的隐式表达为</p><script type="math/tex; mode=display">\begin{align}F(P) &= 0\\\\(P_x-C_x)^2+(P_y-C_y)^2+(P_z-P_z)^2-R^2 &= 0\\\\(P-C) \cdot (P-C) &= 0\nonumber\end{align}</script><p>代入光线$P(t)=E+tD$得到</p><script type="math/tex; mode=display">\begin{align}F(P(t)) &= 0\\\\(E+tD-C) \cdot(E+tD-C) &= 0\\\\(D\cdot D)t^2+2D\cdot (E-C)t+(E-C)\cdot(E-C)-R^2 &=0\nonumber\end{align}</script><p>然后<strong>按照二次方程</strong>处理</p><hr><h4 id="光线与三角形相交"><a href="#光线与三角形相交" class="headerlink" title="光线与三角形相交"></a>光线与三角形相交</h4><p><strong>空间中的三角形</strong>$ABC$中点$P$可以用<strong>重心坐标</strong>表达</p><script type="math/tex; mode=display">P=\alpha A+\beta B+\gamma C</script><script type="math/tex; mode=display">\alpha +\beta +\gamma=1</script><script type="math/tex; mode=display">\alpha\ ,\ \beta\ ,\ \gamma\ge 0</script><blockquote><p>$tips$：三角形重心坐标可以参见:<a href="https://amy-oo1.github.io/2024/10/19/Rasterization-draw-Triangle/">https://amy-oo1.github.io/2024/10/19/Rasterization-draw-Triangle/</a></p></blockquote><p>建立方程</p><script type="math/tex; mode=display">E+tD=\alpha A+\beta B+\gamma C</script><p>展开成多项式方程组</p><script type="math/tex; mode=display">\begin{align}E_x+tD_x &= A_x+\alpha(B_x-A_x)+\gamma(C_x-A_x)\\\\E_x+tD_y &= A_x+\alpha(B_y-A_y)+\gamma(C_y-A_y)\\\\E_x+tD_z &= A_x+\alpha(B_z-A_z)+\gamma(C_z-A_z)\nonumber\end{align}</script><p>最后，转化为矩阵方程</p><script type="math/tex; mode=display">\left[\begin{matrix}B_x-A_x &  C_x-A_x &-D_x\\\\B_y-A_y &  C_y-A_y &-D_y\\\\B_z-A_z &  C_z-A_z &-D_z\end{matrix}\right]\left[\begin{matrix}\alpha\\\\\beta\\\\t\end{matrix}\right]=\left[\begin{matrix}E_x-A_x\\\\E_y-A_y\\\\E_z-A_z \end{matrix}\right]</script><hr><h4 id="光线与多边形相交"><a href="#光线与多边形相交" class="headerlink" title="光线与多边形相交"></a>光线与多边形相交</h4><p>顶点序列$P_i$，法线$N$的多边形上所在平面一点$P\prime$的隐式表达为</p><script type="math/tex; mode=display">(P\prime-P_n)\cdot N=0</script><p>则可以求解方程式</p><script type="math/tex; mode=display">(E+tD-P_n)\cdot N=0</script><p>得到<strong>光线与多边形所在平面的交点</strong>$p\prime$</p><p>最后利用<a href="https://amy-oo1.github.io/2024/10/20/Judge-Point-in-Polyon/">奇偶规则</a>可以判断点$P\prime$是否在多边形内</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;光线追踪的特点&quot;&gt;&lt;a href=&quot;#光线追踪的特点&quot; class=&quot;headerlink&quot; title=&quot;光线追踪的特点&quot;&gt;&lt;/a&gt;光线追踪的特点&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;光线追踪（Ray Tracing）是一种图像渲染技术，它通过&lt;s</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Ray-Tracing" scheme="http://example.com/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>基本光照模型</title>
    <link href="http://example.com/2024/10/20/Shading-model/"/>
    <id>http://example.com/2024/10/20/Shading-model/</id>
    <published>2024-10-20T14:40:37.000Z</published>
    <updated>2024-10-22T16:03:45.870Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="光和颜色"><a href="#光和颜色" class="headerlink" title="光和颜色"></a>光和颜色</h3><ul><li><strong>光</strong>是一种电磁波的形式，它是能量的传播方式。在可见光谱范围内，光<strong>波长</strong>的不同决定了我们看到的颜色。光可以在真空和透明介质中传播，不需要任何物质存在</li><li><strong>颜色</strong>是人的视觉系统对光的一种感知，它是光进入眼睛后，由视网膜上的感光细胞（视锥细胞）解释波长信号的结果</li></ul><p><em>简单来说</em>，<strong>光源</strong>发出的物体<strong>光</strong>打到后，在物体的<strong>物理属性</strong>影响下，发生特定的<strong>折射</strong>和<strong>反射</strong>，进入人眼<strong>感知</strong>颜色信息</p><blockquote><p>$tips$ 只考虑光的<strong>粒子性</strong>，引用<strong>辐射度量学</strong>中的<strong>辐射强度</strong>(Radiant Intensity)$I$，即单位立体角内的辐射通量，描述了<strong>光源在特定方向上的发光能力</strong>，在<strong>计算机图形学</strong>中使用<strong>颜色模型</strong>描述颜色</p></blockquote><hr><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><blockquote><p>任意能发出<strong>辐射能量</strong>的对象，一个光源可以有多种属性：位置，<strong>辐射强度</strong>，发射方向</p></blockquote><p>最简单的模型是<strong>点光源</strong>，种光源模型是对场景中比对象<strong>小</strong>，距离对象<strong>远</strong>的合理<strong>逼近</strong></p><blockquote><p>在<strong>阴影生成</strong>中，这种光源模型只能生成<strong>硬阴影</strong></p></blockquote><hr><p>在图示中，球的正投影是<strong>硬阴影</strong>，光线无法到达，而附近的一块区域因为和<strong>球边缘</strong>发生<strong>散射</strong>，导致亮度偏低，生成<strong>软阴影</strong></p><p><img src="https://s2.loli.net/2024/10/21/ThXfcl3DPRqz7L9.png" alt=""></p><blockquote><p>软阴影的形成是因为光线在传播过程中会发生散射，导致阴影边缘不是完全黑暗的，而是有一定的光照</p></blockquote><hr><h3 id="辐射强度衰减"><a href="#辐射强度衰减" class="headerlink" title="辐射强度衰减"></a>辐射强度衰减</h3><blockquote><p>辐射强度衰减是指随着光线从光源传播出去，其强度随着距离的增加而逐渐减弱的现象，可以用来控制颜色的<strong>明亮程度</strong></p></blockquote><p>对于点光源，遵循<strong>平方反比衰减</strong>：辐射能量在空间中均匀地向四面八方扩散，由于球体的表面积与其半径的平方成正比，所以</p><script type="math/tex; mode=display">I_d=\frac{I}{d^{2}}</script><blockquote><p>$tips$ 通常会根据具体需求和场景的特点选择合适的辐射强度衰减模型</p></blockquote><hr><ul><li><p><strong>漫反射</strong>：光线射到一个粗糙或不规则的表面时，反射光线在多个方向上散射</p></li><li><p><strong>镜面反射</strong>：指光线射到一个平滑表面（如镜子或平静的水面）时，反射光线遵循<strong>入射角等于反射</strong>的定律</p></li></ul><blockquote><p>$tips$：在记算机图形学中，这些光照模型是根据<strong>经验</strong>得到的<strong>启发式函数</strong>，完全模拟真实的光照是不现实的</p></blockquote><hr><h3 id="环境明暗处理"><a href="#环境明暗处理" class="headerlink" title="环境明暗处理"></a>环境明暗处理</h3><blockquote><p>环境光只和物体的<strong>环境光反射系数</strong>和<strong>环境光强度</strong>有关</p></blockquote><script type="math/tex; mode=display">I_{ambient}=I_{ambient}*K_{ambient}</script><p>实际场景中，漫反射反复进行，使人能看见<strong>背光源</strong>物体，而<strong>环境光给场景整体朝明</strong>达到同样效果</p><hr><h3 id="表面处理处理"><a href="#表面处理处理" class="headerlink" title="表面处理处理"></a>表面处理处理</h3><p><strong>朗伯明暗处理模型</strong>模型基于<strong>理想漫反射</strong>的假设，即物体表面<strong>反射的光</strong>在所有方向上是<strong>均匀分布</strong>的</p><blockquote><p>朗伯余弦定律：理想漫反射表面的反射光强度与入射光方向和表面法线之间的夹角的余弦成正比</p></blockquote><p>因此可得<strong>漫反射</strong></p><script type="math/tex; mode=display">I_{diffuse}=K_{diffuse}*I_{light}\ max[ \cos(\hat{N}\cdot -\hat{L})\ ,\ 0]</script><ul><li>$K_{diffuse}$：物体的<strong>漫反射系数</strong>，反应物体的<strong>光学特性</strong></li><li>$I_{light}$：入射光辐射强度</li><li>$N$：平面法向量</li><li>$L$：入射光向量</li><li>$max$函数：中特判<strong>光线照不到</strong>的情况，隐含<strong>背光的辐射强度为0</strong></li></ul><hr><h3 id="Pong-明暗处理"><a href="#Pong-明暗处理" class="headerlink" title="$Pong$明暗处理"></a>$Pong$明暗处理</h3><blockquote><p><strong>高光</strong>：通常表现为物体表面上的小亮点或亮点区域，这些区域的光泽度和亮度都比周围区域要高</p></blockquote><p>高光是由于光线在<strong>光滑表面</strong>发生<strong>镜面反射</strong>而产生的，$Phong$模型认为<strong>镜面反射强度</strong>与$\cos(\hat{R}\cdot\hat{V})$正相关，其中$R$是出射光方向向量，$V$是反射点到人眼的向量</p><script type="math/tex; mode=display">I_{specular}=I_{light}*K_{specular}*\ max[0\ ,\ (\hat{R}\cdot\hat{V})^n]</script><p><strong>镜面反射参数</strong>$n$反应了表明高光大小，实践中，$n$值设置太低会导致表面出现<strong>大面积高光</strong></p><hr><h4 id="Blinn-Phong-反射模型"><a href="#Blinn-Phong-反射模型" class="headerlink" title="$Blinn-Phong$反射模型"></a>$Blinn-Phong$反射模型</h4><p>这个模型对$Pong$模型中引入<strong>办程向量H</strong>优化了计算</p><script type="math/tex; mode=display">H=V-L</script><p>几何上$H$在$-L$和$V$围成角的<strong>角平分线</strong>上，角$\alpha=\hat{H}\cdot\hat{N}$反应了角$\beta=\hat{R}\cdot\hat{V}$大小</p><blockquote><p>$tips$：若$L$和$V$位于同步一平面上，则有几何关系$2\alpha=\beta$，但是不能推广，他们的相关性在<strong>经验模型</strong>中足矣</p></blockquote><hr><h2 id="ADS-光照模型"><a href="#ADS-光照模型" class="headerlink" title="$ADS$光照模型"></a>$ADS$光照模型</h2><p>$ADS$(Ambient, Diffuse, Specular)光照模型是对以上三种模型的<strong>综合</strong>，同时包含<strong>环境光</strong>，<strong>漫反射</strong>，<strong>镜面反射</strong></p><script type="math/tex; mode=display">I=I_a*K_a+\sum_{i}^{amount\ of\ light}I_i*[K_d(\hat{N}\cdot\hat{-L})+K_s(\hat{N}\cdot\hat{H})^n]</script><blockquote><p>$tips$：若还要考虑<strong>辐射强度衰减</strong>，只需要对$I_{light}$处理，因为环境光是<strong>无穷光源</strong></p></blockquote><p>若在$RAGB$模型中，$I=[I_R\ ,\ I_G\ ,\ I_B]$中，各个数值的值域在$[0\ ,\ 1]$.最后的结果需要<strong>截断</strong>或者<strong>映射</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;光和颜色&quot;&gt;&lt;a href=&quot;#光和颜色&quot; class=&quot;headerlink&quot; title=&quot;光和颜色&quot;&gt;&lt;/a&gt;光和颜色&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;光&lt;/strong&gt;是一种电磁波的形式，它是能量的传播方式。在可见光谱范围内，光&lt;st</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>判断平面上的线段相交</title>
    <link href="http://example.com/2024/10/20/Judge-Segment-Intersect/"/>
    <id>http://example.com/2024/10/20/Judge-Segment-Intersect/</id>
    <published>2024-10-20T13:41:36.000Z</published>
    <updated>2024-10-23T14:00:25.302Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><blockquote><p>判断<strong>平面</strong>内线段相交，可以联立<strong>直线方程</strong>求解，然后判断是否在线段上</p></blockquote><p>这个方法需要用到<strong>除法</strong>运算，会有精度问题</p><hr><h5 id="判断点在线段的方向"><a href="#判断点在线段的方向" class="headerlink" title="判断点在线段的方向"></a>判断点在线段的方向</h5><p>定义向量$(B-A)$和点$P$,判定式</p><script type="math/tex; mode=display">flag=V(B-A)\times V(P-A)</script><ul><li>$flag=0$:点$P$和向量$(B-A)$共线</li><li>$flag&gt;0$:点$P$在向量$(B-A$的顺时针方向</li><li>$flag&lt;0$:点$P$在向量$(B-A$的逆时针方向</li></ul><blockquote><p>$tips$ 右手系坐标</p></blockquote><hr><h3 id="跨立试验"><a href="#跨立试验" class="headerlink" title="跨立试验"></a>跨立试验</h3><blockquote><p>跨立试验通过判断<strong>四个端点位于另一条线段的异侧</strong>证明线段相交</p></blockquote><p>非形式化证明：</p><ol><li>若一条线段$A$的两端位于另一条线段$B$两侧，则只有一种可能:<strong>B所在直线穿过线段A</strong></li><li>当把线段$A$沿着直线方向靠近线段$B$，只有两线段相交时，线段$B$两端的端点位于线段$A$异侧</li></ol><h4 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h4><p>当存在一个端点正好在另一条直线上，只需要<strong>比较坐标大小</strong>就可以判断点在线段上</p><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跨立试验证明线段相交</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="built_in">Vec2</span>(<span class="type">double</span> a, <span class="type">double</span> b) :<span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> x,<span class="type">double</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(Point T) &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>(T.x - <span class="keyword">this</span>-&gt;x, T.y - <span class="keyword">this</span>-&gt;y); &#125;</span><br><span class="line"><span class="type">double</span> x, y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="built_in">Edge</span>(Point S, Point T):<span class="built_in">S</span>(S),<span class="built_in">T</span>(T)&#123;&#125;</span><br><span class="line">Point S, T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叉积</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Det_Vec2</span><span class="params">(Vec2 A, Vec2 B)</span> </span>&#123; <span class="keyword">return</span> A.a * B.b - A.b - B.a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Point_on_Segment</span><span class="params">(Point P, Edge E)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">min</span>(E.S.x, E.T.x) &lt;= P.x &amp;&amp; P.x &lt;= <span class="built_in">max</span>(E.S.x, E.T.x) &amp;&amp; <span class="built_in">min</span>(E.S.y, E.T.y) &lt;= P.y &amp;&amp; P.y &lt;= <span class="built_in">max</span>(E.S.y, E.T.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Judge_segment_Intersect</span><span class="params">(Edge A, Edge B)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> B_S_in_A = <span class="built_in">Det_Vec2</span>(A.T - A.S, B.S - A.S),</span><br><span class="line">   B_T_in_A = <span class="built_in">Det_Vec2</span>(A.T - A.S, B.T - A.S),</span><br><span class="line">   A_S_in_B = <span class="built_in">Det_Vec2</span>(B.S - B.T, A.S - B.S),</span><br><span class="line">   A_T_in_B = <span class="built_in">Det_Vec2</span>(B.S - B.T, A.T - B.S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((B_S_in_A &gt; <span class="number">0</span> &amp;&amp; <span class="number">0</span> &lt; B_T_in_A) || (B_S_in_A &lt; <span class="number">0</span> &amp;&amp; <span class="number">0</span> &gt; B_T_in_A)) &amp;&amp; ((A_S_in_B &gt; <span class="number">0</span> &amp;&amp; <span class="number">0</span> &lt; A_T_in_B) || (A_S_in_B &lt; <span class="number">0</span> &amp;&amp; <span class="number">0</span> &gt; A_T_in_B)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (B_S_in_A == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(B.S, A))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (B_T_in_A == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(B.T, A))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A_S_in_B == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(A.S, B))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A_T_in_B == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(A.T, B))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;朴素算法&quot;&gt;&lt;a href=&quot;#朴素算法&quot; class=&quot;headerlink&quot; title=&quot;朴素算法&quot;&gt;&lt;/a&gt;朴素算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;判断&lt;strong&gt;平面&lt;/strong&gt;内线段相交，可以联立&lt;strong&gt;直线方程&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="计算几何" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>判断点和平面多边形关系</title>
    <link href="http://example.com/2024/10/20/Judge-Point-in-Polyon/"/>
    <id>http://example.com/2024/10/20/Judge-Point-in-Polyon/</id>
    <published>2024-10-20T01:34:58.000Z</published>
    <updated>2024-10-23T17:24:01.284Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote><p><strong>奇偶规则</strong>:若<strong>平面内</strong>某个点$P$在(无交叉边)多边形内(不包括边上)，则它发出的任意<strong>射线</strong>穿过<strong>奇数条边</strong>(多边形的)</p></blockquote><hr><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><blockquote><p>$tips$ 不考虑射线恰好落在<strong>顶点</strong>上的情况</p></blockquote><ul><li>非形式化证明: 多边形是一条线组成封闭图形，每<strong>穿线</strong>一次,<strong>射线端点的状态</strong>就改变一次</li></ul><p>对于$n(n\ge 3)$边<strong>平面</strong>多边形</p><ul><li>基本情况$n=3$,射线最多经过一条边</li><li>归纳假设，假设对于$n&gt;3$的多边形，性质成立</li><li>归纳推理：对于$(n+1\ ,\ n&gt;3)$的多边形，将它切分为$n$变形和一个三角形，注意这里会产生<strong>重边(切割线)</strong>，但是在大的多边形内部，不记这条重边<ul><li>若P发出的射线不经过三角形，那它一定只经过$n$边形，根据假设，性质成立</li><li>只经过三角形，根据基本情况，性质成立</li><li>同时经过三角形和$n$边形<ul><li>若点穿过三角形一条边，经过三角形一条边后，<strong>射线前端到多边形外</strong>，然后穿<strong>偶数条边</strong>后穿出$n$边形，相反的顺序依然成立</li><li>若点穿过三角形两条边，射线一定不会从三角形内出发，对穿过$n$边形的奇数条边没有影响</li></ul></li></ul></li></ul><hr><h3 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h3><p>如果射线恰好落在顶点上，需要特殊处理，<strong>把顶点视为某条邻边的一部分</strong>，这也可以解决重叠判定问题</p><hr><h4 id="射线和线段相交"><a href="#射线和线段相交" class="headerlink" title="射线和线段相交"></a>射线和线段相交</h4><ul><li>射线$Ray$的起点为$P$,方向向量为$D$</li><li>线段$AB$</li></ul><p>建立交点方程</p><script type="math/tex; mode=display">P+tD=A+S(B-A)</script><p>变换为</p><script type="math/tex; mode=display">Dt+S(A-B)=A-P</script><p>展开为矩阵表达</p><script type="math/tex; mode=display">\left[\begin{matrix}D_x & A_x-B_x\\\\D_y & A_y-B_y\end{matrix}\right]\left[\begin{matrix}t\\\\s\end{matrix}\right]=\left[\begin{matrix}A-P_y\\\\A-P_y\end{matrix}\right]</script><p>若$t&gt;0$且$0\le s\le 1$，则线段和射线相交</p><hr><h4 id="引入跨立试验判断"><a href="#引入跨立试验判断" class="headerlink" title="引入跨立试验判断"></a>引入跨立试验判断</h4><p>为了处理<strong>过单个顶点</strong>和<strong>重叠</strong>的特殊情况，可以使用叉积判定<strong>点在射线的方向</strong>，考虑运算量，可以将这个判定放在前面，避开部分矩阵方程</p><p>作出以下假设方便之后的分析：<strong>若射线所在直线过顶点，则该顶点在射线的顺时针方向</strong>，之后的<strong>判定相交</strong>都在这个语义下</p><script type="math/tex; mode=display">a=D\times(A-P)\ ,\ b=D\times(B-P)</script><ul><li><p>$a=0\ ,\ b=0$，线段与<strong>射线所在直线</strong>重叠的情况，不相交</p></li><li><p>两种<strong>对称</strong>的情况</p><ul><li><p>$a=0\ ,\ b&gt;0$，其中一个顶点在<strong>射线所在直线</strong>上，另一个顶点在射线顺时针方向，不相交</p></li><li><p>$a=0 \,\ b&lt;0$，其中一个顶点在<strong>射线所在直线</strong>上，另一个顶点在射线逆时针方向，<strong>需要判定射线和线段相交</strong>，不过可能的相交的点一定是$A$，所以只需要带入射线方程求非负解</p></li></ul></li><li><p>$ab&gt;0$，线段在射线所在直线一侧，不相交</p></li><li><p>只剩$ab&lt;0$，线段要么与射线相交，要么与反方向射线相交</p></li></ul><hr><h4 id="使用辅助点"><a href="#使用辅助点" class="headerlink" title="使用辅助点"></a>使用辅助点</h4><p>从以上分析可以看出，真正的困难是最后一种情况，也就是实践中最多的情况，射线的方向处理，可以引入对于多边形来说足够长的线段来代替射线，若四边形坐标有一定限制，那么这个方法可行</p><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="built_in">Vec2</span>(<span class="type">double</span> a, <span class="type">double</span> b) :<span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(Point S) &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>(<span class="keyword">this</span>-&gt;x - S.x, <span class="keyword">this</span>-&gt;y - S.y); &#125;</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="built_in">Edge</span>(Point S, Point T) :<span class="built_in">S</span>(S), <span class="built_in">T</span>(T) &#123;&#125;</span><br><span class="line">Point S, T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叉积</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Det_Vec2</span><span class="params">(Vec2 A, Vec2 B)</span> </span>&#123; <span class="keyword">return</span> A.a * B.b - A.b * B.a; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Point_on_Segment</span><span class="params">(Point P, Edge E)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">min</span>(E.S.x, E.T.x) &lt;= P.x &amp;&amp; P.x &lt;= <span class="built_in">max</span>(E.S.x, E.T.x) &amp;&amp; <span class="built_in">min</span>(E.S.y, E.T.y) &lt;= P.y &amp;&amp; P.y &lt;= <span class="built_in">max</span>(E.S.y, E.T.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点在简单多边形内</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Judge_Point_in_Ployon</span><span class="params">(Point P, vector&lt;Edge&gt; Ployon)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">E</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;<span class="comment">//无穷远点,多边形坐标都非负</span></span><br><span class="line">Vec2 Ray = E - P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Cross = [&amp;](Edge segment) &#123;</span><br><span class="line"><span class="type">double</span> S_in_Ray = <span class="built_in">Det_Vec2</span>(Ray, segment.S - P),</span><br><span class="line">   T_in_Ray = <span class="built_in">Det_Vec2</span>(Ray, segment.T - P);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特判顶点和重叠</span></span><br><span class="line"><span class="keyword">if</span> (S_in_Ray == <span class="number">0</span>)<span class="comment">//将顶点放在射线顺时针方向</span></span><br><span class="line">S_in_Ray = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (T_in_Ray == <span class="number">0</span>)</span><br><span class="line">T_in_Ray = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段在射线一侧的情况</span></span><br><span class="line"><span class="keyword">if</span> ((S_in_Ray &gt; <span class="number">0</span> &amp;&amp; T_in_Ray &gt; <span class="number">0</span>) || (S_in_Ray &lt; <span class="number">0</span> &amp;&amp; T_in_Ray &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">cout &lt;&lt; S_in_Ray &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段和射线相交</span></span><br><span class="line"><span class="type">double</span> Ray_E_in_segment = <span class="built_in">Det_Vec2</span>(E - segment.S, segment.T - segment.S),</span><br><span class="line">   Ray_P_in_segment = <span class="built_in">Det_Vec2</span>(P - segment.T, segment.T - segment.S);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，可能会产生溢出，这里为了表意这样写</span></span><br><span class="line"><span class="keyword">return</span> ((Ray_E_in_segment == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(E,segment))</span><br><span class="line"> || (Ray_P_in_segment == <span class="number">0</span> &amp;&amp; <span class="built_in">Point_on_Segment</span>(P, segment)) </span><br><span class="line"> || Ray_E_in_segment * Ray_P_in_segment &lt; <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; segment : Ployon)</span><br><span class="line">flag += <span class="built_in">Cross</span>(segment);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;奇偶规则&lt;/strong&gt;:若&lt;strong&gt;平面内&lt;/strong&gt;某</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="计算几何" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>光栅化-绘制三角</title>
    <link href="http://example.com/2024/10/19/Rasterization-draw-Triangle/"/>
    <id>http://example.com/2024/10/19/Rasterization-draw-Triangle/</id>
    <published>2024-10-19T15:11:58.000Z</published>
    <updated>2024-10-22T15:40:10.675Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>光栅化（Rasterization）是计算机图形学中的一个基本过程，它将矢量图形（由数学方程或直线、曲线等几何形状定义的图形）转换为光栅图形（即像素图）</p></blockquote><p>可以看出，<strong>光栅化</strong>包含了很多操作，这里只讨论<strong>绘制三角形</strong>，很多关键步骤和绘制三角形同步进行，而这一过程在<strong>屏幕映射</strong>后进行</p><hr><h2 id="二维直线绘制"><a href="#二维直线绘制" class="headerlink" title="二维直线绘制"></a>二维直线绘制</h2><p>二维直线方程给出了使用<strong>顶点</strong>在屏幕上绘制直线的方法</p><ul><li>输入 两个在屏幕上的不同点，$V_0\ ,\ V_1$</li><li>输出<strong>参数</strong>方程</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}x\\\\y\end{matrix}\right]=\left[\begin{matrix}V_{0_x}+t(V_{0_x}-V_{1_x})\\\\V_{1_y}+t(V_{1_y}-V_{1_y})\end{matrix}\right]</script><p>用向量表示为</p><script type="math/tex; mode=display">V(t)=V_0+t(V_1-V_0)</script><hr><h3 id="在屏幕上绘制线段"><a href="#在屏幕上绘制线段" class="headerlink" title="在屏幕上绘制线段"></a>在屏幕上绘制线段</h3><p>在计算机屏幕上显示线段，需要<strong>采样</strong>后的<strong>离散数据</strong>，即<strong>线上的采样点和它映射的像素集合</strong></p><blockquote><p>$tips_1$ 物理像素用整数坐标索引，显示的是周围$\frac{1}{2}$距离的范围</p><p>$tips_2$ 用<strong>图元像素</strong>表示<strong>某个采样点映射到的物理像素</strong>，这是(离散后)<strong>图元的基本元素</strong>，而不是物理像素本身</p></blockquote><hr><h3 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h3><p>给出两个<strong>顶点映射出的像素</strong>，可以得到<strong>线段采样点集</strong></p><script type="math/tex; mode=display">\{(P_x\ ,\ P_y) \vert (P_x\ ,\ P_y) \in F(V)\}</script><p>其中$F$是<strong>舍入规则</strong>，$V$是线段上的的点</p><blockquote><p>实践证明，贪心的实现精度不够</p></blockquote><hr><h3 id="中点算法"><a href="#中点算法" class="headerlink" title="中点算法"></a>中点算法</h3><p>中点算法基于$V_x$和$V_y$变化速率之比，即<strong>斜率</strong>的不同，给出不同的绘制分案</p><p>考虑斜率$s\in(0\ ,\ 1]$，即$V_x$的增长速度快于$V_y$的情况，若从左到右绘制，有以下性质</p><ol><li>每一次绘制有两个候选<strong>像素</strong>$(V_x+1\ ,\ V_y)\ ,\ (V_x+1\ ,\ V_y+1)$，其中$(P_x,P_y)$为上一个绘制的<strong>像素</strong></li><li><strong>同一列只有一个像素</strong></li></ol><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>根据<strong>性质2</strong>，找出<strong>两顶点</strong>所在的列上的像素</p><script type="math/tex; mode=display">(S_x\ ,\ S_y)=(F(min(P_{0_x}\ ,\ P_{0_x}))\ ,\ F(min(P_{0_y}\ ,\ P_{0_y})))</script><script type="math/tex; mode=display">(T_x\ ,\ T_y)=(F(min(P_{1_x}\ ,\ P_{1_x}))\ ,\ F(min(P_{1_y}\ ,\ P_{1_y})))</script><ul><li>$ def\ y=S_x\ ,\ for\ x=S_x\ upto\ T_x\ do$<ul><li>$draw(x\ ,\ y)$</li><li>$if\ (\ condition\ )\ y=y+1$</li></ul></li></ul><p>对于候选点的选择条件$condition$，选择<strong>候选点中点</strong>$(x+1\ ,\ y+\frac{1}{2})$，判断点和直线的关系</p><script type="math/tex; mode=display">condition=(y+\frac{1}{2}-V_{(x+1)_y}\ge 0)</script><p>其中$V_{(x+1)_y}$是直线上点$V_x=x+1$的$y$坐标</p><hr><h4 id="增量实现"><a href="#增量实现" class="headerlink" title="增量实现"></a>增量实现</h4><p>朴素实现中，计算中点坐标是关键路径，因为$x$方向的变化速度是固定的，即每次循环时$y$坐标变化量是固定的，所以</p><script type="math/tex; mode=display">y_{x-x_t}=y_s+(x-x_s)*\frac{max(y_0\ ,\ y_1)-min(y_0\ ,\ y_1)}{x_t-x_s}</script><script type="math/tex; mode=display">def\ T= \frac{max(y_0\ ,\ y_1)-min(y_0\ ,\ y_1)}{x_t-x_s}</script><script type="math/tex; mode=display">y_{x+1-x_t}=y_{x-x_t}+T</script><blockquote><p>$tips$ 为了减少角标，这里省略了点的表示</p></blockquote><hr><h3 id="二维三角形绘制"><a href="#二维三角形绘制" class="headerlink" title="二维三角形绘制"></a>二维三角形绘制</h3><blockquote><p>$tips$ 以下的三角形都是指被<strong>填充</strong>的三角形，而非三角形线框</p></blockquote><p>和二维直线绘制相同，需要在三角形的点集中<strong>采样</strong>像素点,一种可行的办法，通过三个顶点绘制线段直线作为三角形线框，绘制被线框围住的像素</p><p>实践中采用以下原则判断一个像素是非该被特定三角形绘制</p><ul><li><strong>当且仅当一个</strong>像素<strong>中心在三角形内(不包括边)，才被绘制</strong>  </li><li><strong>在边上的像素</strong>特殊处理</li></ul><hr><h4 id="重心坐标系"><a href="#重心坐标系" class="headerlink" title="重心坐标系"></a>重心坐标系</h4><blockquote><p>重心坐标系可以用来判断<strong>平面内</strong>任意一个点是否在三角形内</p></blockquote><p>给定三角形$ABC$和任意点$P$，令$A$为坐标原点，有</p><script type="math/tex; mode=display">P=A+\beta (B-A)+\gamma (C-A)</script><p>令</p><script type="math/tex; mode=display">\alpha=1-\beta-\gamma</script><p>则有</p><script type="math/tex; mode=display">P=\alpha A+\beta B + \gamma C</script><script type="math/tex; mode=display">\alpha +\beta +\gamma =1</script><blockquote><p>$tips_1$ 上述的式子需要分别作用于$x$和$y$，若要求解，带入原始公式求解方程式</p><p>$tips_2$ 这里不是笛卡尔坐标系，所以坐标原点不是$(0\ ,\ 0\ ,\ 0)$</p><p>$tips_3$ 在三角形中使用了大写字母作为顶点，而不是角</p></blockquote><hr><h5 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h5><blockquote><p>$\alpha\ ,\ \beta\ ,\ \gamma$分别是三角形$APB\ ,\ BPC\ ,\ CPA$面积和$ABC$面积之比  </p></blockquote><script type="math/tex; mode=display">0 < \alpha < 1</script><script type="math/tex; mode=display">0 < \beta < 1</script><script type="math/tex; mode=display">0 < \gamma < 1</script><p>可以为$P$分类</p><ul><li>其中一个系数为0，点在<strong>对边</strong></li><li>两个系数为0，点在<strong>顶点</strong></li></ul><hr><h4 id="简化计算"><a href="#简化计算" class="headerlink" title="简化计算"></a>简化计算</h4><blockquote><p>隐式直线方程$f(x\ ,\ y)=0$在某点$A$的结果$f(A_x,A_y)$表示点$A$和直线$f(x,y)=0$的距离乘上一个系数(和斜率有关) </p></blockquote><p><strong>将面积比简化为三角形相同底边的高比</strong>，则有</p><script type="math/tex; mode=display">\alpha=\frac{f_{BC}(P_x,P_y)}{f_{BC}(A_x,A_y)}</script><hr><h4 id="二维三角形绘制方法"><a href="#二维三角形绘制方法" class="headerlink" title="二维三角形绘制方法"></a>二维三角形绘制方法</h4><p>基于三角形绘制的第一条指导，可以得到部分绘制规则</p><ol><li>顺序遍历可能的像素区域</li><li>依序计算$\alpha,\beta,\gamma$</li><li>$(\alpha &gt;0 , \beta&gt;0,\gamma&gt;0)$成立时绘制三角</li></ol><p>三角形边的点可能会在两个三角形<strong>公共边</strong>上，简单的绘制和不绘制会带来<strong>重复绘制</strong>或<strong>空隙</strong></p><p>可以选择屏幕外一点$Q$,若有三角形公共边的的顶点$P$，当且仅当$Q$和三角形位于公共边同侧，$P$才被绘制</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;光栅化（Rasterization）是计算机图形学中的一个基本过程，它将矢量图形（由数学方程或直线、曲线等几何形状定义的图形）转换为光栅图形（即像素图）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，&lt;strong&gt;光栅化&lt;/str</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>隐藏面消除</title>
    <link href="http://example.com/2024/10/19/Z-buffer/"/>
    <id>http://example.com/2024/10/19/Z-buffer/</id>
    <published>2024-10-19T10:38:16.000Z</published>
    <updated>2024-10-22T14:45:11.260Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>假设已经完成了<strong>投影变换</strong>，得到的是在$(x\ ,\ y)\in[-1,1]^3$的<strong>标准视体</strong>,现在要做的工作就是将<strong>3维空间</strong>视体<strong>映射</strong>到<strong>2维显示器</strong></p><hr><h2 id="显示投影"><a href="#显示投影" class="headerlink" title="显示投影"></a>显示投影</h2><blockquote><p>只需要显示器（屏幕）的<strong>尺寸</strong>，就可以利用<strong>平移矩阵</strong>和<strong>缩放矩阵</strong>让视体在不破坏$(x\ ,\ y)$方向上的偏序关系下，完成变换  </p></blockquote><p>假设<strong>像素</strong>成矩阵排列，可以将显示器抽象成$W\times H$个<strong>像素</strong>的面,每个像素用<strong>整数坐标</strong>位置索引,坐标原点$(0\ ,\ 0)$在屏幕左下角,最右上角像素坐标为$(W-1\ ,\ H-1)$</p><blockquote><p>现在只需要把像素看做显示设备的基本元素</p></blockquote><p>因此，一个像素$(x \ ,\ y)$，<strong>显示</strong>范围为$(x-\frac{1}{2}\ ,\ y-\frac{1}{2})$，整个屏幕的显示范围为</p><script type="math/tex; mode=display">[-\frac{1}{2}\ ,\ -\frac{1}{2} ]\to [W-\frac{1}{2}\ ,\ H-\frac{1}{2}]</script><p>所以一个<strong>标准视体</strong>内的<strong>顶点</strong>$V$通过变换</p><script type="math/tex; mode=display">\left[\begin{matrix}P_x\\\\P_y\\\\1\end{matrix}\right]\left[\begin{matrix}\frac{W}{2} & 0 & \frac{W-1}{2}\\\\0 & \frac{H}{2} & \frac{H-1}{2}\\\\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}V_x\\\\V_y\\\\1\end{matrix}\right]</script><p>映射到屏幕像素$P$</p><blockquote><p>$tips_1$ 忽视了$Z$轴</p><p>$tips_2$ 平移矩阵有额外的$-\frac{1}{2}$的偏移</p><p>$tips_3$ 假定了<strong>显示平面</strong>和<strong>近裁剪面平行</strong>，所以可以使用$XY$坐标系变换</p></blockquote><hr><h2 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h2><blockquote><p>虽然隐藏面消除还有$BSP$等算法，但是存在物体相互遮挡的问题</p></blockquote><p>隐藏面消除的诉求来源于：<strong>场景中相互遮挡的部分会映射到同一块屏幕区域</strong>，后面的物体需要被隐藏，<strong>BSP</strong>等算法对<strong>图元</strong>排序，而Z-buffer对<strong>被映射到同一个像素的点</strong>排序</p><blockquote><p>上面提到了<strong>点</strong>,这里不是指<strong>图元顶点</strong>，而是将图元拆解后的<strong>基本元素</strong></p></blockquote><h3 id="引用-to-绘制图形"><a href="#引用-to-绘制图形" class="headerlink" title="引用$\to$绘制图形"></a>引用$\to$绘制图形</h3><p>经过<strong>屏幕投影</strong>阶段后，图元<strong>顶点</strong>被映射到屏幕上，使用特定<strong>采样算法</strong>将点<strong>集</strong>$\to$图元</p><blockquote><p>$eg$ 三角形：三个顶点$\to$三角形线框$\to$填充的三角形</p><p>$tips_1$ 第二幅图的底应该被填充</p><p>$tips_2$ 不代表具体采样方法</p></blockquote><p><img src="https://s2.loli.net/2024/10/19/AbsJYwqtShkVnUm.png" alt=""></p><blockquote><p>有时<strong>像素</strong>指的是<strong>显示单元</strong>，有时指的是<strong>图元单元</strong>，因为在$Z-buffer$算法中，一个物理像素被多个图元单元映射，在这里对他们进行区分，图元单元用<strong>像素点表示</strong></p></blockquote><hr><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>Z-buffer算法只需要一个数据结构</p><ul><li>$Z-buffer[W\times H]=z_{near}$ 被映射到<strong>物理像素</strong>$(i_w\ ,\ i_h)$的点中，$z$最<strong>大(视体在$-Z$轴)像素点</strong>的$z$坐标</li></ul><blockquote><p>$tips_1$ 这里$z$坐标经过了($z$方向上非线性变化)<strong>透视投影</strong>，$\Delta z$和<strong>模型</strong>数据不同</p><p>$tips_2$ 如果存储使用整数，可能会因为精度丢失造成伪影</p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>将$Z-buffer$缓冲器内元素初始化为$0$</li><li>遍历视体内所有图案的**像素点，更新$Z-buffer[P_x][P_y]=max\{Z-buffer[P_x][P_y]\ ,\ P_z\}$</li><li>在绘制<strong>图像</strong>时，遍历每个图元的所有<strong>点</strong>$P$，做深度测试$flag=(P_z==Z-buffer[P_x][P_y])$</li></ol><p>如果$flag==true$，就重写对应<strong>物理像素的属性</strong></p><p>实践中不需要<strong>步骤1</strong>，<strong>缓冲帧</strong>可以高效刷新$RGBA$，可以边改写$Z-buffer$，边重写物理像素属性</p><hr><h4 id="写入冲突"><a href="#写入冲突" class="headerlink" title="写入冲突"></a>写入冲突</h4><p>在上面的实现中，步骤1和步骤2中，都没有对<strong>遍历顺序</strong>做特别说明，然而这个属性会对结果会产生影响</p><p>考虑不相同的图元上可能会有相同的点，<strong>先遍历到的点会失去物理像素的占用权</strong>，造成这一现象可能的原因</p><ol><li>模型本身有重叠</li><li>变换过程中Z坐标的舍弃误差</li><li>Z-buffer缓冲器位深度不够，精度缺失</li></ol><blockquote><p>实现一般不对顺序做限制</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;假设已经完成了&lt;strong&gt;投影变换&lt;/strong&gt;，得到的是在$(x&#92; ,&#92; y)&#92;in[-1,1]^3$的&lt;strong&gt;</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>标准DFA状态数量最小化</title>
    <link href="http://example.com/2024/10/18/DFA-Minimize/"/>
    <id>http://example.com/2024/10/18/DFA-Minimize/</id>
    <published>2024-10-18T15:22:18.000Z</published>
    <updated>2024-10-22T14:50:14.767Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="同构自动机"><a href="#同构自动机" class="headerlink" title="同构自动机"></a>同构自动机</h3><p>实践表明，用<strong>子集构造法</strong>生成的DFA可能存在<strong>同构</strong>，即一个自动机至少存在这样的两个状态</p><ul><li>都不是接受状态</li><li>对于任意相同的输入，转移到同一个状态</li></ul><p>存在同构的的自动机可以<strong>合并</strong>这样的节点，减少节点数量</p><hr><p>为了定量描述算法，这里给出符号定义</p><ul><li>$DFA$的状态数量为$N$</li><li>小写字母$a$表示DFA状态,带角标的小写字母$a_1$表示终结状态</li><li>大写字母$A$表式任意$DFA$状态非空子集<strong>组</strong></li><li>$DFA$的输入符号集为$\sum$,希腊字母表示$\alpha$表示特定的转换条件</li><li>若无其他说明，表示不加区分，比如非法转换状态$\epsilon$</li></ul><hr><h3 id="朴素模拟"><a href="#朴素模拟" class="headerlink" title="朴素模拟"></a>朴素模拟</h3><p>基于同构的定义，可以</p><ol><li>暴力枚举任意两个<strong>非终结状态</strong></li><li>用$\Vert\sum\Vert$个输入符号做<strong>同构测试</strong></li><li>对状态集中的所有<strong>出边重定向</strong></li></ol><p>时间复杂度为</p><script type="math/tex; mode=display">Max\ O(N*(N^2*\Vert\sum\Vert)+N*\Vert\sum\Vert)=O(N^3*\Vert\sum\Vert)</script><p>实际上系数$N$是消去同构的次数，实践中<strong>高度同构</strong>的可能性很低</p><hr><h3 id="逆向处理"><a href="#逆向处理" class="headerlink" title="逆向处理"></a>逆向处理</h3><blockquote><p>朴素的处理是<strong>证明存在同构</strong>，而这里要介绍的是<strong>排除不同构</strong></p></blockquote><p>定义$DFA$的状态集合$G$</p><ol><li>首先初始化$G$，把不可能同构的状态分开，即<ol><li>把识别相同词法单元终结状态划归同组</li><li>其他所有状态一组</li><li>这两类状态构成$G$</li></ol></li><li>重复以下流程<ol><li>循环$G$中的每一个组$A$后得到$G\prime$<ol><li>将$A$划分为更小的组，使得任意两个小组$B$，$C$在同一组中，当且仅当对于所有的输入符号$\alpha$，状态$B$和$C$在$\alpha$的转换都到达$G$中同一个小组</li><li>用$B$，$C$等划分小组替换$A$</li></ol></li><li>若$G\prime =G$，停止重复</li></ol></li></ol><p>因此，算法的核心是<strong>对状态集合正确有效</strong>的划分 ，一个错误的划分可以直接独立每一个状态，但是任何时候都是无效操作</p><blockquote><p>鉴于这个方法将会用到集合操作，这里简单定义<strong>哈希</strong>相关算法时间复杂度为$O(1)$</p></blockquote><hr><h4 id="算法维持性质"><a href="#算法维持性质" class="headerlink" title="算法维持性质"></a>算法维持性质</h4><p>首先，给出<strong>串区分组</strong>的概念</p><blockquote><p>若输入串到达某个组时，组内状态有对当前输入字符有不一致的转移，则串能区分组</p></blockquote><p>要证明算法成立，需要两个性质</p><ul><li>状态在所有组中是唯一的</li><li>同一组状态不可能被任意串区分</li></ul><p>而在这个算法中，完成$i$<strong>步骤2</strong>后，<strong>长度为</strong>$i$<strong>的串不能区分任何组</strong></p><hr><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>实现这个算法需要</p><ul><li>数据结构$ainA[a]=ID_A$表示某一$DFA$状态$a$所在的组$A$，这个数据结构在步骤$1$初始化</li><li>在<strong>步骤2</strong>中维护一个数据结构$atoA[\alpha][a]=ID_A$，即某一$DFA$状态$a$在输入$\alpha$后到达的组$A$</li></ul><blockquote><p>通过以上分析，可以只用索引$ID$标记<strong>组</strong>，不实际储存状态集合，减少集合操作</p></blockquote><p>在每一次<strong>步骤2</strong>流程中</p><ol><li>迭代$\Vert\sum\Vert$个输入集, $\Vert\sum\Vert$<ol><li>对$N$个$DFA$状态$a$计算$atoA$，需要$ainA$的辅助，$N$</li><li>对每个状态<strong>顺序</strong>处理, $N$<ol><li>用哈希集标记$ainA$中的元素，用$O(1)$时间更新$ainA$</li></ol></li></ol></li></ol><p>因此，若同样做最坏处理,时间复杂度为</p><script type="math/tex; mode=display">Max\ O(N(N*\Vert\sum\Vert)+N*\Vert\sum\Vert)=O(N^2*\Vert\sum\Vert)</script><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>$E(a,\alpha)=b$</p><p>$End[i]=t_i$，第$i$个词法终结状态</p></blockquote><p>为了直观分组，在分组的同时计算了组$ID$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，为了减少细节处理，输入的是标准DFA</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DFA_minimize</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; E, vector&lt;<span class="type">int</span>&gt;&amp; End,<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size_state = E.<span class="built_in">size</span>(), size_instr = E.<span class="built_in">front</span>().<span class="built_in">size</span>(), size_End = End.<span class="built_in">size</span>(), size_Group = size_End + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ainA</span><span class="params">(size_state, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_End; ++i)</span><br><span class="line">ainA[End[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; size_state; ++a)</span><br><span class="line"><span class="keyword">if</span> (ainA[a] == <span class="number">-1</span>)</span><br><span class="line">ainA[a] = size_End;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> size_old_group = size_Group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> instr = <span class="number">0</span>; instr &lt; size_instr; ++instr) &#123;</span><br><span class="line"><span class="comment">//计算atoA</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">atoA</span><span class="params">(size_state)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; size_state; ++a)</span><br><span class="line">atoA[a] = ainA[E[a][instr]];</span><br><span class="line"><span class="comment">//关键步骤，分组</span></span><br><span class="line">vector&lt;unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">AtoA</span>(size_Group);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">type_toA</span><span class="params">(size_Group, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; size_state; ++a) &#123;</span><br><span class="line"><span class="type">int</span> A = ainA[a];</span><br><span class="line"><span class="keyword">if</span> (AtoA[A].<span class="built_in">find</span>(atoA[a]) == AtoA[A].<span class="built_in">end</span>())</span><br><span class="line">AtoA[A][atoA[a]] = type_toA[A]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新ainA</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ainA_new</span><span class="params">(size_state)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(type_toA.begin(), type_toA.end())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size_Group; ++i)</span><br><span class="line">cur[i] += cur[i - <span class="number">1</span>];<span class="comment">//组ID偏移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; size_state; ++a) &#123;</span><br><span class="line"><span class="type">int</span> A = ainA[a];</span><br><span class="line">ainA_new[a] = AtoA[A][atoA[a]] + cur[A] - type_toA[A];</span><br><span class="line">&#125;</span><br><span class="line">size_Group = cur.<span class="built_in">back</span>();</span><br><span class="line">ainA = ainA_new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出条件，组无变化</span></span><br><span class="line"><span class="keyword">if</span> (size_old_group == size_Group)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造新DFA</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Min_End</span><span class="params">(size_End)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(Min_End.<span class="built_in">begin</span>(), Min_End.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Min_E</span>(size_Group, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size_instr));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; size_state; ++a)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> instr = <span class="number">0</span>; instr &lt; size_instr; ++instr)</span><br><span class="line">Min_E[ainA[a]][instr] = ainA[E[a][instr]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_tuple</span>(Min_E, Min_End, ainA[s]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;同构自动机&quot;&gt;&lt;a href=&quot;#同构自动机&quot; class=&quot;headerlink&quot; title=&quot;同构自动机&quot;&gt;&lt;/a&gt;同构自动机&lt;/h3&gt;&lt;p&gt;实践表明，用&lt;strong&gt;子集构造法&lt;/strong&gt;生成的DFA可能存在&lt;strong&gt;同构&lt;/str</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="String" scheme="http://example.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器实现-NFA转DFA</title>
    <link href="http://example.com/2024/10/17/NFA-to-DFA/"/>
    <id>http://example.com/2024/10/17/NFA-to-DFA/</id>
    <published>2024-10-17T03:39:58.000Z</published>
    <updated>2024-10-22T13:58:10.449Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="合并-NFA"><a href="#合并-NFA" class="headerlink" title="合并$NFA$"></a>合并$NFA$</h3><p>到目前为止，只讨论了识别一个词语的情况，如果有多个词语，分别构造$NFA$，重复扫描识别可以实现，一趟扫描需要<strong>合并</strong></p><p>$NFA$的性质允许简单的合并</p><ol><li>新建起点状态$s$，在所有词语的$NFA$之间连一条标号为$\epsilon$的边</li><li>把所有终点状态附加状态，表明是哪个词语的识别完成</li></ol><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>实际上，词语定义之间存在交集和包含关系，通俗讲</p><ol><li>字符序列$SD$是词语S和词语D还是单个词语SD</li><li>一个序列和多个正则表达式匹配</li></ol><p>这里处理的方法是</p><ol><li>选择最长的前缀</li><li>给所有的词语定义附上优先级</li></ol><hr><h3 id="确定有穷自动机-DFA"><a href="#确定有穷自动机-DFA" class="headerlink" title="确定有穷自动机$(DFA)$"></a>确定有穷自动机$(DFA)$</h3><p>$DFA$的定义是相对于$NFA$的</p><ol><li>不允许$\epsilon$标记的边</li><li>对于每一个状态<strong>a</strong>和$\sum$中每个的输入符号$\beta$，<strong>有且只有</strong>一条标号为$\beta$的边离开a</li></ol><blockquote><p>$tips$ 第二条定义规定了每一个状态有$\lVert \sum\lVert$条不同的出边，可以通过引入<strong>无效状态</strong>定义非法路径</p></blockquote><p>引入$DFA$的可以解决$NFA$中因为$\epsilon$标号导致的高额开销</p><hr><h3 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h3><p>子集构造法可以将$NFA$转为识别同样语言的$DFA$，基本思想是让<strong>构造得到的</strong>$DFA$<strong>的每个状态对应于</strong>$NFA$<strong>的一个状态集合</strong></p><p>先解释几种符号</p><ul><li>大写字母<em>A</em>表示$DFA$的状态，小写字母代表NFA的状态，除此之外没有联系，希腊字母代表$NFA$状态转换条件，形式化定义 $E(a,\beta\ or\ \epsilon)=b$</li><li>因为$DFA$状态由$NFA$状态集合生成，所以定义$A=\{a,b,\cdots,c\}$，而$DFA$中状态不同可以定义为 $A\ne B$</li><li>$s$通过<strong>0个或多个</strong>$\epsilon$符号到达的状态集合 $closure(s)=\{(t|s\to t\ by\ \epsilon)^n\ ,\ n\ge 0\}$</li><li>$DFA$状态生成函数 $F(A,\sum)=B$<ul><li>对于特定输入符号$\beta$ </li><li>$A=\{a\ ,\ b\ ,\ \cdots\ ,\ c\}$</li><li>$B=\{closure(E(a\ ,\ \beta))\ ,\ closure(E(b\ ,\ \beta))\ ,\ \cdots\ ,\ closure(E(c\ ,\ \beta))\}$</li></ul></li></ul><h4 id="子集构造法的流程"><a href="#子集构造法的流程" class="headerlink" title="子集构造法的流程"></a>子集构造法的流程</h4><ul><li>$DFA$开始状态为$S=closure(s)$，其中$S$，$s$依次为$DFA$，$NFA$的开始状态</li><li>循序流程直到没有<strong>无标记状态</strong>可用<ul><li>对每个未标记的$DFA$状态$A$和每个输入符号$\beta$运用函数$F(A\ ,\ \beta)=sum_B=\{B_1\ ,\ B_2\ ,\ \cdots\ ,\ B_3\}$</li><li>将产生的$sum_B$中每一个状态与$DFA$现有的$DFA$状态集合(注意这里会变换)比较</li><li>如果是DFA状态集合中没有的，就<strong>加入并打上标记</strong></li></ul></li><li>加入无效节点$\emptyset$，完善$DFA$，即<ul><li>$\emptyset$有$\Vert\sum\Vert$条<strong>自边</strong></li><li>检查每一个$DFA$状态$A$,如果没有某个输入集$\sum$中的标号，就补对应的标号边连向$\emptyset$</li></ul></li><li>若$DFA$状态$A$中存在$NFA$的某个词语的结束状态$s_1$，就将$A$标记为对应词语的结束状态<ul><li>若存在不止一种词语的$NFA$结束状态，选择<strong>高优先级</strong>词语的结束状态</li></ul></li></ul><hr><h3 id="模拟DFA"><a href="#模拟DFA" class="headerlink" title="模拟DFA"></a>模拟DFA</h3><p>此时的DFA可以识别不同的词语，按照贪心规则，<strong>不断的读取输入文本字符直至达到无效状态</strong>$\emptyset$，然后回溯，最早遇到的结束符号，就是识别出的词语，若输入的的文本符合词语的正则表表达集和优先级规则，就可以将一个文本分割为各个词语</p><h3 id="处理非法输入"><a href="#处理非法输入" class="headerlink" title="处理非法输入"></a>处理非法输入</h3><p>实际情况是大多数文本会出现非法输入段落，因为贪心规则，没办法像单个词语的NFA那样利用$(\sum)^\ast$避开</p><blockquote><p>表现在程序上:$DFA$到达无效状态$\epsilon$后回溯找不到终止状态，最终到达起点状态</p></blockquote><p>实践中有多种处理方法，最简单的方法就是忽略部分输入</p><hr><h3 id="合并-NFA-1"><a href="#合并-NFA-1" class="headerlink" title="合并$NFA$"></a>合并$NFA$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并NFA 返回表</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Merge_NFA</span><span class="params">(vector&lt;vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt;&gt;&gt;&amp; gather_NFA, vector&lt;<span class="type">int</span>&gt;&amp; gather_flag)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> type_NFA = gather_NFA.<span class="built_in">size</span>(), size_node = <span class="built_in">accumulate</span>(gather_NFA.<span class="built_in">begin</span>(), gather_NFA.<span class="built_in">end</span>(), <span class="number">1</span>, [](<span class="type">int</span> sum, <span class="keyword">auto</span>&amp; vec) &#123;<span class="keyword">return</span> sum + vec.<span class="built_in">size</span>(); &#125;);</span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">E</span>(size_node, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(size_char));<span class="comment">//空集为非法转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(type_NFA)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定位</span></span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; type_NFA; ++i) &#123;</span><br><span class="line">E[<span class="number">0</span>][<span class="number">0</span>].<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">flag[i] = cur + gather_flag[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; gather_NFA[i].<span class="built_in">size</span>(); ++u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [v, f] : gather_NFA[i][u])</span><br><span class="line">E[cur + u][char_to_init[f]].<span class="built_in">emplace_back</span>(cur + v);</span><br><span class="line">cur += gather_NFA[i].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(E, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="NFA-转-DFA"><a href="#NFA-转-DFA" class="headerlink" title="$NFA$转$DFA$"></a>$NFA$转$DFA$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子集构造NFA转DFA  返回表</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NFA_to_DFA</span><span class="params">(vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;&amp; NFA_E, vector&lt;<span class="type">int</span>&gt; &amp;NFA_flag)</span> </span>&#123;</span><br><span class="line"><span class="comment">//点闭包初始化</span></span><br><span class="line"><span class="type">int</span> size_node = NFA_E.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">node_closure</span>(size_node);</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_finish</span><span class="params">(size_node, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; size_node; ++u)</span><br><span class="line">node_closure[u].<span class="built_in">emplace</span>(u);<span class="comment">//递归基</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归计算点闭包</span></span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; self, <span class="type">int</span> u)-&gt;<span class="type">void</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (is_finish[u])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; v : NFA_E[u][char_to_init[<span class="string">&#x27;#&#x27;</span>]]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!is_finish[v])</span><br><span class="line"><span class="built_in">self</span>(self, v);</span><br><span class="line">node_closure[u].<span class="built_in">insert</span>(node_closure[v].<span class="built_in">begin</span>(), node_closure[v].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">is_finish[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; size_node; ++u)</span><br><span class="line"><span class="built_in">dfs</span>(dfs, u);</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态闭包初始化</span></span><br><span class="line">vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; state_closure;</span><br><span class="line"><span class="type">int</span> size_state = <span class="number">1</span>;</span><br><span class="line">state_closure.<span class="built_in">emplace_back</span>(node_closure[<span class="number">0</span>].<span class="built_in">begin</span>(), node_closure[<span class="number">0</span>].<span class="built_in">end</span>());</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">DFA_E</span>(size_node, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size_char - <span class="number">1</span>, <span class="number">-1</span>));<span class="comment">//偏移掉#空转换</span></span><br><span class="line"><span class="type">int</span> type_end = NFA_flag.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">DFA_flag</span>(type_end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子集构造状态闭包</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">st_state</span><span class="params">(&#123; <span class="number">0</span> &#125;)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (!st_state.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> state = st_state.<span class="built_in">top</span>();</span><br><span class="line">st_state.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//定位终极符号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> Re_end = <span class="number">0</span>; Re_end &lt; type_end; ++Re_end)</span><br><span class="line"><span class="keyword">if</span> (state_closure[state].<span class="built_in">find</span>(NFA_flag[Re_end]) != state_closure[state].<span class="built_in">end</span>()) &#123;</span><br><span class="line">DFA_flag[Re_end].<span class="built_in">emplace</span>(state);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> f = <span class="number">1</span>; f &lt; size_char; ++f) &#123;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; new_state;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; u : state_closure[state])</span><br><span class="line"><span class="keyword">if</span> (!NFA_E[u][f].<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = NFA_E[u][f][<span class="number">0</span>];<span class="comment">//同非空字符转换最多一条</span></span><br><span class="line">new_state.<span class="built_in">insert</span>(node_closure[v].<span class="built_in">begin</span>(), node_closure[v].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!new_state.<span class="built_in">empty</span>()) &#123;<span class="comment">//忽略掉死状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(state_closure.<span class="built_in">begin</span>(), state_closure.<span class="built_in">end</span>(), new_state) == state_closure.<span class="built_in">end</span>()) &#123;</span><br><span class="line">state_closure.<span class="built_in">emplace_back</span>(new_state);</span><br><span class="line">st_state.<span class="built_in">emplace</span>(size_state++);</span><br><span class="line">&#125;</span><br><span class="line">DFA_E[state][f - <span class="number">1</span>] = <span class="built_in">find</span>(state_closure.<span class="built_in">begin</span>(), state_closure.<span class="built_in">end</span>(), new_state) - state_closure.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(DFA_E.<span class="built_in">begin</span>(), DFA_E.<span class="built_in">begin</span>() + size_state), DFA_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;合并-NFA&quot;&gt;&lt;a href=&quot;#合并-NFA&quot; class=&quot;headerlink&quot; title=&quot;合并$NFA$&quot;&gt;&lt;/a&gt;合并$NFA$&lt;/h3&gt;&lt;p&gt;到目前为止，只讨论了识别一个词语的情况，如果有多个词语，分别构造$NFA$，重复扫描识别可以实</summary>
      
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="String" scheme="http://example.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器实现-正则转NFA</title>
    <link href="http://example.com/2024/10/16/Lex-Re-to-NFA/"/>
    <id>http://example.com/2024/10/16/Lex-Re-to-NFA/</id>
    <published>2024-10-16T04:48:37.000Z</published>
    <updated>2024-10-22T13:40:03.818Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="词法分析器功能"><a href="#词法分析器功能" class="headerlink" title="词法分析器功能"></a>词法分析器功能</h2><p>词法分析器可以看做这样一个黑盒</p><p><strong>接收输入</strong></p><ul><li>字符组成的文本，定义了可用字符集</li><li>任意个词语定义，即用字符集中字符构造特定词语</li></ul><p><strong>产生输出</strong></p><ul><li>解析后的<strong>词语串</strong></li></ul><blockquote><p>通俗讲，词法分析器是<strong>字符串匹配算法</strong>的推广，字符串匹配在字符串中找特定字符，词法分析器在一串字符中找一类字符(正则定义)</p></blockquote><hr><h2 id="正则语言描述"><a href="#正则语言描述" class="headerlink" title="正则语言描述"></a>正则语言描述</h2><p>词语的字符定义可以用<strong>正则表达式</strong>表示，即这里处理的词语都在正则语言可表示的范围内</p><p>定义<strong>字符(串)</strong>$L,R$则有(优先级逐渐变高)</p><script type="math/tex; mode=display">L\vert M=\{S\vert S=L\ or\ S=R\}\tag{或}</script><script type="math/tex; mode=display">L\circ M=\{S\vert S=LM\}\tag{并}</script><script type="math/tex; mode=display">L^*=\{(L\circ L)^n\vert(L\circ L)^0=\epsilon\}\tag{Kleene闭包}</script><blockquote><p>$tips$ 若一个语言为空，表示为$\epsilon$，空语言存在是有意义的，当一个词语存在可选部分时，它可以作为占位符</p></blockquote><hr><h2 id="解析正则语言"><a href="#解析正则语言" class="headerlink" title="解析正则语言"></a>解析正则语言</h2><p>现在词语有了明确定义，下一步目标是将他从字符串中<strong>识别</strong>出来</p><h3 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h3><blockquote><p>自动机是一个对<strong>信号序列</strong>进行<strong>判定</strong>的数学模型,此处为字符序列</p></blockquote><p>这里我用<strong>图</strong>描述自动机</p><ul><li>图上点对应自动机上的状态</li><li>图上边对应自动机状态转换</li><li>边标号含义为状态转换的条件，一条路径的标号序列允许这个字符序列的通过</li></ul><h3 id="不确定有穷自动机-NFA"><a href="#不确定有穷自动机-NFA" class="headerlink" title="不确定有穷自动机($NFA$)"></a>不确定有穷自动机($NFA$)</h3><p>$NFA$对状态的转换限制宽松点,可以有多个出边，且标号可以用$\epsilon$ ($DFA$不允许)</p><p>一个$NFA$由以下部件组成</p><ol><li>有穷的状态集合$S$</li><li>输入符号集$\sum$，对应文本符号集，注意,隐含$\epsilon\notin\sum$</li><li>转换函数$f(a\ ,\ \beta)=c\ (a\ ,\ c\in S\ ,\ \beta\in\sum\bigcup\epsilon)$，即边标号的数学描述</li><li>开始状态$s$和结束状态$t$,且$s\ ,\ t\in S$</li></ol><h3 id="正则表达式构造-NFA"><a href="#正则表达式构造-NFA" class="headerlink" title="正则表达式构造$NFA$"></a>正则表达式构造$NFA$</h3><p><strong>MCMaughton-Yamada-Yhompson</strong>给出了相关算法</p><ul><li>单个字符表达式 $f(s,\beta \  or \ \epsilon)=t$</li><li>有运算符存在的正则表达,除了$s$的入边，其他边的标号一定是$\epsilon$，所以图上线条箭头的标号都是$\epsilon$</li></ul><p><img src="https://s2.loli.net/2024/10/16/AMFXEdB5JjUKrlH.jpg" alt=""></p><blockquote><p>$tips$ 这里隐藏表达式因子的内部结构，他们对运算结果没有影响</p></blockquote><hr><h3 id="Dijkstra双栈算法"><a href="#Dijkstra双栈算法" class="headerlink" title="Dijkstra双栈算法"></a>Dijkstra双栈算法</h3><blockquote><p>从正则表达式到NFA的转换规则出发，需要特定正则表达式的<strong>表达式树</strong>，即一个正则表达式的运算层次结构</p></blockquote><p>Dijkstra双栈算法用两个栈分别存储<strong>运算符</strong>和<strong>运算分量</strong>  </p><p>算法扫描表达式</p><ol><li>遇到运算符，如果运算符栈内的运算符不能晚于<strong>扫描点处的运算符</strong>表达，就表达它</li><li>扫描完成，应该清空运算符栈</li><li>最后在运算分量栈留下的运算分量就是这个表达式的结果</li></ol><blockquote><p>把这个算法运用在正则表达式上，就能得出对应的<strong>表达式树</strong>，实现上不需要显式构建这个树，因为这个算法的思想是<strong>自下而上</strong>的</p></blockquote><p>算法的关键在于正确<strong>解析运算符优先级，结合性，定位运算分量</strong></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入字符为ACSLL字符集，不包括(和)和#</span></span><br><span class="line"><span class="comment">//#为空符</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Regular_to_NFA</span><span class="params">(vector&lt;<span class="type">char</span>&gt; regular)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算节点最大数量</span></span><br><span class="line"><span class="type">int</span> size_ch = regular.<span class="built_in">size</span>(),</span><br><span class="line">size_state = <span class="number">2</span> * (size_ch - <span class="built_in">accumulate</span>(regular.<span class="built_in">begin</span>(), regular.<span class="built_in">end</span>(), <span class="number">0</span>,</span><br><span class="line">[](<span class="type">int</span> num, <span class="type">char</span> ch) &#123;<span class="keyword">return</span> num + (ch == <span class="string">&#x27;|&#x27;</span> || ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;)&#x27;</span>); &#125;)),</span><br><span class="line">size_connect = <span class="built_in">accumulate</span>(regular.<span class="built_in">begin</span>(), regular.<span class="built_in">end</span>(), <span class="number">0</span>,</span><br><span class="line">[](<span class="type">int</span> num, <span class="type">char</span> ch) &#123;<span class="keyword">return</span> num + ch == <span class="string">&#x27;|&#x27;</span>; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt;&gt; <span class="built_in">E</span>(size_state);</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; M_connect;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配节点</span></span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> build_heft = [&amp;cur] &#123;cur += <span class="number">2</span>; <span class="keyword">return</span> <span class="built_in">make_pair</span>(cur - <span class="number">2</span>, cur - <span class="number">1</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双栈</span></span><br><span class="line">stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st_heft;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; st_operator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> express_operator = [&amp;](<span class="type">char</span> operation) &#123;</span><br><span class="line"><span class="keyword">if</span> (operation != <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> [sc, tc] = <span class="built_in">build_heft</span>();</span><br><span class="line"><span class="keyword">auto</span> [sb, tb] = st_heft.<span class="built_in">top</span>();</span><br><span class="line">st_heft.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (operation == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">E[sc].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(tc, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[tb].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(sb, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[sc].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(sb, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[tb].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(tc, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> [sa, ta] = st_heft.<span class="built_in">top</span>();</span><br><span class="line">st_heft.<span class="built_in">pop</span>();</span><br><span class="line">E[sc].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(sa, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[sc].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(sb, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[ta].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(tc, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">E[tb].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(tc, <span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">st_heft.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(sc, tc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> [sb, tb] = st_heft.<span class="built_in">top</span>();</span><br><span class="line">st_heft.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">auto</span> [sa, ta] = st_heft.<span class="built_in">top</span>();</span><br><span class="line">st_heft.<span class="built_in">pop</span>();</span><br><span class="line">st_heft.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(sa, tb));</span><br><span class="line">M_connect[sb] = ta;<span class="comment">//保留编号小的节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; ch : regular) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;|&#x27;</span> || ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: &#123;st_operator.<span class="built_in">emplace</span>(<span class="string">&#x27;(&#x27;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">while</span> (!st_operator.<span class="built_in">empty</span>() &amp;&amp; st_operator.<span class="built_in">top</span>() == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">express_operator</span>(st_operator.<span class="built_in">top</span>());</span><br><span class="line">st_operator.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">st_operator.<span class="built_in">emplace</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">while</span> (!st_operator.<span class="built_in">empty</span>() &amp;&amp; st_operator.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">express_operator</span>(st_operator.<span class="built_in">top</span>());</span><br><span class="line">st_operator.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">st_operator.<span class="built_in">emplace</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: &#123;<span class="built_in">express_operator</span>(<span class="string">&#x27;*&#x27;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">while</span> (!st_operator.<span class="built_in">empty</span>() &amp;&amp; st_operator.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">express_operator</span>(st_operator.<span class="built_in">top</span>());</span><br><span class="line">st_operator.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">st_operator.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">st_heft.<span class="built_in">emplace</span>(<span class="built_in">build_heft</span>());</span><br><span class="line">E[st_heft.<span class="built_in">top</span>().first].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(st_heft.<span class="built_in">top</span>().second, ch));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清栈</span></span><br><span class="line"><span class="keyword">while</span> (!st_operator.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="built_in">express_operator</span>(st_operator.<span class="built_in">top</span>());</span><br><span class="line">st_operator.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规整化</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt;&gt; <span class="built_in">NFA_E</span>(size_state - size_connect);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; size_state; ++u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [v, f] : E[u])</span><br><span class="line"><span class="keyword">if</span> (M_connect.<span class="built_in">find</span>(v) != M_connect.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="type">int</span> temp_v = v;</span><br><span class="line">v = M_connect[temp_v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; size_state; ++u)</span><br><span class="line"><span class="keyword">if</span> (M_connect.<span class="built_in">find</span>(u) != M_connect.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [v, f] : E[u])</span><br><span class="line">E[M_connect[u]].<span class="built_in">emplace_back</span>(v, f);</span><br><span class="line">E[u].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; trans;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line">trans[st_heft.<span class="built_in">top</span>().first] = cur++;<span class="comment">//进入状态def 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; size_state; ++u) &#123;</span><br><span class="line"><span class="keyword">if</span> (!E[u].<span class="built_in">empty</span>() &amp;&amp; trans.<span class="built_in">find</span>(u) == trans.<span class="built_in">end</span>())</span><br><span class="line">trans[u] = cur++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [v, f] : E[u])</span><br><span class="line">NFA_E[trans[u]].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>((trans.<span class="built_in">find</span>(v) == trans.<span class="built_in">end</span>() ? trans[v] = cur++ : trans[v]), f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(NFA_E, trans[st_heft.<span class="built_in">top</span>().second]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="NFA-的模拟"><a href="#NFA-的模拟" class="headerlink" title="$NFA$的模拟"></a>$NFA$的模拟</h3><p>根据特定正则表达式构造出的$NFA$有如下性质</p><blockquote><p>完整经过$NFA$路径的字符序列集合是这个正则表达式所定义的词语集合</p></blockquote><p>现在给出的答卷是：输入语言串，该串是不是正则表达定义的词语，$NFA$回答<strong>是否</strong>，一种简单的处理方法，将词语的正则定义的前端加上<strong>输入集</strong>的闭包,即</p><script type="math/tex; mode=display">Re\prime=(\sum)^* Re</script><p>将整个文本输入$NFA$,然后贪心的识别词语，即达到结束状态就标记一个词语，就可以得到<strong>词语串</strong></p><blockquote><p>因为$NFA$允许$\epsilon$标号和多条出边，模拟一个$NFA$可能会出现分支，后面将会将$NFA$转为$DFA$缓解开销</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;词法分析器功能&quot;&gt;&lt;a href=&quot;#词法分析器功能&quot; class=&quot;headerlink&quot; title=&quot;词法分析器功能&quot;&gt;&lt;/a&gt;词法分析器功能&lt;/h2&gt;&lt;p&gt;词法分析器可以看做这样一个黑盒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收输入&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="String" scheme="http://example.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>3D模型观测[2]</title>
    <link href="http://example.com/2024/10/15/3D_Viewing-2/"/>
    <id>http://example.com/2024/10/15/3D_Viewing-2/</id>
    <published>2024-10-15T05:40:57.000Z</published>
    <updated>2024-10-22T14:49:06.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$tips$ 此处$n$和$f$都为<strong>无向距离</strong></p></blockquote><hr><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>把相机位置固定好后，需要归一化观测模型，把模型投影到2D屏幕上,在计算在图形学中，将要观察的<strong>视域</strong>通过<strong>平移</strong>和<strong>缩放归一化</strong>到$[-1,1]^3$的$3$维空间内</p><hr><h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p>正射投影是一种<strong>平行投影</strong>，场景模型只会做<strong>线性变换</strong>，平行的场景经过正射投影后显示后，仍能得保持平行</p><p><img src="https://s2.loli.net/2024/10/15/kWe8Ftx4cZv7lyD.jpg" alt=""></p><h3 id="正射投影矩阵"><a href="#正射投影矩阵" class="headerlink" title="正射投影矩阵"></a>正射投影矩阵</h3><p>依照定义，只需要对<strong>视域</strong>数字化输入</p><ul><li>相机到近/远裁剪平面的距离$n/f$</li><li>裁剪平面左下角坐标$(L\ ,\ B)$和右上角坐标$(R\ ,\ T)$  </li></ul><p>先对<strong>裁剪空间平移</strong>再<strong>放缩</strong>得到<strong>正射投影矩阵</strong></p><script type="math/tex; mode=display">O=\left[\begin{matrix}\frac{2}{R-L} & 0 & 0 & 0\\\\0 & \frac{2}{T-B} & 0 & 0\\\\0 & 0 & \frac{2}{f-n} & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 & -\frac{L+R}{2}\\\\0 & 1 & 0 & -\frac{B+T}{2}\\\\0 & 0 & 1 & \frac{n+f}{2}\\\\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}\frac{2}{R-L} & 0 & 0 & -\frac{L+R}{R-L}\\\\0 & \frac{2}{T-B} & 0 & -\frac{B+T}{T-B}\\\\0 & 0 & \frac{2}{f-n} & \frac{n+f}{f-n}\\\\0 & 0 & 0 & 1\end{matrix}\right]</script><blockquote><p>$tips_1$ 视域在$-Z$方向，所以平移矩阵的$z$分量符号为正时才能接近原点</p><p>$tips_2$ $Z$轴坐标虽然不影响<strong>显示投影</strong>，这里变换是为了<strong>插值法线</strong></p></blockquote><hr><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><blockquote><p>透视法来源<strong>近小远大</strong>的主观印象</p></blockquote><p>可以通过<strong>增大远裁剪面的面积</strong>达到这一目的,而实现的关键在于如何<strong>将锥形视域转换为立方体</strong></p><p><img src="https://s2.loli.net/2024/10/15/gwYOK6XBC4naM7x.jpg" alt=""></p><blockquote><p>$tips$ 压缩(透视变换)这一过程并不需要裁剪面的大小</p></blockquote><p>用<strong>相似三角</strong>,可以得到$x\prime =x\frac{n}{-z}$和$y\prime =y\frac{n}{-z}$</p><blockquote><p>$tips$ 因为$-z$方向的物体的$z$分量为负，所以要除$-z$</p></blockquote><p>而这个算式会在矩阵中引入对于每个点不同变量$z$，可以通过非标准齐次坐标</p><script type="math/tex; mode=display">(x\prime z\ ,\ y\prime z\ ,\ z\prime z\ ,\ z)</script><p>在矩阵中消除变量$z$<br>$z\prime$对于$x$和$y$是无关变量,综合可得</p><script type="math/tex; mode=display">\left[\begin{matrix}n & 0 & 0 & 0\\\\0 & n & 0 & 0\\\\0 & 0 & A & B\\\\0 & 0 & -1 & 0\end{matrix}\right]\left[\begin{matrix}x\\\\y\\\\z\\\\1\end{matrix}\right]=\left[\begin{matrix}nx\\\\ny\\\\Az+B\\\\-z\end{matrix}\right]=\left[\begin{matrix}\frac{n x}{-z}\\\\\frac{n y}{-z}\\\\\frac{Az+B}{-z}\\\\1\end{matrix}\right]</script><p>$A$和$B$的值通过特殊关系</p><script type="math/tex; mode=display">z_{-n}\prime=-n</script><script type="math/tex; mode=display">z_{-f}\prime=-f</script><p>解出</p><script type="math/tex; mode=display">A=n+f</script><script type="math/tex; mode=display">B=nf</script><p>综上，可以得出透视矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}n & 0 & 0 & 0\\\\0 & n & 0 & 0\\\\0 & 0 & n+f & nf\\\\0 & 0 & -1 & 0\end{matrix}\right]</script><hr><p>关于$z$坐标的的改变,对</p><script type="math/tex; mode=display">f=z\prime-z=n+f-\frac{nf}{z}-z>0</script><p>求导可得</p><script type="math/tex; mode=display">f\prime=\frac{nf}{z^2}-1</script><p>分析可得</p><script type="math/tex; mode=display">z\prime\geq z</script><hr><h3 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h3><p><strong>透视变换矩阵</strong>将锥形视域变换为立方体,<strong>透视投影矩阵</strong>在透视变换基础上，把<strong>近裁剪面投影到显示面</strong>，所以完整的透视投影矩阵需要让透视变换矩阵<strong>左乘正射投影矩阵</strong>，最后得到的透视投影矩阵为</p><script type="math/tex; mode=display">\left[\begin{matrix}\frac{2n}{R-l} & 0 & \frac{L+R}{R-L} & 0\\\\0 & \frac{2n}{T-B} & \frac{B+T}{T-B} & 0\\\\0 & 0 & \frac{n+f}{f-n} & \frac{2nf}{f-n}\\\\0 & 0 & -1 & 0\end{matrix}\right]</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;$tips$ 此处$n$和$f$都为&lt;strong&gt;无向距离&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;投影&quot;&gt;&lt;a href=&quot;#投影&quot; class=&quot;headerlink&quot; title=&quot;投影&quot;&gt;&lt;/a&gt;投</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>3D模型观测[1]</title>
    <link href="http://example.com/2024/10/14/3D_Viewing-1/"/>
    <id>http://example.com/2024/10/14/3D_Viewing-1/</id>
    <published>2024-10-14T13:09:57.000Z</published>
    <updated>2024-10-27T13:12:11.165Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="非齐次坐标"><a href="#非齐次坐标" class="headerlink" title="非齐次坐标"></a>非齐次坐标</h3><p>非齐次坐标表示为$(x\ ,\ y)$或$(x\ ,\ y\ ,\ z)$，对应的<strong>标准</strong>齐次坐标为$(x\ ,\ y\ ,\ 1)$或$(x\ ,\ y\ ,\ z\ ,\ 1)$</p><blockquote><p>齐次坐标引入了<strong>放缩分量</strong>,即最后的非零坐标</p></blockquote><p><strong>齐次坐标</strong>$(x\ ,\ y\ ,\ N)$或$(x\ ,\ y\ ,\ z\ ,\ N)\ ,\ N &gt;0$对应的标准形式为$(\frac{x}{N}\ ,\ \frac{y}{N}\ ,\ 1)$或$(\frac{x}{N}\ ,\ \frac{y}{N}\ ,\ \frac{z}{N}\ ,\ 1)$</p><blockquote><p>$tips$ 只能用<strong>标准化</strong>的齐次坐标生成向量</p></blockquote><hr><h2 id="向量的运用"><a href="#向量的运用" class="headerlink" title="向量的运用"></a>向量的运用</h2><hr><h3 id="向量加-减法"><a href="#向量加-减法" class="headerlink" title="向量加/减法"></a>向量加/减法</h3><p>定义向量</p><script type="math/tex; mode=display">A=(A_x\ ,\ A_y\ ,\ A_z\ ,\ 0)</script><script type="math/tex; mode=display">B=(B_x\ ,\ B_y\ ,\ B_z\ ,\ 0)</script><script type="math/tex; mode=display">C=A\pm B</script><p>则有</p><script type="math/tex; mode=display">C=(A_x\pm B_x\ ,\ A_y\pm B_y\ ,\ A_z\pm B_z\ ,\ 0)</script><hr><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><p>复用上面的定义</p><script type="math/tex; mode=display">A\cdot B=\Vert A\Vert\Vert B\Vert\cos(\langle A\ ,\ B\rangle)</script><blockquote><p><strong>向量点乘可以计算向量夹角,判断向量之间的位置关系</strong></p></blockquote><hr><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><blockquote><p>$tips_1$ 以下讨论基于右手系坐标</p><p>$tips_2$ 当把一个<strong>坐标</strong>写为向量形式时，表示为<strong>列向量</strong></p></blockquote><p>对于平面上的向量$A\ ,\ B$</p><script type="math/tex; mode=display">A\times B=det(matrix[A\ ,\ B])=det\left[\begin{matrix}A_x & B_x\\\\A_y & B_y\end{matrix}\right]=A_x*B_y-B_x*A_y</script><p>对于$3$维空间上的向量$A\ ,\ B$</p><script type="math/tex; mode=display">A\times B=det(matrix[I\ ,\ A\ ,\ B])=det\left[\begin{matrix}i & A_x & B_x\\\\j & A_y & B_y\\\\k & A_z & B_y\end{matrix}\right]</script><blockquote><p>几何上$\Vert A\times B\Vert=$向量$A\ ,\ B$张成的平行四边形面积</p></blockquote><hr><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><hr><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>对于矩阵$A[m][p]\ ,\ B[p][n]$和$C=AB$</p><script type="math/tex; mode=display">C[i][j]=\sum_{i=o}^{m-1}\sum_{j=0}^{n-1}\sum_{k=0}^{p-1}A[i][k]\cdot B[k][j]</script><blockquote><p>$tips$ 矩阵乘法是变换的基本操作，有低于$O(N^3)$的实现，也可以通过不同层次的并行加速</p></blockquote><hr><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>记$T$为坐标在各个方向平移的的距离，有</p><script type="math/tex; mode=display">\left[\begin{matrix}x+T_x\\\\y+T_y\\\\z+T_z\\\\1\end{matrix} \right]=\left[\begin{matrix}1 & 0 & 0 & T_x\\\\0 & 1 & 0 & T_y\\\\0 & 0 & 1 & T_z\\\\0 & 0 & 0 & 1\end{matrix}\right]\left[ \begin{matrix}x\\\\y\\\\z\\\\1\end{matrix}\right]</script><blockquote><p>齐次坐标的优势之一，可以用矩阵乘法表示平移</p></blockquote><hr><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>缩放操作让<strong>点靠近/远离坐标原点</strong>，通常需要对<strong>模型</strong>上的每一个<strong>顶点</strong>进行统一操作</p><blockquote><p>若物体的<strong>中心在原点</strong>，表现为整体的<strong>大小改变</strong></p></blockquote><p>记$S$为不同坐标上的缩放系数，则有</p><script type="math/tex; mode=display">\left[\begin{matrix}x\cdot S_x\\\\y\cdot S_y\\\\z\cdot S_z\\\\1\end{matrix}\right]=\left[\begin{matrix}S_x & 0 & 0 & 0\\\\0 & S_y & 0 & 0\\\\0 & 0 & S_z & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}x\\\\y\\\\z\\\\1\end{matrix}\right]</script><hr><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>因为已经有了平移变换，可以只考虑<strong>经过坐标原点的旋转轴</strong>，且<strong>欧拉角</strong>可以将任意轴<strong>拆分</strong>成三个旋转方向，所以只需要<strong>三个坐标轴的旋转矩阵</strong></p><blockquote><p>$tips$ 此处的旋转正方向都为逆时针</p></blockquote><p>点绕$X$轴旋转$\theta$度</p><script type="math/tex; mode=display">\left[\begin{matrix}1 & 0 & 0 & 0\\\\0 & \cos(\theta) & -\sin(\theta) & 0\\\\0 & \sin(\theta) & \cos(\theta) & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]</script><p>可以通过三角函数证明欧拉角的旋转矩阵$A_R$有以下性质</p><script type="math/tex; mode=display">A_R^{-1}=A_R^T</script><blockquote><p>$tips$ 任何旋转矩阵都是<strong>正交矩阵</strong>:<strong>矩阵的逆等于转置矩阵</strong></p></blockquote><h3 id="万向锁和四元数"><a href="#万向锁和四元数" class="headerlink" title="万向锁和四元数"></a>万向锁和四元数</h3><p>用欧拉角旋转存在<strong>万向锁</strong>的隐患，即旋转的两个坐标轴重合后，会<strong>丢失一个维度的自由度</strong>,替换为<strong>四元数</strong>后可以避免</p><hr><h2 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h2><blockquote><p>模型建立在$(x,y,z)$的<strong>世界坐标</strong>中，而把<em>相机</em>引入<strong>世界坐标系</strong>中观察物体时，用<strong>相机坐标系</strong>更方便处理</p></blockquote><p>视图变换可以把相机<em>放</em>在<strong>原点</strong>并朝向固定位置$(-Z)$</p><h4 id="视图变换输入"><a href="#视图变换输入" class="headerlink" title="视图变换输入"></a>视图变换输入</h4><ul><li><strong>相机位置</strong>：相机在世界坐标下的坐标 $E$</li><li><strong>注视点</strong>：世界坐标下观测目标的坐标 $G$</li><li><strong>向上方向向量</strong>：相机的向上方向的单位向量$V$(<em>归一化</em>)，通常定义为$(0\ ,\ 0\ ,\ 1)$</li></ul><h4 id="相机坐标系的-线性无关-基向量"><a href="#相机坐标系的-线性无关-基向量" class="headerlink" title="相机坐标系的(线性无关)基向量"></a>相机坐标系的(线性无关)基向量</h4><ul><li><strong>注视向量</strong></li></ul><script type="math/tex; mode=display">W=\frac{E-G}{\Vert E-F\Vert}</script><p>被定向到世界坐标系中$Z$轴方向的基向量</p><ul><li><strong>右方向</strong></li></ul><script type="math/tex; mode=display">U=\frac{V\times W}{\Vert V\times W\Vert}</script><p>被定向到世界坐标系中$X$轴方向的基向量</p><ul><li><strong>新的向上方向</strong></li></ul><script type="math/tex; mode=display">V=\frac{W\times U}{\Vert W\times U\Vert}</script><p>被定向到世界坐标系中$Y$轴方向的基向量</p><hr><h3 id="视图变换矩阵"><a href="#视图变换矩阵" class="headerlink" title="视图变换矩阵"></a>视图变换矩阵</h3><p>视图变换矩阵由两部分完成</p><ol><li>将相机位置<strong>平移</strong>到原点</li><li>将相机坐标系<strong>旋转</strong>，和世界坐标系对应基向量重叠</li></ol><p>为了得到第二步的旋转矩阵，可以考虑它的逆向操作：<strong>将世界坐标基向量重定位到相机坐标基向量</strong>，可以得到这个逆过程的旋转矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}U_x & V_x & W_x & 0\\\\U_y & V_y & W_y & 0\\\\U_z & V_z & W_z & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]</script><p>转置矩便可以得到所需的旋转矩阵</p><p>组合后可得<strong>视图变换矩阵</strong></p><script type="math/tex; mode=display">V=\left[\begin{matrix}U_x & U_y & U_z & 0\\\\V_x & V_y & V_z & 0\\\\W_x & W_y & W_z & 0\\\\0 & 0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 & -E_x\\\\0 & 1 & 0 & -E_y\\\\0 & 0 & 1 & -E_z\\\\0 & 0 & 0 & 1\end{matrix}\right]</script><p>场景中的模型$M$在相机坐标系下的坐标可以表示为</p><script type="math/tex; mode=display">P=VM</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;非齐次坐标&quot;&gt;&lt;a href=&quot;#非齐次坐标&quot; class=&quot;headerlink&quot; title=&quot;非齐次坐标&quot;&gt;&lt;/a&gt;非齐次坐标&lt;/h3&gt;&lt;p&gt;非齐次坐标表示为$(x&#92; ,&#92; y)$或$(x&#92; ,&#92; y&#92; ,&#92; z)$，对应的&lt;strong&gt;标准&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>DFT与频域转换</title>
    <link href="http://example.com/2024/10/13/DFT-Signal/"/>
    <id>http://example.com/2024/10/13/DFT-Signal/</id>
    <published>2024-10-12T17:22:21.000Z</published>
    <updated>2024-10-22T14:46:50.419Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="信号离散化"><a href="#信号离散化" class="headerlink" title="信号离散化"></a>信号离散化</h3><ul><li>物理上，气压变化引起空气<strong>分子振动</strong>，产生声波, 因此用波形图($t-$振幅)图储存，这就是音频信号的<strong>时域</strong>表示</li><li>理论上，图像可以无限<strong>分割</strong>到足够小，并用坐标表示位置，用颜色模型表示点信息，这就是图像信号的<strong>空域</strong>表示  </li></ul><p>然而，计算机只能处理有限的信息，因此需要将<strong>信号离散化</strong></p><blockquote><p><strong>采样</strong>:选择信号的有限个<strong>样点</strong>代表信号</p><p><strong>采样频率</strong>: <strong>单位时间/空间内的样本数</strong></p></blockquote><hr><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p>使用采用的方法会一定程度影响信号的准确性，如果一个信号偏差过大，就会发生<strong>失真</strong>，<strong>那奎斯特定理</strong>对这一现象给出定量分析</p><blockquote><p><strong>使用的采样频率至少是被采样信息频率的两倍</strong></p></blockquote><hr><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>通过傅里叶级数，可以将满足<strong>狄利克雷条件</strong>(连续，单调，有界)的<strong>周期</strong>函数，表示为不同频率的正弦和余弦函数</p><script type="math/tex; mode=display">f(t)=\sum_{-\infty}^{+\infty}\left[a_n\cos(nwt)+bn\sin(nwt)\right]</script><p>其中</p><script type="math/tex; mode=display">w=\frac{2\pi}{T}</script><script type="math/tex; mode=display">a_n=1/T\int_{-2/T}^{2/T}f(t)\cos(nwt)dt</script><script type="math/tex; mode=display">b_n=1/T\int_{-2/T}^{2/T}f(t)\sin(nwt)dt</script><hr><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>$CFT$是傅里叶级数在<strong>周期趋于无穷</strong>时的表达,利用欧拉公式，可以表达为</p><script type="math/tex; mode=display">F(t)=\int_{-\infty}^{+\infty}f(t)e^{nwti}dt</script><hr><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>$DFT$是$CFT$在<strong>离散输入</strong>下的特殊情况，并且它有优秀的算法实现(参见:<a href="https://amy-oo1.github.io/2024/10/12/FFT_1/">FFT</a>)</p><p>将$CFT$的积分号变为求和就可以得到$n$个样点$DFT$的一般表达式</p><script type="math/tex; mode=display">F(k)=\sum_{t=0}^{t=n-1} f(t)e^{\frac{2\pi tki}{n}}</script><hr><h2 id="DFT-处理音频信号"><a href="#DFT-处理音频信号" class="headerlink" title="$DFT$处理音频信号"></a>$DFT$处理音频信号</h2><p>对于采样数量为$N$,采样频率为$f_s$的离散音频信号$f(t)$，其$DFT$表示</p><script type="math/tex; mode=display">F(k)=\sum_{t=0}^{t=N-1} f(t)e^{\frac{2\pi tki}{N}}</script><ul><li>$t$ 表示时域表中样点索引，代表第$t$个样点</li><li><strong>频率分辨率</strong> $\Delta f=\frac {f_s}{N}$，相邻两个频率分量之间的频率差值</li><li>$k$ 是频域中频率分量索引，代表第k个频率分量，对应的<strong>频率</strong>为$k\Delta f$</li><li>$F(k)$ 第$k$个频率分量的值$(real,imag)$，<strong>幅度</strong>$\vert F[k]\vert$，<strong>相位</strong>$\tan^{-1}(\frac{imag}{real})$</li></ul><blockquote><p>因为FFT在实数输入上有对称的输出，高于$N/2$的信号只是前$N/2$信号的镜像，所以有实际意义的只有前$N/2$个频率分量</p></blockquote><hr><h3 id="DFT-处理图像信号"><a href="#DFT-处理图像信号" class="headerlink" title="$DFT$处理图像信号"></a>$DFT$处理图像信号</h3><p>图像使用二维的空域表示，需要二重$DFT$,对于$M\times N$的二维离散图像$f[m][n]$，$DFT_{M\times N}$</p><script type="math/tex; mode=display">F[k][l]=\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}f[m][n]e^{\frac{2\pi kmi}{M}}e^{\frac{2\pi lni}{N}}</script><h4 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h4><p><strong>水平频率</strong></p><script type="math/tex; mode=display">f_k=(k\geq \frac{M}{2}\ ?\ k-M\ :\ k)</script><p><strong>垂直频率</strong></p><script type="math/tex; mode=display">f_l=(k\geq \frac{N}{2}\ ?\ k-N\ :\ l)</script><blockquote><p>$tips\ $<em>mathjax对case块支持有点问题，故此用C的条件表达</em></p></blockquote><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><script type="math/tex; mode=display">f=\frac{f_{k\vert l}}{M\vert N}</script><blockquote><p>这两步将$F[k][l]$置于区间$(-0.5,0.5)$内,有方便<strong>频域分析</strong></p></blockquote><hr><h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><p>一个完整的信号通常具有较多的样点，可以<strong>按时间将信号分成多个帧并行处理</strong></p><blockquote><p>$\Delta f$与$N$值相关，过低的$N$值会使频率分量之间的间隔变大</p></blockquote><p>然而分帧也会带来<strong>频域泄漏</strong>,即中间帧的<strong>边缘样本缺失</strong>相关样本信息产生的误差，具体表现为帧与帧之间的连接不连续，可以通过<strong>窗口函数缓解</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;信号离散化&quot;&gt;&lt;a href=&quot;#信号离散化&quot; class=&quot;headerlink&quot; title=&quot;信号离散化&quot;&gt;&lt;/a&gt;信号离散化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;物理上，气压变化引起空气&lt;strong&gt;分子振动&lt;/strong&gt;，产生声波, 因此用波形图(</summary>
      
    
    
    
    <category term="数字信号处理" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
    <category term="傅里叶分析" scheme="http://example.com/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>FFT的数学解释[2]</title>
    <link href="http://example.com/2024/10/12/FFT-2/"/>
    <id>http://example.com/2024/10/12/FFT-2/</id>
    <published>2024-10-12T02:32:23.000Z</published>
    <updated>2024-10-27T23:38:18.763Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>一个$n$次多项式的点值表达式变换需要的工作就是计算项集</p><script type="math/tex; mode=display">\{(x_i\ ,\ y_i)\vert 0\le i\le n-1\ ,\ y_i=\sum_{j=0}^{n-1}a_jx_i^j\}</script><p>使用朴素方法需要$O(n^2)$的时间，用矩阵的逆(<strong>UL分解</strong>)求解逆变换需要$O(n^3)$时间，即便使用拉格朗日公式也需要$O(n^2)$的时间，整体上多项式乘法乘法并没有得到改进</p><hr><h3 id="折半原理"><a href="#折半原理" class="headerlink" title="折半原理"></a>折半原理</h3><p>定义<strong>主单位复数根</strong></p><script type="math/tex; mode=display">W_n=e^{\frac{2\pi i}{n}} \tag{1}</script><p>使得</p><script type="math/tex; mode=display">(W_n^k)^n=1</script><p>而$W_n^{(k)}$称为<strong>n次单位复数根</strong></p><hr><p>根据公式$(1)$可得<strong>消去原理</strong></p><script type="math/tex; mode=display">W_{2n}^{2k}=\left(e\frac{2\pi}{2n}\right)^{2k}=\left(e\frac{2\pi}{n}\right)^k=W_n^k\tag{2}</script><p>使用公式$(2)$对于$n$为偶数的主单位复数根，有<strong>折半原理</strong></p><script type="math/tex; mode=display">\left(W_n^k\right)^2=\left(W_n^{k+n/2}\right)^2=W_{n/2}^k\tag{3}</script><blockquote><p>这表明<strong>n次单位复数根的平方集合等价于n/2次单位复数集</strong></p></blockquote><hr><h3 id="DFT"><a href="#DFT" class="headerlink" title="$DFT$"></a>$DFT$</h3><p>考虑将$n$次单位复数根用在n次多项式点值表达式求值</p><script type="math/tex; mode=display">y_k=A(W_n^k)=\sum_{j=0}^{n-1}a_j(W_n^k)^j</script><p>向量</p><script type="math/tex; mode=display">y=(y_0\ ,\ y_1\ ,\ y_2\ ,\ \cdots\ ,\ y_{n-1})</script><p>就是系数向量</p><script type="math/tex; mode=display">a=(a_0\ ,\ a_1\ ,\ a_2\ ,\ \cdots\ ,\ a_{n-1})</script><p>的<strong>离散傅里叶变换</strong>(Discrete Fourier transform,$DFT$),记为</p><script type="math/tex; mode=display">y=DFT_n(a)</script><hr><h2 id="FFT"><a href="#FFT" class="headerlink" title="$FFT$"></a>$FFT$</h2><p>对于$n$($n$为$2$的幂)次多项式，采用偶/奇数项系数，构造$\frac{n}{2}$次数多项式</p><script type="math/tex; mode=display">A_{even}(x)=a_o+a_2x^1+a_4x^2+\cdots+a_{n-2}x^{(n/2-1)}</script><script type="math/tex; mode=display">A_{odd}(x)=a_1+a_3x^1+a_4x^3+\cdots+a_{n-1}^{(n/2-1)}</script><p>则有</p><script type="math/tex; mode=display">A(x)=A_{even}(x^2)+xA_{odd}^{x^2}</script><p>代入<strong>折半原理</strong>$(3)$左边两项</p><hr><script type="math/tex; mode=display">\begin{align}Y_k &= A(W_n^k)\\\\&= A_{even}(W_n^{2k})+W_n^kA_{odd}(W_n^{2k})\\\\&= A_{even}(W_{n/2}^{k})+W_n^kA_{odd}(W_{n/2}^{k})\tag{消去原理}\\\\&= y_{even_k}+W_n^ky_{odd_k}\nonumber\end{align}</script><script type="math/tex; mode=display">\begin{align}Y_{n/2+k} &= A(W_n^{n/2+k)})\\\\&= A_{even}({W_n^{n+2k}})+W_n^{n/2+k}A_{odd}(W_n^{n+2k})\\\\&= A_{even}({W_n^{2k}})-W_n^{k}A_{odd}(W_n^{2k})\tag{III}\\\\&= y_{even_k} -W_n^ky_{odd_k} \tag{消去原理}\nonumber\end{align}</script><p>$III$式可以通过<strong>欧拉公式</strong>$e^{ui}=\cos(u)+i\sin(u)$得出</p><blockquote><p>根据以上结果，可以递归计算奇偶项系数组成多项式的DFT，递归基为$n=1$,此时$y=a$</p></blockquote><hr><h3 id="DFT-n-1"><a href="#DFT-n-1" class="headerlink" title="$DFT_n^{-1}$"></a>$DFT_n^{-1}$</h3><p><strong>逆离散傅里叶变换</strong>同样从矩阵乘法找思路，把$DFT$写成矩阵乘积</p><script type="math/tex; mode=display">y=V_na</script><p>此时的逆矩阵并不需要<strong>UL分解</strong>这样的技术,因为</p><script type="math/tex; mode=display">V_n^{-1}[j][k]=\frac{W_n^{-kj}}{n}</script><p>可以推出$DFT_n^{-1}(y)$</p><script type="math/tex; mode=display">a_j=\frac{1}{n}\sum_{k=0}^{n-1}y_kW_n^{-kj}</script><blockquote><p>综上所述，我们用$DFT_n$处理单位根的倒数，最后除$n$即可实现$DFT_n^{-1}$</p></blockquote><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">S_FFT</span><span class="params">(vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; A_T, <span class="type">int</span> re_T=<span class="number">1</span>)</span> -&gt; vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; </span>&#123;<span class="comment">//长度为2的幂</span></span><br><span class="line"><span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> sub_fft = [&amp;pi](<span class="keyword">auto</span> &amp;self,vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; A, <span class="type">int</span> re = <span class="number">1</span>)-&gt;vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; &#123;</span><br><span class="line"><span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">Wn</span><span class="params">(cos(<span class="number">2.0</span> * pi / <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(n)), sin(<span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(re) * <span class="number">2.0</span> * pi / <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(n)))</span>, <span class="title">W</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;complex&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">A_even</span>(n &gt;&gt; <span class="number">1</span>), <span class="built_in">A_odd</span>(n &gt;&gt; <span class="number">1</span>), <span class="built_in">Y</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">A_even[i &gt;&gt; <span class="number">1</span>] = A[i];</span><br><span class="line">A_odd[i &gt;&gt; <span class="number">1</span>] = A[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> y_even = <span class="built_in">self</span>(self, A_even, re);</span><br><span class="line"><span class="keyword">auto</span> y_odd = <span class="built_in">self</span>(self, A_odd, re);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n &gt;&gt; <span class="number">1</span>); ++i) &#123;</span><br><span class="line">Y[i] = y_even[i] + W * y_odd[i];</span><br><span class="line">Y[i + (n &gt;&gt; <span class="number">1</span>)] = y_even[i] - W * y_odd[i];</span><br><span class="line">W *= Wn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> T_Y = <span class="built_in">sub_fft</span>(sub_fft,A_T, re_T);</span><br><span class="line"><span class="keyword">if</span> (re_T == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; y : T_Y)</span><br><span class="line">y /= complex&lt;<span class="type">double</span>&gt;&#123;<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(A_T.<span class="built_in">size</span>()), <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> T_Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>利用<strong>主定理</strong>，可以得出$DFT_n$和$DFT_n^{-1}$的过程可以在$O(n\log n)$的时间完成，而点值表达式的乘积可以在$O(n)$时间完成</p><blockquote><p>FFT加速多项式乘积的时间复杂度为$(n\log n)$</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;朴素算法&quot;&gt;&lt;a href=&quot;#朴素算法&quot; class=&quot;headerlink&quot; title=&quot;朴素算法&quot;&gt;&lt;/a&gt;朴素算法&lt;/h3&gt;&lt;p&gt;一个$n$次多项式的点值表达式变换需要的工作就是计算项集&lt;/p&gt;
&lt;script type=&quot;math/tex; </summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="多项式与生成函数" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
