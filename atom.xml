<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amy_blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-03T10:40:57.650Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Amy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>辐射度模型</title>
    <link href="http://example.com/2025/10/01/Radiosity-modle/"/>
    <id>http://example.com/2025/10/01/Radiosity-modle/</id>
    <published>2025-09-30T16:00:59.000Z</published>
    <updated>2024-11-03T10:40:57.650Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="渲染度模型"><a href="#渲染度模型" class="headerlink" title="渲染度模型"></a>渲染度模型</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;渲染度模型&quot;&gt;&lt;a href=&quot;#渲染度模型&quot; class=&quot;headerlink&quot; title=&quot;渲染度模型&quot;&gt;&lt;/a&gt;渲染度模型&lt;/h3&gt;&lt;hr&gt;
</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>体渲染模型</title>
    <link href="http://example.com/2024/11/06/Volume-Rendering/"/>
    <id>http://example.com/2024/11/06/Volume-Rendering/</id>
    <published>2024-11-06T14:58:04.000Z</published>
    <updated>2024-11-07T07:40:24.422Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>体渲染把气体等物质抽象成一团飘忽不定的<strong>粒子群</strong>。光线在穿过这类物体时，其实就是光子在跟粒子发生碰撞的过程</p></blockquote><p>考虑一段<strong>单位体积</strong>中，光子沿<strong>直线</strong>传播，则光子的运动可能会有如下情况</p><ul><li><p><strong>吸收</strong>（$absorption$）：光子被粒子吸收</p></li><li><p><strong>放射</strong>（$emission$）：宏观表现为物体自发光</p></li><li><p><strong>外散射</strong>（$out-scattering$）：光子在撞击到粒子后，可能会发生弹射，导致方向发生偏移,脱离当前定义的光子群</p></li><li><p><strong>内散射</strong>（$in-scattering$）：其他方向的光子在撞到粒子后，可能和当前方向上的光子重合</p></li></ul><p>若有点$P$在$w$方向的入射（辐射）强度$I_i$和出射辐射强度$I_r$，则有</p><p>$I_o-I_i=emission-absorption-scattering_{out}+scattering_{in}$</p><hr><h3 id="吸收（-absorbing-）"><a href="#吸收（-absorbing-）" class="headerlink" title="吸收（$absorbing$）"></a>吸收（$absorbing$）</h3><p>从$I_i$到$I_o$的光路截取一段到点$P$的<strong>距离</strong>为$s$<strong>微元区域</strong>，其垂直于光线的<strong>底面积</strong>为$E$，高为$ds$，单位体积包含的粒子数$\rho(s)$</p><p>则有光子吸收比例等价于：粒子横截面积比例</p><script type="math/tex; mode=display">\frac{\rho(s)\ Eds\ A}{E}=\rho(s)Ads</script><p>其中$A$为粒子最大的横截面积，且值域为$[0,1]$</p><blockquote><p>$tips$ 因为已经取了光路的<strong>横截微元体</strong>，当它切分的足够细，$ds$小到跟粒子直径一样大的时候，可以认为粒子在圆柱体高这个方向上<strong>不会互相重叠</strong></p></blockquote><p>所以在一段$ds$长度的光路中，（<em>只考虑吸收</em>）有</p><script type="math/tex; mode=display">\begin{align}dI &= -\rho(s)Ads\ I(s)\\\frac{dI}{ds}  &=-\rho(s)AI(s)\\&=-\tau_a(s)I(s)\\I(s) &= I_0\ exp\left(-\int_0^s\tau_a(t)dt\right)\end{align}</script><p>此处$I_0$表示常微分方程中的常数项，物理意义上表示光线的起始点处的光总强度$I_i$，即</p><script type="math/tex; mode=display">I_o=I_i\ exp\left(-\int_i^{o}\tau_a(t)dt\right)</script><p>定义<strong>透视比</strong>$T=\frac{I_s}{I_i}=exp\left(-\int_i^{s}\tau_a(t)dt\right)$<strong>反应</strong>光线衰减的幅度</p><p>$\tau_a(s)=\rho(s)A$也被称为<strong>光学厚度</strong>，它的值越小，粒子群越透明</p><hr><h3 id="放射（-emission-）"><a href="#放射（-emission-）" class="headerlink" title="放射（$emission$）"></a>放射（$emission$）</h3><p>假设粒子单位横截面积（距离$s$处）发射一束光的辐射强度为$I_e(s)$，考虑<strong>吸收</strong>后可以建立方程</p><script type="math/tex; mode=display">\begin{align}dI &= \rho(s)AI_e(s)ds\\\frac{dI}{ds} &= \rho(s)AI_e(s)\\&= \tau_a(s) I_e(s)\end{align}</script><hr><h3 id="散射（-scattering-）"><a href="#散射（-scattering-）" class="headerlink" title="散射（$scattering$）"></a>散射（$scattering$）</h3><p>散射和吸收的物理性质不能一概而论，用$\tau_s(s)$来表示外散射对光线的削弱比例</p><h4 id="外散射（-out-scattering-）"><a href="#外散射（-out-scattering-）" class="headerlink" title="外散射（$out-scattering$）"></a>外散射（$out-scattering$）</h4><p>粒子除了吸收光子，也可能会弹射光子，这个过程称为外散射，即光子被弹射出原本的光路，导致光线强度减弱，可以定义为</p><script type="math/tex; mode=display">\frac{dI}{ds}=-\tau_s(s)I(s)</script><h4 id="内散射-（-in-scattering-）"><a href="#内散射-（-in-scattering-）" class="headerlink" title="内散射 （$in-scattering$）"></a>内散射 （$in-scattering$）</h4><p>光子可以被弹射走，自然就有其他光路的光子被弹射到当前光路，这一过程就是内散射。内散射需要考虑其他光路光强，这里用$I_s$表示</p><script type="math/tex; mode=display">\frac{dI}{ds}=\tau_s(s)I_s(s)</script><hr><h3 id="体渲染方程"><a href="#体渲染方程" class="headerlink" title="体渲染方程"></a>体渲染方程</h3><p>综合四种光子运动</p><script type="math/tex; mode=display">\frac{dI}{ds}=-\tau_a(s)I(s)+\tau_a(s)I_e(s)-\tau_s(s)I(s)+\tau_s(s)I_s(s)</script><p>令$\tau_t(s)=\tau_s(s)$，解常微分方程</p><script type="math/tex; mode=display">\begin{align}I(s)=\frac{dI}{ds} &= -\tau_a(s)I(s)+\tau_a(s)I_e(s)-\tau_s(s)I(s)+\tau_s(s)I_s(s)\\\\&= -\tau_t(s)I(s)+\tau_a(s)I_e(s)+\tau_s(s)I_s\\\\&= \int_0^se^{\left(-\int_0^t\tau_t(u)du\right)}(\tau_a(t)I_e(t)+\tau_s(s)I_s(t))+I_0e^{\left(-\int_0^t\tau_t(t)dt\right)}\end{align}</script><p>假设$\tau_t=\tau_a=\tau_a=\sigma$，令$C=I_e+I_s$</p><script type="math/tex; mode=display">\begin{align}I(s) &= \int_0^s e^{\left(-\int_0^t\sigma(u)du\right)}\sigma(t)C(t)dt+I_0e^{\left(-\int_0^s\sigma(t)dt\right)}\\\\&= \int_0^sT(t)\sigma(t)C(t)dt+T(s)I_0\end{align}</script><p>其中</p><script type="math/tex; mode=display">T(t)=e^{\left(-\int_0^t\sigma(u)du\right)}</script><hr><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>将$[0,s]$的光路等距划分为$N$个区间$[t_i,t_{i+1}],0\le i\le N-1$</p><p>令$I[t_i,t_{i+1}]=\int_{t_i}^{t_{i+1}}T(t)C(t)\sigma(t)dt$，再令区间内$\sigma (t)$处处相等，则有</p><script type="math/tex; mode=display">I[t_i,t_{i+1}]=C_i\sigma_i\int_{t_i}^{t_{i+1}}T(t)dt</script><p>$T(t)$是从光路上$0$到$t$的积分，令$T(begin\to end)$是光路上（从$begin$到$end$）路径段的积分</p><script type="math/tex; mode=display">\begin{align}T(t)=T(0\to s) &= e^{\left(-\int_0^t\sigma(u)du\right)}\\\\&= e^{\left(-\int_0^{t_i}\sigma(u)du-\int_{t_i}^t\sigma(u)du\right)}\\\\&= e^{\left(-\int_0^{t_i}\sigma(u)du\right)}e^{\left(-\int_{t_i}^t\sigma(u)du\right)}\\\\&= T(0\to t_i)T(t_i\to t)\end{align}</script><script type="math/tex; mode=display">\begin{align}I[t_i,t_{i+1}] &= C_i\sigma_i\int_{t_i}^{t_{i+1}}T(0\to t)dt\\\\&= C_i\sigma_i\int_{t_i}^{t_{i+1}}T(0\to t_i)T(t_i\to t)dt\\\\&= C_i\sigma_iT(0\to t_i)\int_{t_i}^{t_{i+1}}T(t_i\to t)dt\\\\&= C_i\sigma_iT(0\to t_i)\int_{t_i}^{t_{i+1}}e^{\left(-\sigma(t-t_i)\right)}dt\\\\&= C_iT(0\to t_i)(1-e^{\left(-\sigma(t_{i+1}-t_i)\right)})\end{align}</script><p>令$\delta=t_{i+1}-t_i$,累加各个区间</p><script type="math/tex; mode=display">\begin{align}I(s) &= \int_0^sT(t)\sigma(t)C(t)dt+T(s)I_0\\\\&\approx \sum_{i=0}^{N-1}I[t_i,t_{i+1}]+T(0\to s)I_0\\\\&= \sum_{i=0}^{N-1}C_iT(0\to t_i)(1-e^{\left(-\sigma(t_NaN-t_i)\right)})+T(0\to s)I_0\\\\&= \sum_{i=0}^{N-1}(1-e^{-\sigma(t)\delta_i})C_iT(0\to t_i)+T(0\to s)I_0\end{align}</script><p>$T$积分域都从$0$开始，最后可得体渲染方程</p><script type="math/tex; mode=display">I(s)=\sum_{i=0}^{N-1}(1-e^{-\sigma(t)\delta_i})C_iT(t_i)+T(s)I_0</script><script type="math/tex; mode=display">T(s)=e^{\left( \sum_{j=0}^{t_j={s-1}}\sigma(j)\delta_j\right)}</script><script type="math/tex; mode=display">\delta=t_{i+1}-t_i</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;体渲染把气体等物质抽象成一团飘忽不定的&lt;strong&gt;粒子群&lt;/strong&gt;。光线在穿</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>四元数与旋转</title>
    <link href="http://example.com/2024/11/05/Quaternion-rotation/"/>
    <id>http://example.com/2024/11/05/Quaternion-rotation/</id>
    <published>2024-11-05T01:52:18.000Z</published>
    <updated>2024-11-05T14:33:55.309Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="绕坐标轴旋转"><a href="#绕坐标轴旋转" class="headerlink" title="绕坐标轴旋转"></a>绕坐标轴旋转</h3><p>考虑在$XOY$平面上的二维旋转：$P$沿逆时针旋转$\theta$角度得$P^\prime$</p><p>根据旋转定义</p><script type="math/tex; mode=display">\lVert P\rVert=\lVert P^\prime\rVert\tag{I}</script><p>其中向量$Q(-y_P,x_P)$为$P$逆时针<strong>旋转</strong>$90^\circ$得到，$P$和$Q$正交</p><p>则有$P^\prime=proj_P+proj_Q$，简单来说，$P^\prime$在两个正交基方向上的投影</p><script type="math/tex; mode=display">\begin{align}proj_P &= (\frac{P^\prime\cdot P}{\lVert P\rVert})\frac{P}{\lVert P\rVert}=P\cos\theta\tag{reference I}\\proj_Q &= (\frac{P^\prime\cdot Q}{\lVert Q\rVert})\frac{Q}{\lVert Q\rVert}=Q\sin\theta\tag{reference I}\end{align}</script><p><img src="https://s2.loli.net/2024/11/05/4NBhwj8xWPsu6eb.png" alt=""></p><script type="math/tex; mode=display">\begin{align}P^\prime &= P\cos\theta+Q\sin\theta\\P_x^\prime &= P_x\cos\theta-P_y\sin\theta\\P_y^\prime &= P_y\cos\theta+P_x\sin\theta\\\end{align}</script><p>转换为矩阵</p><script type="math/tex; mode=display">P^\prime=\left[\begin{matrix}\cos\theta & -\sin\theta\\\sin\theta & \cos\theta\end{matrix}\right]P</script><p>将这一结论推广到<strong>笛卡尔坐标系</strong>中<strong>绕坐标轴</strong>的旋转</p><ul><li>绕$X$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_X(P,\theta)=\left[\begin{matrix}1 & 0 &  0\\ 0 &\cos\theta & -\sin\theta\\0 &\sin\theta & \cos\theta\end{matrix}\right]P</script><ul><li>绕$Y$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_Y(P,\theta)=\left[\begin{matrix}0 &\cos\theta & -\sin\theta\\0 & 1 & 0\\0 &\sin\theta & \cos\theta\end{matrix}\right]P</script><ul><li>绕$Z$轴旋转：</li></ul><script type="math/tex; mode=display">Rotate_Z(P,\theta)=\left[\begin{matrix}0 &\cos\theta & -\sin\theta\\0 &\sin\theta & \cos\theta\\0 & 0 & 1\end{matrix}\right]P</script><hr><h3 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h3><script type="math/tex; mode=display">Rotate_Q(ai+bj+ck,\theta)=Rotate_Q(ai,\theta)+Rotate_Q(bj,\theta)+Rotate_Q(ck,\theta)\tag{II}</script><p>考虑三维空间中向量$P$绕旋转轴$Q$逆时针旋转$\theta$度得到$P^\prime$</p><p>同二维旋转一样，为$P^\prime$建立正交基</p><script type="math/tex; mode=display">\begin{align}P &= Proj_QP+Perp_QP\\P^\prime &= Rotate_Q(P,\theta)\\&= Rotate_Q(Proj_QP,\theta)+Rotate_Q(Perp_QP,\theta)\tag{reference II}\\&= Proj_QP+Rotate_Q(Perp_QP,\theta)\end{align}</script><p>因为$Perp_QP$向量旋转后的向量在二维平面，且可以用正交基$Q\times P$，$Perp_QP$表示，所有又是一个二维平面旋转问题</p><script type="math/tex; mode=display">\begin{align}\lVert Perp_QP\rVert &= P\sin\alpha =\frac{\lVert Q\times P\rVert}{\lVert Q \rVert}\\\\Rotate_Q(Perp_QP,\theta) &= (Perp_QP)\cos\theta+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\end{align}</script><p>其中</p><script type="math/tex; mode=display">\begin{align}Proj_QP &= (\frac{P\cdot Q}{\lVert Q\rVert})\frac{Q}{\lVert Q\rVert}=(P\cdot\hat{Q})\hat{Q}\\Perj_QP &= P-Prej_QP=P-(P\cdot\hat{Q})\hat{Q}\end{align}</script><p><img src="https://s2.loli.net/2024/11/05/AFPLJTnp8gEWVHC.png" alt=""></p><p>综上</p><script type="math/tex; mode=display">\begin{align}Rotate_Q(P,\theta) &= (P\cdot\hat{Q})\hat{Q}+(P-(P\cdot\hat{Q})\hat{Q})\cos\theta+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\\\\&= P\cos\theta+(1-\cos\theta)(P\cdot\hat{Q})\hat{Q}+\frac{(Q\times P)}{\lVert Q \rVert}\sin\theta\\\\&= P\cos\theta+(1-\cos\theta)\hat{Q}\hat{Q}^TP+(\hat{Q}\times P)\sin\theta\end{align}</script><blockquote><p>$tips$ $(P\cdot Q)Q=QQ^TP$</p></blockquote><p>转换为矩阵表达$c=\cos\theta,s=sin\theta$</p><script type="math/tex; mode=display">Rotate_Q(P,\theta)=\left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{matrix}\right]cP+\left[\begin{matrix}\hat{Q}_x^2 & \hat{Q}_x\hat{Q}_y & \hat{Q}_x\hat{Q}_z\\\hat{Q}_x\hat{Q}_y & \hat{Q}_y^2 & \hat{Q}_y\hat{Q}_z\\\hat{Q}_x\hat{Q}_z & \hat{Q}_y\hat{Q}_z & \hat{Q}_z^2\end{matrix}\right](1-c)P+\left[\begin{matrix}0 & -\hat{Q}_z & \hat{Q}_y\\\hat{Q}_z & 0 & -\hat{Q}_x\\-\hat{Q}_y & \hat{Q}_x & 0\end{matrix}\right]sP</script><p><em>可以再缩写成一个矩阵，不过没有特征就不再展示</em></p><hr><h3 id="四元数的基本性质"><a href="#四元数的基本性质" class="headerlink" title="四元数的基本性质"></a>四元数的基本性质</h3><blockquote><p>四元数（$Quaternion$）是数学中一种扩展的复数形式，由爱尔兰数学家威廉·卢云·哈密顿在1843年发现。四元数是一种包含四个分量的超复数</p></blockquote><p>四元数$q$通常具有以下形式</p><script type="math/tex; mode=display">q=s+xi+yj+zk=(s,v)</script><p>其中$s,x,y,z$是实数，$i,j,k$为虚数单位，$v$为虚部向量，且有</p><ul><li><p>$i^2=j^2=ijk=-1$</p></li><li><p>$ij=-ji=k$</p></li><li><p>$jk=-kj=i$</p></li><li><p>$ki=-ik=j$</p></li></ul><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><script type="math/tex; mode=display">\begin{align}q_a &= s_a+x_ai+y_aj+z_ak\\q_b &= s_b+x_bi+y_bj+z_bk\\q_a+q_b &=s_a+s_b+(x_a+x_b)i+(y_a+y_b)j+(z_a+z_b)k\end{align}</script><h4 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h4><script type="math/tex; mode=display">\begin{align}q_aq_b &= (s_a+x_ai+y_aj+z_ak)(s_b+x_bi+y_bj+z_bk)\\&= i(s_ax_b+s_bx_a+y_az_b-y_bz_a)\\&+ j(s_ay_b+s_by_a-x_az_b+x_bz_a)\\&+ k(s_az_b+s_bz_a+x_ay_b-x_by_a)\\&+ s_as_b-x_ax_b-y_ay_b-z_az_b\\&= (s_ab_a-q_{av}\cdot q_{bv},q_{av}\times q_{bv}+s_aq_{av}+s_bq_{bv})\end{align}</script><p>标量乘法：$tq=(ts,tv)$</p><h4 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h4><script type="math/tex; mode=display">q^\ast=(s,-v)</script><h4 id="欧几里得范数"><a href="#欧几里得范数" class="headerlink" title="欧几里得范数"></a>欧几里得范数</h4><script type="math/tex; mode=display">\begin{align}\lVert q\rVert &= \sqrt{qq^\ast}=\sqrt{q^\ast q}\\&=\sqrt{s^2+v^2+0i+0j+0k}\\&=\sqrt{s^2+x^2+y^2+z^2}\end{align}</script><p>两个四元数乘积的模等于模的乘积，即</p><script type="math/tex; mode=display">\lVert q_aq_b\rVert=\lVert q_a\rVert \lVert q_b\rVert</script><p><em>直接展开即可证明，因为计算量较大，此处不进一步证明</em></p><h4 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h4><p>定义单位四元数$I$满足$\lVert I\rVert=1$，四元数的逆满足$q^{-1}q=qq^{-1}=I$，则四元数的逆可以表示为</p><script type="math/tex; mode=display">q^{-1}=\frac{q^\ast}{qq^\ast}=\frac{q^\ast}{(\lVert q\rVert)^2}</script><hr><h3 id="用四元数表示旋转"><a href="#用四元数表示旋转" class="headerlink" title="用四元数表示旋转"></a>用四元数表示旋转</h3><h4 id="旋转满足的条件"><a href="#旋转满足的条件" class="headerlink" title="旋转满足的条件"></a>旋转满足的条件</h4><p>对于特定的旋转轴和旋转角度：函数$Rotate_Q(P,\theta)=\phi(P)$映射满足一下条件</p><ul><li>向量长度不变：</li></ul><script type="math/tex; mode=display">\lVert \phi(P)\rVert=\lVert P\rVert\tag{I}</script><ul><li>向量间夹角不变：</li></ul><script type="math/tex; mode=display">\phi(P_1)\cdot\phi(P_2)=P_1\cdot P_2\tag{II}</script><ul><li>惯用手不变：</li></ul><script type="math/tex; mode=display">\phi(P_1)\times\phi(P_2)=P_1\times P_2\tag{III}</script><blockquote><p>$tips$: 惯用手不变的性质保证了旋转的方向，否则向量可能会逆转更大的角度到达目标位置</p></blockquote><p>扩展函数$\phi$使其成为从四元数到自身的映射：</p><script type="math/tex; mode=display">\phi(s+P)=s+\phi(P)\tag{IV}</script><p>利用笛卡尔坐标系中的的向量$P$建立实数部为$0$的四元数$P^\prime=(0,P)$，则可以有</p><script type="math/tex; mode=display">\begin{align}\phi(P_1^\prime P_2^\prime) &= \phi(P_1\times P_2-P_1\cdot P_2)\\&= -P_1\cdot P_2+\phi(P_1\times P_2)\tag{reference IV}\\&= -\phi(P_1)\cdot\phi(P_2)+\phi(P_1)\times\phi(P_2)\tag{reference II and III}\\&= \phi(P_1^\prime)\phi(P_2^\prime)\end{align}</script><p>所以建立条件等式$V$替换$II,III$</p><script type="math/tex; mode=display">\phi(P_1^\prime P_2^\prime)=\phi(P_1^\prime)\phi(P_2^\prime)\tag{V}</script><h4 id="四元数旋转条件证明"><a href="#四元数旋转条件证明" class="headerlink" title="四元数旋转条件证明"></a>四元数旋转条件证明</h4><blockquote><p>$tips$ 有些资料可能会重用$P$表示点$P$的构成的实部为$0$的四元数，这里采用符号$P^\prime$，上面的条件也需要改变</p></blockquote><p>接下来证明函数$\phi_q$满足条件$I,V$</p><script type="math/tex; mode=display">\phi_q(P^\prime)=qP^\prime q^{-1}</script><script type="math/tex; mode=display">\begin{align}I:\lVert\phi_q(P^\prime) \rVert &=\lVert qP^\prime q^{-1}\rVert\\&= \lVert q\rVert\lVert P^\prime\rVert\lVert q^{-1}\rVert\\&= \lVert P^\prime \rVert\lVert qq^{-1}\rVert\\&= \lVert P^\prime\rVert\end{align}</script><script type="math/tex; mode=display">\begin{align}V:\phi_q(P_1^\prime P_2^\prime) &= qP_1^\prime P_2^\prime q^{-1}\\&= qP_1^\prime q^{-1}qP_1^\prime q^{-1}\\&= \phi(P_1^\prime)\phi(P_2^\prime)\end{align}</script><p>只要找到一个$q$对应于绕旋转轴$Q$旋转$\theta$度，则有$Rotate_Q(P,\theta)\equiv\phi_q(P^\prime)$</p><hr><h3 id="解-phi-q-P-prime"><a href="#解-phi-q-P-prime" class="headerlink" title="解$\phi_q(P^\prime)$"></a>解$\phi_q(P^\prime)$</h3><p>设单位四元数（$\lVert q\rVert=1$）$q=(s,V)$，则</p><script type="math/tex; mode=display">\begin{align}\phi_q(P^\prime) &= qP^\prime q^{-1}\\&= (s+V)P^\prime\frac{q^\ast}{(\lVert  q\rVert)^2}\\&= (s+V)P^\prime(s-V)\\&= (-V\cdot P+(V\times P+sP))(s-V)\\&= (-V\cdot P)s-(V\times P+sP)\cdot(-V)\\&+ (V\times P+sP)\times(-V)+(-V\cdot P)(-V)+s(V\times P+sP)\\&= -s(V\cdot P)+(V\times P)\cdot V+s(P\cdot V)\\&- V\times P\times V-s(P\times V)+VV^TP+s(V\times P)+s^2P\\&= -V\times P\times V+2s(V\times P)+VV^TP+s^2P\end{align}</script><p>前面较复杂的部分都是四元数乘法，化简部分较为复杂，下面是需要主要的点</p><ul><li><p>$(P\cdot V)V=VV^TP$</p></li><li><p>$(V\times P)\cdot P=0$</p></li><li><p>$P\times V=-V\times P$</p></li></ul><p>直接对$V\times P\times V$展开</p><script type="math/tex; mode=display">\begin{align}&i\ ((V_y^2+V_z^2)P_x-V_xV_yP_y-V_xV_zP_z)\\&j\ (-V_xV_yP_y+(V_x^2+V_z^2)P_y-V_yV_zP_z)\\&k\ (-V_xV_zP_x-V_yV_zP_y+(V_x^2+V_y^2)P_z)\end{align}</script><p>展开为矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}(\lVert V\rVert)^2 & 0 & 0\\0 & (\lVert V\rVert)^2 & 0\\0 & 0 & (\lVert V\rVert)^2\end{matrix}\right]P-\left[\begin{matrix}V_x^2 & V_xV_y & V_xV_z\\V_xV_y & V_y^2 & V_yV_z\\V_xV_z & V_yV_z & V_z^2\end{matrix}\right]P</script><p>综上，$V\times P\times V=((\lVert V\rVert)^2I-VV^T)P$，其中$I$为单位向量</p><blockquote><p>$tips$ 已经解出了具体表达式，可以直接使用$P$而不用区分$P^\prime$</p></blockquote><p>带回得</p><script type="math/tex; mode=display">\phi_q(P)=(s^2-(\lVert V\rVert)^2)P+2s(V\times P)+2VV^TP</script><hr><h3 id="解-q"><a href="#解-q" class="headerlink" title="解$q$"></a>解$q$</h3><script type="math/tex; mode=display">Rotate_Q(P,\theta)=\cos\theta P+\sin\theta (\hat{Q}\times P)+(1-\cos\theta)\hat{Q}\hat{Q}^TP</script><script type="math/tex; mode=display">\phi_q(P)=(s^2-(\lVert V\rVert)^2)P+2s(V\times P)+2VV^TP</script><p>令$V=t\hat{Q}$($q$是单位四元数不代表$V$是单位向量)，$t$为实数</p><script type="math/tex; mode=display">\begin{align}s^2-t^2 &= \cos\theta\\2st &= \sin\theta\\2t^2 &=1-\cos\theta\end{align}</script><p>解出$s=cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><p>综上，得旋转$T=Rotate_Q(P,\theta)$可以用四元数形式表达为</p><script type="math/tex; mode=display">T=\phi_q(P)=(s^2-t^2)P+2s(t\hat{Q}\times P)+2t^2\hat{Q}\hat{Q}^TP</script><p>其中$s=\cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><hr><h4 id="aq-和-a-（-a-为非0常数）为一种旋转"><a href="#aq-和-a-（-a-为非0常数）为一种旋转" class="headerlink" title="$aq$和$a$（$a$为非0常数）为一种旋转"></a>$aq$和$a$（$a$为非0常数）为一种旋转</h4><script type="math/tex; mode=display">aqP\prime(aq)^{-1}=qP^\prime q^{-1}</script><h4 id="q-1q-2-表示先施加旋转-q-2-，然后-q-1"><a href="#q-1q-2-表示先施加旋转-q-2-，然后-q-1" class="headerlink" title="$q_1q_2$表示先施加旋转$q_2$，然后$q_1$"></a>$q_1q_2$表示先施加旋转$q_2$，然后$q_1$</h4><script type="math/tex; mode=display">q_1(q_2P^\prime q_2^{-1})q_1^{-1}=(q_11_2)P^\prime (p_1p_2)^{-1}</script><blockquote><p>$tips$ 四元数乘法具有结合律，不具有交换律</p></blockquote><hr><h3 id="矩阵表达"><a href="#矩阵表达" class="headerlink" title="矩阵表达"></a>矩阵表达</h3><p>改写$Rotate_Q(P,\theta)$</p><script type="math/tex; mode=display">I:\left[\begin{matrix}(s^2-t^2) & 0 & 0\\0 & (s^2-t^2) & 0\\0 & 0 & (s^2-t^2)\end{matrix}\right]P</script><script type="math/tex; mode=display">II:\left[\begin{matrix}0 & -2st\hat{Q}_z & 2st\hat{Q}_y\\2st\hat{Q}_z & 0 & -2st\hat{Q}_x\\-2st\hat{Q}_y & 2st\hat{Q}_x & 0\end{matrix}\right]P</script><script type="math/tex; mode=display">III:\left[\begin{matrix}2t^2\hat{Q}_x^2 & 2t^2\hat{Q}_x\hat{Q}_y & 2t^2\hat{Q}_x\hat{Q}_z\\2t^2\hat{Q}_x\hat{Q}_y & 2t^2\hat{Q}_y^2 & 2t^2\hat{Q}_y\hat{Q}_z\\2t^2\hat{Q}_x\hat{Q}_z & 2t^2\hat{Q}_y\hat{Q}_z & 2t^2\hat{Q}_z^2\end{matrix}\right]P</script><p>用四元数$q=(s,x,y,z)$改写（<em>之后会得到更为简洁的表达</em>）:</p><script type="math/tex; mode=display">\begin{align}x &= t\hat{Q}_x\\y &= t\hat{Q}_y\\z &= t\hat{Q}_z\\\end{align}</script><script type="math/tex; mode=display">x^2+y^2+z^2=t^2(\lVert\hat{Q}\rVert)^2=t^2</script><p>因为$q=I$（单位四元数），所以$s^2+x^2+y^2+z^2=1$</p><p>替换后可得最终表达</p><script type="math/tex; mode=display">\phi_q(P)=\left[\begin{matrix}1-2y^2-2z^2 & 2xy-2sz & 2xz+2sy\\2xy+2sz & 1-2x^2-2z^2& 2yz-2sx\\2xz-2sy& 2yz+2sx & 1-2x^2-2y^2\end{matrix}\right]</script><p>为了完整性，再补充$s=\cos\frac{\theta}{2},t=\sin\frac{\theta}{2}$</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;绕坐标轴旋转&quot;&gt;&lt;a href=&quot;#绕坐标轴旋转&quot; class=&quot;headerlink&quot; title=&quot;绕坐标轴旋转&quot;&gt;&lt;/a&gt;绕坐标轴旋转&lt;/h3&gt;&lt;p&gt;考虑在$XOY$平面上的二维旋转：$P$沿逆时针旋转$&#92;theta$角度得$P^&#92;prime$&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>环境贴图</title>
    <link href="http://example.com/2024/11/04/environment-Mapping/"/>
    <id>http://example.com/2024/11/04/environment-Mapping/</id>
    <published>2024-11-04T09:17:55.000Z</published>
    <updated>2024-11-04T10:04:05.652Z</updated>
    
    <content type="html"><![CDATA[<p>环境贴图是一种用于模拟光滑表面反射周围环境的技术。它通常用于创建金属、水面、玻璃等材质的反射效果。环境贴图通过将环境映射到一个球体、立方体或其他几何形状上，然后将这些环境信息赋予物体表面，来实现反射效果。</p><hr><h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>天空盒是实现环境贴图的一种技术，它是</p><ul><li><p>在场景中一个立方体对象，每个面内侧都贴有纹理贴图</p></li><li><p>天空盒对象围住场景所有对象，理论上，其顶点离所有对象无限远</p></li></ul><h3 id="在光栅成像中实现"><a href="#在光栅成像中实现" class="headerlink" title="在光栅成像中实现"></a>在光栅成像中实现</h3><p>实现<strong>无限远</strong>只需要在可见性判定上处理</p><ol><li>保证天空盒对象包围住相机</li><li>禁用深度测试并渲染天空盒</li><li>开启深度测试渲染其他对象</li></ol><p>因为深度测试中的初始值为无线深，先渲染的天空盒对于其他物体都是无穷远的</p><h3 id="在光线追踪中实现"><a href="#在光线追踪中实现" class="headerlink" title="在光线追踪中实现"></a>在光线追踪中实现</h3><p>不需要建立对象，使用<strong>背景函数</strong>，它接受光线的方向向量</p><p>若一个对象从视体边界射出，从背景函数中查找对象的$RGBA$</p><hr><h3 id="光泽效果"><a href="#光泽效果" class="headerlink" title="光泽效果"></a>光泽效果</h3><ul><li><p>在光线追踪程序中，增加环境项即可</p></li><li><p>在光栅成像程序中，利用观察方向相对于法线的反射方向去查询环境映射的颜色值，简单来讲，<strong>反射光线求交</strong></p></li></ul><hr><h3 id="穹顶"><a href="#穹顶" class="headerlink" title="穹顶"></a>穹顶</h3><p>相比天空盒，穹顶不会存在边界缝隙，但是可能存在图像扭曲</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境贴图是一种用于模拟光滑表面反射周围环境的技术。它通常用于创建金属、水面、玻璃等材质的反射效果。环境贴图通过将环境映射到一个球体、立方体或其他几何形状上，然后将这些环境信息赋予物体表面，来实现反射效果。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;天空盒&quot;&gt;&lt;a href=&quot;#天空</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>阴影贴图</title>
    <link href="http://example.com/2024/11/04/Shadow-Mapping/"/>
    <id>http://example.com/2024/11/04/Shadow-Mapping/</id>
    <published>2024-11-04T06:55:03.000Z</published>
    <updated>2024-11-04T09:16:43.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阴影贴图是一种用于在三维场景中渲染动态阴影的技术。它基于光线的视角来生成深度信息，这些信息随后用于确定场景中的哪些部分处于阴影中。</p></blockquote><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><blockquote><p>阴影贴图技术是基于这样的认知：直接光照不能覆盖到的区域都在阴影中。这个判定只能产生<strong>硬阴影</strong></p></blockquote><h4 id="光源空间的转换"><a href="#光源空间的转换" class="headerlink" title="光源空间的转换"></a>光源空间的转换</h4><p>从<strong>光源主视角</strong>来观察场景。场景中的所有物体都需要根据光源的位置和方向进行转换，以确定它们在光源视角下的位置。</p><p>也就是说，需要<strong>光源的视图变换矩阵</strong>$V_{Light}$，其中观察方向$G-E$等价于主视角</p><h3 id="深度图的生成"><a href="#深度图的生成" class="headerlink" title="深度图的生成"></a>深度图的生成</h3><p>在光源视角下，渲染器会渲染场景的深度信息， <strong>深度贴图</strong>的每个像素代表了从光源到场景中<strong>最近表面的距离</strong>。<br>这个过程和使用相机渲染唯一的不同</p><ul><li><p>使用$V_{Light}$而非$V_{cerama}$</p></li><li><p>只需要完成可见面判定</p></li></ul><blockquote><p>$tips$ 可见面判定和着色通常一起进行，不过从光源处渲染不需要着色</p></blockquote><h3 id="场景的正常渲染"><a href="#场景的正常渲染" class="headerlink" title="场景的正常渲染"></a>场景的正常渲染</h3><p>渲染器从摄像机视角渲染场景，并在渲染每个像素时执行一个额外的步骤：<strong>确定这个像素在光源视角下的深度</strong>。</p><p>具体的说，如果一个点$(x^\prime,y^\prime,z^\prime,w)$可见，但是还不能直接着色，需要判定<strong>光源是否可见</strong></p><p>而光源是否可见又是一个<strong>可见面判定问题</strong>，再一次对<strong>世界坐标下的点</strong>$(x,y,z)$使用变换$M_L$，然后判定<strong>光源可见</strong></p><script type="math/tex; mode=display">for\ each((x^\prime,y^\prime,z^\prime,w))</script><script type="math/tex; mode=display">if\ Depth_C[(x^\prime,y^\prime,z^\prime,w)]>-z^\prime==false\ continue</script><script type="math/tex; mode=display">Depth_C[(x^\prime,y^\prime,z^\prime,w)]=-z^\prime</script><script type="math/tex; mode=display">if\ Depth_L[M_L\cdot(x,y,z,1)^T]\approx Depth_C[(x^\prime,y^\prime,z^\prime,w)]\ Shadow</script><blockquote><p>最后一行伪代码就是含有阴影贴图的时，相机着色新增的判定</p><p>前三行代码为光源的$Depth_L$生成</p></blockquote><p>多光源时，对于场景中的每个像素，需要为场景中的每个光源执行阴影测试，只要能不被任何光源照到，就会产生阴影</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;阴影贴图是一种用于在三维场景中渲染动态阴影的技术。它基于光线的视角来生成深度信息，这些信息随后用于确定场景中的哪些部分处于阴影中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>齐次空间裁剪[2]</title>
    <link href="http://example.com/2024/11/04/Homogeneous-Space-Clipping-[2]/"/>
    <id>http://example.com/2024/11/04/Homogeneous-Space-Clipping-[2]/</id>
    <published>2024-11-03T16:46:11.000Z</published>
    <updated>2024-11-04T05:25:07.767Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在上半篇中，得出了以下结果：</p><ul><li><p><strong>在齐次空间的标准视体下的流水选位置裁剪</strong></p></li><li><p>快速获取<strong>顶点关于六个视体表面的相对位置</strong></p></li></ul><p>如果简单的把不在视体内的顶点去掉，或者由此引发的，把相关图元去掉，会生成明显的不连续边缘</p><p>这里的统一做法为使用各种<strong>插值方法生成边缘顶点</strong></p><hr><h3 id="裁剪线段"><a href="#裁剪线段" class="headerlink" title="裁剪线段"></a>裁剪线段</h3><p>线段$AB$和标准视体的位置关系可以划分为</p><ol><li>线段完全在视体<strong>内部</strong>：端点$A,B$的都在视体内</li><li>线段完全在实体<strong>外部</strong>：端点$A,B$在视体外且<strong>区域码相同</strong></li><li>线段部分和视体<strong>表面相交</strong></li></ol><p>如果线段$AB$不满足情况$1,2$，则只需要端点$A,B$的特定区域码位不同，就可以断言：线段穿过该区域码对应的视体表面所在的<strong>平面</strong></p><h3 id="Cyus-Beck-裁剪算法"><a href="#Cyus-Beck-裁剪算法" class="headerlink" title="$Cyus-Beck$裁剪算法"></a>$Cyus-Beck$裁剪算法</h3><p>对端点$A(x_A,y_A,z_A,w_A)$和$B(x_B,y_B,z_B,w_B)$组队的线段$AB$有参数线段方程</p><script type="math/tex; mode=display">P(u)=uB+(1-u)A,0\le u\le 1</script><p>展开为</p><script type="math/tex; mode=display">\begin{align}P(u)_x &= ux_B+(1-u)x_A\\P(u)_y &= uy_B+(1-u)y_A\\P(u)_z &= uz_B+(1-u)z_A\\P(u)_w &= uw_B+(1-u)w_A\end{align}</script><p>比如，若线段$AB$已经和视体<strong>右表面</strong>所在的平面$\frac{X}{W}=1$相交，则有方程</p><script type="math/tex; mode=display">\frac{ux_B+(1-u)x_A}{uw_B+(1-u)w_A}=1</script><p>获得交点坐标后，只需要判定<strong>点在平面内部</strong>就可以得到线段未穿过视体表面，得到线段与视体表面的<strong>交点</strong></p><p>在后一种情况，需要裁剪线段，需要用<strong>交点</strong>替换在视体<strong>表面外侧端点</strong></p><p>为了更加简化过程，使用<strong>奇偶规则</strong>把情况$3$划分为：</p><ul><li><p>其中一个端点在视体内：必定裁剪一次</p></li><li><p>两个端点都在外部：一次都不裁剪，或者裁剪两次</p></li></ul><hr><blockquote><p>$tips$ 有处理<strong>凹多边形</strong>裁剪的算法，不过在三维空间中只需要使用一次凹分解</p></blockquote><h2 id="Sutherland-Hodgman-凸多边形裁剪"><a href="#Sutherland-Hodgman-凸多边形裁剪" class="headerlink" title="$Sutherland-Hodgman$凸多边形裁剪"></a>$Sutherland-Hodgman$凸多边形裁剪</h2><blockquote><p>$Sutherland-Hodgman$算法又叫做逐边裁剪算法.该算法的基本思想是逐边处理裁剪窗口和多边形。具体来说，算法将多边形的每条边与裁剪窗口的每条边进行比较，根据边的相对位置关系，决定是否输出顶点或交点。</p></blockquote><p>多边形和视体之间的位置关系可以由线段与视体的位置关系扩展</p><p><strong>依次使用六个视体表面所在的平面切割三角形，保留表面内的部分，最后的保留部分就是所需的凸多边形</strong></p><p>算法的正确性不言而喻，</p><ol><li>切割面是平整的，不会产生<strong>凹角</strong></li><li>六个平面内部构成的封闭空间就是标准视体</li></ol><h3 id="平面裁剪"><a href="#平面裁剪" class="headerlink" title="平面裁剪"></a>平面裁剪</h3><p>可以将多边形表示为有序的顶点序列，在转换为的线段（有序顶点对）序列。若$(P_0,P_1,P_2,P_3)$表示由线段$(P_0,P_1),(P_1,P_2),(P_2,P_3),(P_3,P_0)$构成的凸四边形</p><p>考虑线段$(A,B)$与平面的位置的情况</p><ul><li><p>完全在<strong>平面外侧</strong>：直接去掉</p></li><li><p>和<strong>平面相交</strong>：将外侧点替换为交点，注意点序不可更改</p></li><li><p>完全在<strong>平面</strong>内侧：保留顶点</p></li></ul><blockquote><p>$tips$ 这里是线段与平面求交，而非<strong>表面</strong>，纵使交点不在表面上，可能在另一个视体表面外侧，也保留，因为另一个表面所在的平面会再一次裁剪</p></blockquote><p><img src="https://s2.loli.net/2024/11/04/UsfOgGF8Hl4hNpk.png" alt=""></p><script type="math/tex; mode=display">\begin{align}(P_0,P_1) &\to (P_0^\prime,P_1)\\(P_1,P_2) &\to (P_1,P_2)\\(P_2,P_3) &\to (P_2,P_3^\prime)\\(P_3,P_0) &\to \emptyset\end{align}</script><p>若不相交，则所有线段转化为$\emptyset$</p><h3 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h3><p>切割出的线段序列不能组装成<strong>封闭</strong>多边形，但是切割过程和划分过程保证了</p><p>重组后的多边形：<strong>线段的后一个顶点是下一个线段的前一个顶点</strong>，遍历一次就可以重新组装为</p><script type="math/tex; mode=display">(P_0^\prime,P_1),(P_1,P_2),(P_2,P_3^\prime),(P_3^\prime,P_0^\prime)</script><p>标准的$Sutherland-Hodgman$算法需要区分射入和射出，输入线段，输出顶点序列表示多边形</p><script type="math/tex; mode=display">\begin{align}(P_0,P_1) &\to P_0^\prime\\(P_1,P_2) &\to P_1\\(P_2,P_3) &\to (P_2,P_3^\prime)\\(P_3,P_0) &\to \emptyset\end{align}</script><script type="math/tex; mode=display">(P_0^\prime,P_1,P_2,P_3^\prime)</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在上半篇中，得出了以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在齐次空间的标准视体下的流水选位置裁剪&lt;/stron</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>齐次空间裁剪[1]</title>
    <link href="http://example.com/2024/11/03/Homogeneous-Space-Clipping[1]/"/>
    <id>http://example.com/2024/11/03/Homogeneous-Space-Clipping[1]/</id>
    <published>2024-11-03T11:05:31.000Z</published>
    <updated>2024-11-04T03:58:49.811Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><blockquote><p>裁剪是指在渲染场景之前，将位于摄像机视野之外的物体或者被其他物体遮挡的部分移除的过程。这样可以提高渲染效率，因为不需要绘制最终不会出现在屏幕上的物体。</p></blockquote><p>裁剪需要满足以下条件</p><ul><li><p><strong>确定场景</strong>：不会再发生<strong>顶点变换</strong>，否则可能会把场景内的点裁剪掉</p></li><li><p><strong>确定视域</strong>：引入相机参数后，在投影变换前，它是一个<strong>四棱台</strong>，之后是正方体（<strong>规范化</strong>）</p></li></ul><h3 id="图像流水线"><a href="#图像流水线" class="headerlink" title="图像流水线"></a>图像流水线</h3><p>按照<strong>场景对象</strong>表现形式的不同，图形流水线可以分为三个阶段：世界坐标系，相机坐标系，齐次空间，屏幕空间</p><p><img src="https://s2.loli.net/2024/11/03/f91hQqvpOGxNklR.png" alt=""></p><h4 id="世界坐标系"><a href="#世界坐标系" class="headerlink" title="世界坐标系"></a>世界坐标系</h4><ol><li>模型可以被添加到世界坐标系中，组成场景</li><li>可能会有<strong>顶点变换</strong></li></ol><blockquote><p>$tips$ 虽然只说明了顶点变换，如果模型顶点存在法线，需要做<strong>法线变换</strong></p></blockquote><h4 id="相机坐标系"><a href="#相机坐标系" class="headerlink" title="相机坐标系"></a>相机坐标系</h4><ol><li>将场景的世界坐标转换为相机坐标系的表达</li><li>可能存在<strong>顶点变换</strong></li></ol><blockquote><p>$tips$ 尽管这里场景对象可能没有变换，不过这会是<strong>裁剪</strong>可能发生的位置</p></blockquote><h4 id="齐次空间"><a href="#齐次空间" class="headerlink" title="齐次空间"></a>齐次空间</h4><ol><li>对相机坐标系的场景做投影变换</li><li>规范化</li></ol><h4 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><ol><li>将规范视体投影到屏幕</li><li>可见面判定算法<strong>剔除</strong></li></ol><hr><h3 id="裁剪可能发生的位置"><a href="#裁剪可能发生的位置" class="headerlink" title="裁剪可能发生的位置"></a>裁剪可能发生的位置</h3><blockquote><p>$tips$ 如果保证不在相机坐标系下做<strong>顶点变换</strong>，则可以在世界坐标系下做变换，不过视域需要相机对象，在这个阶段只会有更多限制</p></blockquote><h4 id="相机坐标系-1"><a href="#相机坐标系-1" class="headerlink" title="相机坐标系"></a>相机坐标系</h4><p>在相机坐标系下，做完可能的<strong>顶点变换</strong>，看可以确定视域，它是由以下六个顶点组成的<strong>四棱台</strong></p><script type="math/tex; mode=display">(l,b,-n),(r,b,-n),(l,t,-n),(r,t,-n)</script><script type="math/tex; mode=display">(l,b,-f),(r,b,-f),(l,t,-f),(r,t,-f)</script><p>这六个表明并不规整</p><h4 id="屏幕空间-1"><a href="#屏幕空间-1" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><p>这个阶段得到了规范化视体，可以更简洁的表达视域，不过投影变换会带来问题</p><script type="math/tex; mode=display">Z^\prime=\frac{(n+f)Z+nf}{-Z}</script><p>如果顶点本来就在视域内，$Z^\prime$的推导过程证明不会存在问题</p><p>但是一个可能存在的裁剪点靠近$Z=0$相机所在的$Z$平面时，投影变换会把它会从平面一侧变换到平面另一侧</p><hr><h2 id="齐次空间裁剪"><a href="#齐次空间裁剪" class="headerlink" title="齐次空间裁剪"></a>齐次空间裁剪</h2><p>场景世界坐标$(x,y,z,1)$经过变换$M$后成为齐次形式$(x^\prime,y^\prime,z^\prime,-z)$</p><script type="math/tex; mode=display">\left[\begin{matrix}x^\prime\\\\y^\prime\\\\z^\prime\\\\-z\end{matrix}\right]=M\cdot\left[\begin{matrix}x\\\\y\\\\z\\\\1\end{matrix}\right]</script><p>其中$M$按正确顺序组合<strong>顶点变换，视图变换，投影变换，规范化</strong>的变换矩阵，也就是再对坐标标准化就得到了<strong>屏幕空间</strong></p><blockquote><p>$tips$ 这里的$z\prime$符号可能存在复用，$z^\prime\ne \frac{(n+f)z+nf}{-z},z^\prime=(n+f)z+nf$</p></blockquote><p>齐次空间下的<strong>视域</strong>也需要四维表示，将齐次坐标第四维$-z$定义为$W$， 则特定顶点$(x,y,z,w)$可以得到判定式</p><script type="math/tex; mode=display">\begin{align}-1\le\frac{x}{w}\le 1\\\\-1\le\frac{y}{w}\le 1\\\\-1\le\frac{z}{w}\le 1\end{align}</script><blockquote><p>$tips$ 这里使用的标准视体为$[-1,1]^3$</p></blockquote><p>这里也说明了之前在齐次坐标除$W$后存在的问题，<strong>不能假定</strong>$W$为正（这里排除非法的$w=0$）</p><p>对应的视域为由以下六个顶点组成的<strong>四棱台</strong></p><script type="math/tex; mode=display">(-w,-w,w,w),(-w,w,w,w),(w,-w,w,w),(w,w,w,w)</script><script type="math/tex; mode=display">(-w,-w,-w,w),(-w,w,-w,w),(w,-w,-w,w),(w,w,-w,w)</script><hr><h2 id="三维区域码"><a href="#三维区域码" class="headerlink" title="三维区域码"></a>三维区域码</h2><blockquote><p><strong>三维区域码</strong>表示三维空间中的物体相对于视体位置的一种编码方法。在三维图形的渲染过程中，区域码用于快速判断一个物体或物体的部分是否在视体内</p><p>$tips$ 下面的不太严谨的方位描述都是<strong>相对于相机视角</strong>而言，如图所示</p></blockquote><p>点$(-1,-1,-1),(-1,-1,1),(-1,1,-1),(-1,1,1)$所在平面可能不是<strong>齐次坐标下视体面</strong>所在的平面，因为$w$是未知的，不能假定它的正负</p><p><img src="https://s2.loli.net/2024/11/04/4nuESaMBiq8vUhC.png" alt=""></p><hr><h3 id="构建三维区域码"><a href="#构建三维区域码" class="headerlink" title="构建三维区域码"></a>构建三维区域码</h3><blockquote><p>三维区域面码可以一定程度缓解$w$的不确定性带来的复杂性</p></blockquote><p>忽略点恰好在视体面上的特殊情况，如果只考虑点和视体的关系，则一个点关于一个视体面需要一种<strong>布尔属性</strong>，<strong>是否在表明内一侧</strong></p><blockquote><p>$tips$ 平面的内外通常由平面法线计算的方式决定，不过这里不用考虑太多细节，简单将平面内定义为视体空间一侧</p></blockquote><p>综上，考虑$w&gt;0$可得到一种三维区域码(区域码会因构建的方式有不同的表达)的表示</p><blockquote><p>$tips$ 复用符号$(x,y,z,w)$指顶点的齐次坐标</p></blockquote><script type="math/tex; mode=display">\begin{align}bool_0 &= -w\le x\tag{左}\\bool_1 &= x\le w\tag{右}\\bool_2 &= -w\le y\tag{下}\\bool_3 &= y\le w\tag{上}\\bool_4 &= -w\le z\tag{后}\\bool_4 &= z\le w\tag{前}\\\end{align}</script><p>如果顶点的某一码值为$true$，则表示顶点在这个表明的<strong>内部</strong>，而组合所有码值，就可以表示<strong>被六个视体表面所切割出的</strong>$9\times 3$<strong>个区域</strong></p><p><img src="https://s2.loli.net/2024/11/04/x24vZ5SUJGnDENF.png" alt=""></p><blockquote><p>每一块区域都有唯一的区域码与之对应，可以精确定位顶点的相对位置</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;裁剪&quot;&gt;&lt;a href=&quot;#裁剪&quot; class=&quot;headerlink&quot; title=&quot;裁剪&quot;&gt;&lt;/a&gt;裁剪&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;裁剪是指在渲染场景之前，将位于摄像机视野之外的物体或者被其他物体遮挡的部分移除的过程。这样可以提高渲染效</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契堆</title>
    <link href="http://example.com/2024/11/02/Fibonacci-Heap/"/>
    <id>http://example.com/2024/11/02/Fibonacci-Heap/</id>
    <published>2024-11-02T02:35:34.000Z</published>
    <updated>2024-11-04T15:05:19.543Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><blockquote><p>势能分析是用于分析数据结构操作摊销成本的一种技术。它是一种建立在势能函数基础上的分析方法，通过引入势能函数来跟踪操作的<strong>累积成本</strong>，并将这个累积成本<strong>分摊</strong>到每个操作上，从而得到每个操作的摊销成本</p></blockquote><p><strong>势能</strong>是和整个<strong>数据结构</strong>关联而非特定操作，对数据结构$D$的操作引起势能的变换</p><ul><li><strong>势能函数</strong>$\Phi(D)$：势能函数是一种用来衡量数据结构当前状态的函数。通常，这个函数会根据数据结构中的一些特定属性（如节点的数量、树的深度等）来定义。</li></ul><p>定义对数据结构的每一次操作$i$有：</p><ul><li><p><strong>势能成本</strong>$\Phi(D_i)-\Phi(D_{i-1})$：数据结构在进行操作时的潜在成本，它通常与数据结构的当前状态有关。</p></li><li><p><strong>实际成本</strong>$c_i$：执行一个操作时的即时成本。</p></li><li><p><strong>摊还成本</strong>$\hat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})$：将实际成本和势能变化结合起来</p></li></ul><p>定义初始数据结构$D_0$的势能$\Phi(D_0)=0$，则进行$N$次操作后的总摊还成本</p><script type="math/tex; mode=display">\begin{align}\sum_{i=0}^N\hat{c_i} &= \sum_{i=0}^N(c_i+\Phi(D_i)-\Phi(D_{i-1}))\\\\&= \sum_{i=0}^Nc_i+\Phi(D_N)\end{align}</script><p>因此，只要最后的数据结构势能$\Phi(D_N)$不为负，就可以得到执行$N$次操作代价上界</p><p>更具有普遍性的结论，势能函数满足$\Phi(D)\ge0$</p><hr><h2 id="斐波那契堆结构"><a href="#斐波那契堆结构" class="headerlink" title="斐波那契堆结构"></a>斐波那契堆结构</h2><blockquote><p>一个斐波那契堆是一系列<strong>多叉堆</strong>的集合</p></blockquote><p>为了满足<strong>多分叉，不定分叉</strong>，同二叉堆不同，不使用$left,right$属性将子节点链接，斐波那契节点使用$son$属性链接任意一个子节点，每个节点使用额外的$left,right$链接左右兄弟节点，便于实现，首尾子节点也链接</p><p>直观的讲，<strong>多叉堆</strong>中节点的<strong>子节点使用双链表储存</strong></p><p><img src="https://s2.loli.net/2024/11/02/QGIKjdWsZy7qpHm.png" alt=""></p><p>所以一个斐波那契堆节点$x$具有以下属性</p><ul><li><p>键值对$(val,key)$</p></li><li><p>$son,parent$指针</p></li><li><p>$left,right$左右兄弟节点</p></li><li><p>$mark$<strong>标记</strong>：节点至上一次成为另一个节点的孩子后，是否失去过节点。</p></li><li><p>$degree$度数：节点的子节点数量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><em>后两个属性保持了复杂度度</em></p><p>斐波那契堆维护<strong>父子节点规则</strong></p><script type="math/tex; mode=display">\begin{align}Node\ parent.key\circ Node,key=true\\\\Node.eky\circ each\ Node\ son.key=true\end{align}</script><h3 id="Root-指针"><a href="#Root-指针" class="headerlink" title="$Root$指针"></a>$Root$指针</h3><p>因为<strong>一个斐波那契堆是多叉堆的集合</strong>，为了快速找出所有堆范围下的首序元素，将这些堆根节点也链接起来，$Root$指针指向特定一个根堆</p><script type="math/tex; mode=display">Root.son\circ otehr\ bothers=true</script><p>即$Root$所指节点是多叉堆堆根的首序节点，换句话说，$Root$指向斐波那契堆的首序节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="势能函数"><a href="#势能函数" class="headerlink" title="势能函数"></a>势能函数</h3><p>$def$斐波那契堆$H$的势能函数</p><script type="math/tex; mode=display">\Phi(H)=t(H)+2m(H)</script><p>其中$t(H)$为集合中多叉堆的数量，即$Size(Root.son)$，$m(H)$为<strong>标记节点</strong>的数量</p><h3 id="最大度数"><a href="#最大度数" class="headerlink" title="最大度数"></a>最大度数</h3><p>$def\ D(n)$表示$n$个节点的斐波那契堆中的<strong>任何节点的最大度数</strong></p><p>根据定义保证了$D(n) &lt; n$，不过斐波那契堆的性质会保证$D(n)\le \lfloor\lg n\rfloor$</p><hr><h2 id="斐波那契堆操作"><a href="#斐波那契堆操作" class="headerlink" title="斐波那契堆操作"></a>斐波那契堆操作</h2><h3 id="创建斐波那契堆"><a href="#创建斐波那契堆" class="headerlink" title="创建斐波那契堆"></a>创建斐波那契堆</h3><p>只需要创建一个$Root$指针指向为$nullotr$</p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>在斐波那契堆中的多叉堆集合中加入一个，由单个节点组成的多叉堆</p><p>这也指明了该如何<strong>初始化</strong>斐波那契堆中除了$Root$以外的<strong>节点</strong></p><blockquote><p>$tips$ $mark$标记属性依照定义，初始化为$false$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="插入实现"><a href="#插入实现" class="headerlink" title="插入实现"></a>插入实现</h4><p>多叉堆堆顶无父节点$parent$，并且它的兄弟一定为$Root$指针指向的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_insert_X_to_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root), ++n; &#125;</span><br></pre></td></tr></table></figure><p>其中<code>s_insert_X_to_Y_infer_W</code>表示将<strong>节点</strong>$X$插入为节点$Y$的子节点，$W$为$Y$的其中一个儿子的<strong>引用</strong></p><blockquote><p>$tips$ 下面的代码展示了链表的实现细节，$W$传引用方便更改斐波那契堆属性$Root$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_X_to_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">++Y-&gt;degree;</span><br><span class="line">X-&gt;parent = Y;</span><br><span class="line"><span class="keyword">if</span> (!W) &#123;</span><br><span class="line">W = X;</span><br><span class="line">X-&gt;left = X-&gt;right = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">X-&gt;left = W;</span><br><span class="line">X-&gt;right = W-&gt;right;</span><br><span class="line">W-&gt;right-&gt;left = X;</span><br><span class="line">W-&gt;right = X;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="势能分析-1"><a href="#势能分析-1" class="headerlink" title="势能分析"></a>势能分析</h4><script type="math/tex; mode=display">\begin{align}\hat{c} &=c+\Phi(H^\prime)-\Phi(H)\\\\&=O(1)+(t(H)+1+2m(H))-(t(H)+2m(H))\\\\&=O(1)\end{align}</script><hr><h2 id="弹出首序节点"><a href="#弹出首序节点" class="headerlink" title="弹出首序节点"></a>弹出首序节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* X = Root;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;son)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X-&gt;son-&gt;right, X, X-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line"><span class="built_in">s_erase_X_from_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root);</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">if</span> (Root)</span><br><span class="line"><span class="built_in">s_adjust_pop</span>();</span><br><span class="line"><span class="keyword">return</span> X-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整体步骤分为两步</p><ol><li>抽取$Root$指针所指的多叉堆</li><li>调整得到的斐波那契堆<code>1s_adjust_pop();</code></li></ol><h3 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h3><p>将$Root$指针所指的多叉堆从<strong>多叉堆集合</strong>中搬离出去，再把不该被删除的节点插入回去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**抽取步骤的实际成本**为$T_1=O(D(n))$</span><br><span class="line"></span><br><span class="line">#### 代码细节</span><br><span class="line"></span><br><span class="line">这里$W$传引用依然是为了隐式改变斐波那契堆属性$Root$，在这个中不保证$Root$属性依然指向首序节点，会在调整步骤中保证</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">auto s_erase_X_from_Y_infer_W(Node* X, Node* Y, Node*&amp; W) &#123;</span><br><span class="line">if (Y)</span><br><span class="line">--Y-&gt;degree;</span><br><span class="line">if (W-&gt;right == W)</span><br><span class="line">W = nullptr;</span><br><span class="line">else &#123;</span><br><span class="line">if (W == X)</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">Node* L = X-&gt;left, * R = X-&gt;right;</span><br><span class="line">L-&gt;right = R;</span><br><span class="line">R-&gt;left = L;</span><br><span class="line">&#125;</span><br><span class="line">return X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_adjust_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;Node*&gt; <span class="title">D</span><span class="params">(floor(log10(n))<span class="number">+1</span>, <span class="literal">nullptr</span>)</span>, R</span>;</span><br><span class="line">Node* W = Root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != Root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; Y : R) &#123;</span><br><span class="line"><span class="keyword">while</span> (D[Y-&gt;degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">Node* X = D[Y-&gt;degree];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Y-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">swap</span>(Y, X);</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(X, Y, Y-&gt;son);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line">D[X-&gt;degree] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">D[Y-&gt;degree] = Y;</span><br><span class="line">&#125;</span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : D)</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(r, <span class="literal">nullptr</span>, Root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$tips$ 这里重组时，依照定义，对新的多叉堆根的$mark$属性置$false$</p></blockquote><ul><li><p><strong>第一个循环</strong>：将斐波那契堆中的多叉堆集合中的每一个索引出来</p></li><li><p><strong>第二个循环</strong>：确保了一个性质</p></li></ul><blockquote><p>新的斐波那契堆中的每一个<strong>多叉堆根的度</strong>都是唯一的</p></blockquote><ul><li>要调整的多叉堆数量最多为$O(H(t))+D(n)-1$，因为内部$while$每循环一次，都使得多叉堆数量减$1$</li></ul><p>所以第一个循环和第二个循环总实际代价为$T_2=O(D(n)+t(H))$</p><ul><li><strong>第三个循环</strong> 重构多叉堆集合，实际代价为$T_3=O(D(n))$</li></ul><h4 id="势能分析-2"><a href="#势能分析-2" class="headerlink" title="势能分析"></a>势能分析</h4><script type="math/tex; mode=display">\begin{align}\hat{c} &= c+\Phi(H^\prime)-\Phi(H)\\\\&= O(T_1+T_2+T_3)+(t(H^\prime)+2m(H^\prime))-(t(H)+2m(H))\\\\&= O(D(n)+t(H))+(O(D(n))+1+2m(H))-(t(H)+2m(H))\\\\&= O(D(n))\end{align}</script><hr><h2 id="减小变节点键值"><a href="#减小变节点键值" class="headerlink" title="减小变节点键值"></a>减小变节点键值</h2><p>同二叉堆一样，需要维护新节点的<strong>子父节点关系</strong>，不过这里还需要维护$mark$<strong>标记</strong></p><p>考虑<strong>最小堆</strong>中$key$减小，当它不符合<strong>子父节点关系</strong>时，需要上滤<strong>改变节点</strong></p><ul><li><p>如果它不是多叉堆集合中某个多叉堆的根，将它抽取出来<strong>插入多叉堆集合</strong>，然后进行<strong>级联切除</strong>，检查$Root$指针合理性</p></li><li><p>如果它是多叉堆集合中某个多叉堆的根，需要考虑的只有$Root$指针</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decl</span><span class="params">(Node* X, <span class="type">int</span> new_key)</span> </span>&#123;</span><br><span class="line">X-&gt;key = new_key;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent &amp;&amp; !<span class="built_in">com</span>(X-&gt;parent-&gt;key, new_key))</span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(X, X-&gt;parent);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, new_key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联切除"><a href="#级联切除" class="headerlink" title="级联切除"></a>级联切除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_from_Y</span><span class="params">(Node* X, Node* Y)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X, Y, Y-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;mark == <span class="literal">false</span>)</span><br><span class="line">Y-&gt;mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(Y, Y-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个节点应该被级联切除，它应该至上一次成为另一个节点的孩子后，是否失去了两个字节点，即$mark=false$</p><p>按照$mark$定义，$X$成为多叉堆根节点，置$false$，$Y$不为二叉堆根且正在失去子节点，置$true$</p><h3 id="势能分析-3"><a href="#势能分析-3" class="headerlink" title="势能分析"></a>势能分析</h3><p>记级联切除调用的次数为$s$，除了最后一次调用和切改变节点，都消除了一个$mark=true$的<strong>标记节点</strong>，所以</p><script type="math/tex; mode=display">\begin{align}t(H^\prime) &= t(H)+(s-2)+1\\\\m(H^\prime) &= m(H)-(s-2)\end{align}</script><p>所以摊还代价为</p><script type="math/tex; mode=display">\begin{align}\hat{c} &= c+\Phi(H^\prime)-\Phi(H)\\\\&= O(s)+(t(H)+s-1+2(m(H)-s+2))-(t(H)+2m(H))\\\\&= O(1)\end{align}</script><h2 id="最大度数的界"><a href="#最大度数的界" class="headerlink" title="最大度数的界"></a>最大度数的界</h2><blockquote><p>引理$1$：设节点$x$为斐波那契堆中任意节点，$x.degree=k$，设$y_1,y_2,\cdots,y_k$为$x$的子节点，按照<strong>链入先序</strong>排序,则$y_i.degree\ge i-2$</p></blockquote><ul><li><p>$i\ge 3$，当节点$y_i$链入时，$y_{1,i-1}$已经被链入，此时有$x.degree\ge i-1$，而$adjust$函数要求，只有$x.degree=y_i.degree$时，$y_i$才会被链入，所以有$y_i\ge i-1$</p></li><li><p>$y_i$被链入后最多失去一个节点，$mark$标记和<strong>级联切除</strong>保证了这一性质，否则它将被切除，$x.degree$改变</p></li></ul><blockquote><p>引理$2$：对于斐波那契数列$F_k$($k\ge 0$)，有$F_{k+2}=1+\sum_{i=0}^kF_i$</p></blockquote><p>使用数学归纳法证明</p><p>基础步：$F_{0+2}=1+F_0=F_2$</p><ul><li>归纳步，假设$F_{k+1}=1+\sum_{i=0}^{k+1}F_i$</li></ul><script type="math/tex; mode=display">\begin{align}F_{k+2} &= F_{k-1}+F_k\\\\&= 1+\sum_{i=0}^{k-1}F_i+F_k\\\\&=1+\sum_{i=0}^{k}F_i\end{align}</script><blockquote><p>引理$3$：$F_{k+2}\ge \phi^k,k\ge 0$，其中$\phi$黄金分割率是方程$I\ x^2=x+1$的正根</p></blockquote><p>使用数学归纳法证明</p><ul><li><p>基础步：$F_{0+2}=1=\phi^1$</p></li><li><p>归纳步：假设对于$i=1,2,\cdots,k-1$，有$F_{k+2}\ge \phi^k$</p></li></ul><script type="math/tex; mode=display">\begin{align}F_{k+2} &= F_{k+1}+F_k\\\\&\ge \phi^{k-1}+\phi^{k-2}\\\\&= \phi^{k-2}(\phi+1)\\\\&= \phi^{k-2}\cdot\phi^2\tag{function I}\\\\&= \phi^k\end{align}</script><blockquote><p>引理$4$：设斐波那契堆中任意节点$x,x.degree=k$，有$Size(x)\ge F_{k+2}$，其中$Size(x)$是：斐波那契堆的多叉堆集合中某个多叉堆，它有节点$x$，以$x$为根的子多叉堆的节点数量</p></blockquote><p>设$S_k$为斐波那契堆中度数$x.degree=k$的任意节点$x$的最小可能$Size$，则根据<strong>引理</strong>$1$可得</p><script type="math/tex; mode=display">Size(x) \ge S_k \ge 2+\sum_{i=2}^kS_{i-2}</script><p>使用归纳法证明$S_k\ge F_{k+2}$即可得证</p><ul><li><p>基础步：$S_0=1=F_{0+2}$</p></li><li><p>归纳步：假设对于$k=1,2,3,\dots,k-1$，有$S_k\ge F_{k+2}$成立</p></li></ul><script type="math/tex; mode=display">\begin{align}S_k &\ge 2+\sum_{i=2}^kS_{i-2}\\\\&\ge 2+\sum_{i=2}^kF_i\\\\&= 1+\sum_{i=0}^kF_i\\\\&= F_{k+2}\tag{引理2}\end{align}</script><p>即有</p><script type="math/tex; mode=display">Size(x)\ge F_{k+2}\ge\phi^k\tag{引理3}</script><p>对于有$n$个节点的斐波那契堆</p><script type="math/tex; mode=display">n\ge Size(x)\ge \phi^k</script><p>取对数得到</p><script type="math/tex; mode=display">k\le\log_{\phi}n\le \lg n</script><p>因为$k$为正整数，则$n$个节点的斐波那契中任意节点的最大度数$D(n)$满足</p><script type="math/tex; mode=display">D(n)\le \lfloor\lg n\rfloor</script><hr><h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><p><img src="https://s2.loli.net/2024/11/02/o6xs7BPY3HcaAie.png" alt=""></p><p><img src="https://s2.loli.net/2024/11/04/f5JwM3tCgBkdKNL.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_FIB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, <span class="type">int</span> key) :<span class="built_in">val</span>(val), <span class="built_in">key</span>(key) &#123;&#125;</span><br><span class="line"><span class="type">int</span> val, key, degree = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">Node* left, * right, * parent, * son = <span class="literal">nullptr</span>;<span class="comment">//插入是新节点第一个动作</span></span><br><span class="line">&#125;;</span><br><span class="line">Node* Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">function&lt;<span class="keyword">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear_forest</span><span class="params">(Node* X)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">vector&lt;Node*&gt; R;</span><br><span class="line">Node* W = X;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line"><span class="keyword">if</span> (W-&gt;son)</span><br><span class="line"><span class="built_in">s_clear_forest</span>(W-&gt;son);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != X);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : R)</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S_FIB</span>(function&lt;<span class="built_in">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com) :<span class="built_in">com</span>(com) &#123;&#125;</span><br><span class="line">~<span class="built_in">S_FIB</span>() &#123; <span class="keyword">if</span> (Root)<span class="built_in">s_clear_forest</span>(Root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_insert_X_to_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">++Y-&gt;degree;</span><br><span class="line">X-&gt;parent = Y;</span><br><span class="line"><span class="keyword">if</span> (!W) &#123;</span><br><span class="line">W = X;</span><br><span class="line">X-&gt;left = X-&gt;right = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">X-&gt;left = W;</span><br><span class="line">X-&gt;right = W-&gt;right;</span><br><span class="line">W-&gt;right-&gt;left = X;</span><br><span class="line">W-&gt;right = X;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_erase_X_from_Y_infer_W</span><span class="params">(Node* X, Node* Y, Node*&amp; W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y)</span><br><span class="line">--Y-&gt;degree;</span><br><span class="line"><span class="keyword">if</span> (W-&gt;right == W)</span><br><span class="line">W = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (W == X)</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">Node* L = X-&gt;left, * R = X-&gt;right;</span><br><span class="line">L-&gt;right = R;</span><br><span class="line">R-&gt;left = L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_adjust_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;Node*&gt; <span class="title">D</span><span class="params">(floor(log10(n))<span class="number">+1</span>, <span class="literal">nullptr</span>)</span>, R</span>;</span><br><span class="line">Node* W = Root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">R.<span class="built_in">emplace_back</span>(W);</span><br><span class="line">W = W-&gt;right;</span><br><span class="line">&#125; <span class="keyword">while</span> (W != Root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; Y : R) &#123;</span><br><span class="line"><span class="keyword">while</span> (D[Y-&gt;degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">Node* X = D[Y-&gt;degree];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Y-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">swap</span>(Y, X);</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(X, Y, Y-&gt;son);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line">D[X-&gt;degree] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">D[Y-&gt;degree] = Y;</span><br><span class="line">&#125;</span><br><span class="line">Root = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; r : D)</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(r, <span class="literal">nullptr</span>, Root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_cut_X_from_Y</span><span class="params">(Node* X, Node* Y)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X, Y, Y-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line">X-&gt;mark = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y-&gt;mark == <span class="literal">false</span>)</span><br><span class="line">Y-&gt;mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(Y, Y-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(Node* X)</span> </span>&#123; <span class="built_in">s_insert_X_to_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root), ++n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* X = Root;</span><br><span class="line"><span class="keyword">while</span> (X-&gt;son)</span><br><span class="line"><span class="built_in">s_insert_X_to_Y_infer_W</span>(<span class="built_in">s_erase_X_from_Y_infer_W</span>(X-&gt;son-&gt;right, X, X-&gt;son), <span class="literal">nullptr</span>, Root);</span><br><span class="line"><span class="built_in">s_erase_X_from_Y_infer_W</span>(X, <span class="literal">nullptr</span>, Root);</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">if</span> (Root)</span><br><span class="line"><span class="built_in">s_adjust_pop</span>();</span><br><span class="line"><span class="keyword">return</span> X-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decl</span><span class="params">(Node* X, <span class="type">int</span> new_key)</span> </span>&#123;</span><br><span class="line">X-&gt;key = new_key;</span><br><span class="line"><span class="keyword">if</span> (X-&gt;parent &amp;&amp; !<span class="built_in">com</span>(X-&gt;parent-&gt;key, X-&gt;key))</span><br><span class="line"><span class="built_in">s_cut_X_from_Y</span>(X, X-&gt;parent);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(Root-&gt;key, X-&gt;key))</span><br><span class="line">Root = X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>$reference$ 算法导论第四版</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;势能分析&quot;&gt;&lt;a href=&quot;#势能分析&quot; class=&quot;headerlink&quot; title=&quot;势能分析&quot;&gt;&lt;/a&gt;势能分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;势能分析是用于分析数据结构操作摊销成本的一种技术。它是一种建立在势能函数基础上的分析方法</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>左式堆</title>
    <link href="http://example.com/2024/11/01/Leftist-Heap/"/>
    <id>http://example.com/2024/11/01/Leftist-Heap/</id>
    <published>2024-11-01T13:53:42.000Z</published>
    <updated>2024-11-03T10:46:29.275Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>$root$： 树根节点</p></li><li><p>$left,right$左右子节点，树 </p></li></ul><blockquote><p>左式堆是一种<strong>可并堆</strong>，在基础的二叉堆操作上，支持快速合并</p></blockquote><p>在左式堆<strong>树形</strong>节点中，除了二叉堆中基础的左右子节点，父节点，和键值对，还需要维护<strong>零路径长</strong>$\alpha$</p><script type="math/tex; mode=display">\begin{align}\alpha(x) &=-1\tag{x is nullptr node}\\\\&= min(\alpha(x.left),\alpha(x.right))+1\tag{others}\end{align}</script><p>即节点的零路径长是从它到到<strong>不具有两个子节点</strong>的<strong>最短下降路径</strong></p><p>左式堆需要维护其每一个非空节点$x$的$\alpha$满足</p><script type="math/tex; mode=display">\alpha(x.left)\ge\alpha(x.right)</script><p>则有</p><script type="math/tex; mode=display">\alpha(x)=\alpha(x.right)+1\tag{x not is nullptr node}</script><p>递归使用这个式子，$\alpha(T.root)$就是左式堆$T$的<strong>最右下降路径长度</strong>（每次下降都选择右子节点）</p><hr><h3 id="核心定理"><a href="#核心定理" class="headerlink" title="核心定理"></a>核心定理</h3><blockquote><p>非空左式堆$T$至少有$2^{\alpha(root)+1}-1$个节点</p></blockquote><p>使用数学归纳法证明</p><ul><li><p>基础条件：$\alpha(root)=0$，右子树为空左式堆$T$非空，成立</p></li><li><p>假设条件：对于$\alpha(root)=1,2,\cdots,n$个节点，定理成立</p></li><li><p>归纳假设：若$\alpha(root)=n+1$,则有</p></li></ul><script type="math/tex; mode=display">\begin{align}NodeSize(T) &= NodeSize(T.left)+NodeSize(T.right)+1\\\\&= 2^{\alpha(T.root.left)+1}-1+2^{\alpha(T.root.right)+1}-1+1\\\\&\ge 2^{\alpha(root)}+2^{\alpha(root)}-1\\\\&\ge 2^{n+2}-1\\\\&\ge 2^{\alpha(root)}-1\end{align}</script><p>根节点代入$\alpha(x)=\alpha(x.right)+1$，得到$\alpha(root.right)$=r的非空左式堆至少有$2^r-1$个节点，即</p><p>$N$个节点的左式堆有以下性质</p><script type="math/tex; mode=display">\alpha(root.right)=\lfloor\log(N+1)\rfloor</script><blockquote><p>$N$个节点的非空左式堆的最右下降路径长度为$\lfloor\log(N+1)\rfloor$</p></blockquote><p>左式堆将排序规则下的首序元素放在根节点上，通过合并操作实现插入和删除，左式堆递归地对右子结点合并来保证时间复杂度</p><h3 id="合并Merge"><a href="#合并Merge" class="headerlink" title="合并Merge"></a>合并Merge</h3><p>$key$键上的排序规则$\circ$，合并两个<strong>不同时为空</strong>左式堆$T_1,T_2$，<strong>返回</strong>合并后的二叉堆根节点$T_{new}$，即</p><script type="math/tex; mode=display">T_{new}=Merge(T_1,T_2)</script><h4 id="递归基"><a href="#递归基" class="headerlink" title="递归基"></a>递归基</h4><p>任意一个左式堆位空，返回原本的非空二叉堆</p><h4 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h4><script type="math/tex; mode=display">\begin{align}T_1.key\circ T_2.key &= true\\\\T_{new}.left &= T_1.left\\\\T_{new}.right &=Merge(T_1.right,T_2)\\\\if\ \alpha(T_{new}.left) &> \alpha(T_{new}.right)\ then\ swap(T_{new}.left,T_{new}.right)\\\\set\  &\alpha (T_{new}.root)\end{align}</script><p><em>因为函数是递归的，只需要保持边界条件和递归步骤过程的性质</em>，就能得到整体的性质</p><ul><li><p>因为递归入口为不同时为空的两个左式堆，而存在空左式堆的函数实例都会直接返回，所有递归每一步中的两个二叉堆不同时为空</p></li><li><p>合并的两个左式堆的左右子堆都满足<strong>非零路径要求</strong>，而交换操作使得每一个递归返回的左式堆也满足</p></li><li><p>每一次<strong>递归调用</strong>都在原始的左式堆(没有交换子树)上进行，并且沿着任意一个左式堆最右下降路径进行，所以$Merge$调用次数用时就是两个二叉堆<strong>最右下降路径总和</strong></p></li></ul><p>$O(\lfloor\log(N_1+1)\rfloor+\lfloor\log(N_2+1)\rfloor)=O(\log N)$</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://s2.loli.net/2024/11/02/5arWwQXiJhSb2ok.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左式堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S_L_Heap</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> val, Node* left = <span class="literal">nullptr</span>, Node* right = <span class="literal">nullptr</span>) :<span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">Node* left, * right;</span><br><span class="line"><span class="type">int</span> val, npl = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Node* root = <span class="literal">nullptr</span>;</span><br><span class="line">function&lt;<span class="keyword">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com = <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_clear</span><span class="params">(Node* root)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root) &#123;</span><br><span class="line"><span class="built_in">s_clear</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">s_clear</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_npl</span><span class="params">(Node* node)</span> </span>&#123; <span class="keyword">return</span> node ? node-&gt;npl : <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">up_date</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_npl</span>(node-&gt;left) &lt; <span class="built_in">get_npl</span>(node-&gt;right))</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_npl</span>(node-&gt;left) &lt; <span class="built_in">get_npl</span>(node-&gt;right))</span><br><span class="line"><span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">node-&gt;npl = <span class="built_in">get_npl</span>(node-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s_merge</span><span class="params">(Node* a, Node* b)</span> -&gt; Node* </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> a ? a : b;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">com</span>(a-&gt;val, b-&gt;val))</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line">a-&gt;right = <span class="built_in">s_merge</span>(a-&gt;right, b);</span><br><span class="line"><span class="built_in">up_date</span>(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">S_L_Heap</span>(function&lt;<span class="built_in">auto</span>(<span class="type">int</span>, <span class="type">int</span>)-&gt;<span class="type">bool</span>&gt; com = <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()) :<span class="built_in">com</span>(com) &#123;&#125;</span><br><span class="line">~<span class="built_in">S_L_Heap</span>() &#123; <span class="built_in">s_clear</span>(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(<span class="keyword">auto</span> val)</span> </span>&#123; <span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root, <span class="keyword">new</span> <span class="built_in">Node</span>(val)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root-&gt;val; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* old = root;</span><br><span class="line"><span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root-&gt;left, root-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">merge</span><span class="params">(S_L_Heap&amp; heap)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root != heap.root) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;root = <span class="built_in">s_merge</span>(root, heap.root);</span><br><span class="line">heap.root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$root$： 树根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$left,right$左右子节点，树 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;左式堆是一种&lt;strong&gt;可并堆&lt;/strong&gt;，在基础的二叉堆操作上，支持快速合并&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>微表面理论</title>
    <link href="http://example.com/2024/11/01/Cook-Torrance/"/>
    <id>http://example.com/2024/11/01/Cook-Torrance/</id>
    <published>2024-11-01T07:14:05.000Z</published>
    <updated>2024-11-03T10:41:07.708Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>微表面理论的核心思想是将物体表面视为由无数微小、朝向各异的<strong>镜面</strong>组成的集合。这些微小镜面被称为微面元，每个微面元都能独立<strong>反射</strong>光线</p></blockquote><p>在微表面模型中，物体表面的<strong>粗糙程度</strong>由微面元的<strong>朝向分布</strong>决定。如果微面元的朝向分布较为集中，则表面看起来更光滑；反之，如果朝向分布分散，则表面看起来更粗糙</p><p>综上，可以解释$Cook-Torrance$将$BRDF$表示为</p><script type="math/tex; mode=display">\rho(w_r,w_i)=k_{difffuse}\cdot f_{lambert}(w_r,w_i)+k_{sepcular}\cdot f_{Cook-Torrance}(w_r,w_i)</script><p>其中第一项是漫反射常数分量，在之前已经证明过</p><hr><h2 id="Cook-Torrance-项组成"><a href="#Cook-Torrance-项组成" class="headerlink" title="$Cook-Torrance$项组成"></a>$Cook-Torrance$项组成</h2><script type="math/tex; mode=display">f_{Cook-Torrance}(w_r,w_i)=\frac{F(w_i,h)D(h)G(w_r,w_i,h)}{4(w_r\cdot n)(w_i\cdot n)}</script><p>其中，$ω_r$是观察方向，$w_i$是入射方向，$n$是表面法线， $h$是半角向量，即$w_i$和$w_r$的中间向量。</p><p>现在解释各项的含义</p><h3 id="菲涅尔项-F-w-i-h"><a href="#菲涅尔项-F-w-i-h" class="headerlink" title="菲涅尔项$F(w_i,h)$"></a>菲涅尔项$F(w_i,h)$</h3><ul><li>描述了光线从一种介质进入另一种介质时，光线在界面上的反射率。</li><li>常用的近似是$Schlick$菲涅尔近似，它简化了精确的菲涅尔方程，便于计算。</li></ul><h3 id="法线分布函数-D-h"><a href="#法线分布函数-D-h" class="headerlink" title="法线分布函数$D(h)$"></a>法线分布函数$D(h)$</h3><ul><li>描述了微面元法线分布的概率密度函数。</li><li>它决定了表面粗糙度，常用的模型有$Blinn-Phong$，$GGX$（$Trowbridge-Reitz$分布）和$Beckmann$分布。</li></ul><h3 id="几何函数-G-w-r-w-i-h"><a href="#几何函数-G-w-r-w-i-h" class="headerlink" title="几何函数$G(w_r,w_i,h)$"></a>几何函数$G(w_r,w_i,h)$</h3><ul><li>描述了微面元之间的自遮挡（$masking$）和遮挡（$shadowing$）效应。</li><li>它考虑了由于表面微观结构引起的直接光照和反射光线的可见性问题。</li><li>常用的近似是$Smith-Schlick-GGX$模型。</li></ul><hr><h2 id="菲涅尔效应"><a href="#菲涅尔效应" class="headerlink" title="菲涅尔效应"></a>菲涅尔效应</h2><blockquote><p>菲涅尔效应（$Fresnel Effect$）是指当光线以非垂直角度入射到介质表面时，反射光和透射光的相对强度如何随入射角的变化而变化。具体来说，当光线垂直入射（即入射角为0度）时，反射率较低，大部分光线会透射进入第二种介质；而当光线以较大角度入射时，反射率会增加，透射率相应减少。</p></blockquote><p>菲涅尔项$F(w_i,h)$可以通过菲涅尔方程来计算，该方程基于电磁理论，考虑了两种介质的折射率$n_1,n_2$对于非导电介质，菲涅尔方程可以表示为</p><script type="math/tex; mode=display">\begin{align}F_{parallel} &= \large(\frac{n_1\cos\theta_i-n_2\cos\theta_t}{n_1\cos\theta_i+n_2\cos\theta_t}\large)^2\\\\F_{perpendicular} &= \large(\frac{n_1\cos\theta_t-n_2\cos\theta_i}{n_1\cos\theta_t+n_2\cos\theta_i}\large)^2\end{align}</script><p>其中，$\theta_i$是入射角，$\theta_t$是透射角。平行和垂直分量分别对应于入射光的偏振方向。</p><h3 id="菲涅尔项的简化"><a href="#菲涅尔项的简化" class="headerlink" title="菲涅尔项的简化"></a>菲涅尔项的简化</h3><p>在实际的计算机图形学应用中，通常使用Schlick的近似来简化菲涅尔项的计算，因为它既快速又足够准确。$Schlick$近似的公式如下</p><script type="math/tex; mode=display">F_{Schlick}(w_i,h)=F_0+(1-F_0)(1-(w_i\cdot h))^5</script><p>其中，$F_0$（$F_0\in [0,1]$）是在垂直入射时的反射率（也称为基础反射率）</p><hr><h2 id="几何遮蔽函数"><a href="#几何遮蔽函数" class="headerlink" title="几何遮蔽函数"></a>几何遮蔽函数</h2><blockquote><p>在微表面理论中，表面被视作由无数微小的镜面组成，每个微面元都能独立反射光线。然而，由于这些微面元之间的相对位置，它们可能会相互遮挡，影响最终的反射光强度。几何遮蔽函数$G(w_r,w_i,h)$就是用来量化这种遮挡效应的。</p></blockquote><p>几何遮蔽函数$G$考虑了两个方向的遮蔽效应：</p><ul><li><p><strong>入射方向</strong>$w_i$的遮蔽：从入射方向$w_i$看来，微面元可能被其他微面元遮挡，导致光线无法到达。</p></li><li><p><strong>出射方向</strong>$w_r$的遮蔽：从出射方向$w_r$看来，微面元可能遮挡了其他微面元的反射光线。</p></li></ul><p>函数$G$通常定义为</p><script type="math/tex; mode=display">G=G_1(w_r,h)\cdot G_1(w_i,h)</script><p>其中，$G_1$是单方向的遮蔽函数，它描述了从特定方向观察时的遮蔽效应。</p><p>常见的视线有$Cook-Torrance$遮蔽函数</p><script type="math/tex; mode=display">G_1(w,h)=\frac{h\cdot w}{(h\cdot w)(1-k)+k}</script><p>其中，$k$，$k\in[0,1]$是与表面粗糙度相关的参数</p><hr><blockquote><p>$tips$ $Cook-Torrance$函数中,菲涅尔项$F(w_i,h)$和几何遮蔽项$G(w_r,w_i,h)$值都$\in [0,1]$，减少了反射光线的数量和强度</p></blockquote><hr><h2 id="法线分布函数"><a href="#法线分布函数" class="headerlink" title="法线分布函数"></a>法线分布函数</h2><blockquote><p>法线分布函数$D(h)$描述了微面元法线在半角方向$h$上的<strong>分布</strong>。</p></blockquote><h4 id="D-h-的实际意义"><a href="#D-h-的实际意义" class="headerlink" title="$D(h)$的实际意义"></a>$D(h)$的实际意义</h4><blockquote><p>$tips_2$ <strong>微平面法向量</strong>表示为$w_h$，宏观平面的半角向量表示$h$</p></blockquote><p>非形式化的讲，$D(w_h)$的可以表示为为微表面法向量为$w_h$的<strong>微平面的面积</strong></p><script type="math/tex; mode=display">D(w_h)\equiv\frac{dA_\bot}{dw_h}</script><p>根据定义式，可得$D(h)$的实例应该满足</p><script type="math/tex; mode=display">\int_{\Omega^+}D(h)\cos\theta dh\ dA=dA</script><p>将所有的半球面立体角$h$方向的微平面面积积分，仍为原来的微分面积元$dA$</p><blockquote><p>$tips_1$ $dA_\bot$可以被替换为$dN$，即表示在$w_h$上的微表面数量，两者意思等价</p></blockquote><hr><h3 id="Cook-Torrance-项推导"><a href="#Cook-Torrance-项推导" class="headerlink" title="$Cook-Torrance$项推导"></a>$Cook-Torrance$项推导</h3><p>为了证明能量守恒，先代入为<strong>辐入照度</strong>定义</p><script type="math/tex; mode=display">\begin{align}d^3\phi &\equiv L_i(w_i)dw_id^2A_\bot\\\\&\equiv L_i(w_i)\cos\theta_{w_h}dw_id^2A\\\\&\equiv L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_hdA\end{align}</script><p>代入<strong>辐射出度</strong>定义</p><script type="math/tex; mode=display">\begin{align}dL_r &\equiv \frac{d^3\phi}{\cos\theta_rdw_rdA}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_hdA}{\cos\theta_rdw_rdA}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_h}{\cos\theta_rdw_r}\end{align}</script><p>代入$BRDF$定义</p><script type="math/tex; mode=display">\begin{align}\rho(w_r,w_i) &\equiv \frac{dL_r(w_r)}{dE_i}\\\\&\equiv \frac{L_i(w_i)\cos\theta_{w_h}dw_i\ D(w_h)dw_h}{\cos\theta_rdw_r}\cdot\frac{1}{L_i(w_i)\cos\theta_idw_i}\\\\&\equiv \frac{\cos\theta_{w_h}D(w_h)dw_h}{\cos\theta_r\cos\theta_idw_r}\end{align}</script><p>取特殊点$w_h$的立体角拆分为$(\theta,\phi)$,则$w_r=(2\theta\ mod\ \pi,\phi)$，则</p><script type="math/tex; mode=display">\begin{align}\frac{dw_h}{dw_r} &= \frac{\sin\theta_{w_h}d\theta_{w_h}\ d\phi}{\sin 2\theta_{w_h}d2\theta_{w_h} d\phi}\\\\&= \frac{\sin\theta_{w_h}d\theta_{w_h}\ d\phi}{4\sin\theta_{w_h}\cos\theta_{w_h}d\theta_{w_h} d\phi}\\\\&= \frac{1}{4\cos\theta_{w_h}}\end{align}</script><p>代回$BRDF$可得</p><script type="math/tex; mode=display">\rho(w_r,w_i)=\frac{D(w_h)}{4\cos\theta_r\cos\theta_i}</script><p>加入<strong>几何遮蔽项和菲涅尔项</strong>可得</p><script type="math/tex; mode=display">f_{Cook-Torrance}(w_r,w_i)=\frac{F(w_i,h)D(h)G(w_r,w_i,h)}{4(w_r\cdot n)(w_i\cdot n)}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;微表面理论的核心思想是将物体表面视为由无数微小、朝向各异的&lt;strong&gt;镜面&lt;/str</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="http://example.com/2024/10/30/2d-heap/"/>
    <id>http://example.com/2024/10/30/2d-heap/</id>
    <published>2024-10-30T14:59:23.000Z</published>
    <updated>2024-11-03T10:45:53.640Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p><strong>堆</strong>是一种树形数据结构，它不按照严格的<strong>排序规则</strong>维护数据，它只维护规则下的<strong>首序元素</strong></p></blockquote><ul><li>支持<strong>动态增删改</strong>节点（元素）</li></ul><p>$tips$ 改操作建立在增删操作，只需要堆内指针和外部元素相互存引用</p><ul><li>获取首序节点</li></ul><hr><h3 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h3><h4 id="排序规则-circ-的限制"><a href="#排序规则-circ-的限制" class="headerlink" title="排序规则$\circ$的限制"></a>排序规则$\circ$的限制</h4><ul><li><p>满足<strong>传递性</strong>：若有$key:A,B,C$且$A\circ B=true,B\circ C=true$，则$A\circ C=true$</p></li><li><p>排序规则对<strong>key</strong>没有影响，<em>这个更多是在程序上的限制</em></p></li></ul><blockquote><p>为了便于分析，只考虑二叉堆，实践中可能会使用更多<strong>幂次分叉</strong>利用缓存</p></blockquote><h4 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h4><ul><li>树<strong>节点</strong>存储<strong>元素</strong>：<strong>键值对</strong>$(key,val)$。所以对元素排序，隐含的意思是在$key$之间使用排序规则</li></ul><blockquote><p>$tips$ 在树的语境下使用节点$node$，在排序的语境下使用元素$key$，两者都是<strong>键值对</strong></p></blockquote><ul><li>子父节点关系：$parent_{key}\circ each\ child_{key}=true$</li></ul><blockquote><p>$tips$ 这里的子节点和父节点都是在树中的<strong>一级邻居点</strong>，简单来讲，不是祖父或者孙子之类的</p></blockquote><p>递归应用这个关系，即可以保证下面的性质</p><ul><li><strong>树根</strong>即这棵树（堆）包含的所有元素，在排序规则下的首序元素，即有$root_{key}\circ other\ node_{key}=true$</li></ul><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>若堆中存在$node$，且$node\ne root$使得$root_{key}\circ node_{key}=false$，则堆<strong>不满足子父节点关系</strong></p><p>$def\ root$到$node$的路径为$(root,T_0,T_1,\cdots,T_{n-1},node)$</p><p>则有</p><script type="math/tex; mode=display">\begin{align}root &\circ T_0=true\\\\T_0 &\circ T_1 =true\\\\T_{n-2} &\circ T_{n-1}=true\\\\T_{n-1} &\circ node=true\\\\\end{align}</script><p><em>省略了角标</em>$key$</p><p>根据排序规则的<strong>传递性</strong>，可得应该有$root_{key}\circ node_{key}=true$</p><p>可见，任意违反了<strong>子父关系</strong>的树都不是堆，只要维护子父关系就可以得到堆</p><hr><h3 id="维护堆性质"><a href="#维护堆性质" class="headerlink" title="维护堆性质"></a>维护堆性质</h3><p>$def\ Adjustment(node)$表示对改变了$key$的<strong>二叉堆堆</strong>中节点$node$进行调整</p><p>下面证明，如果堆中只有这一个改变，则这个操作会重新维持堆性质</p><h4 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h4><p>若$key\circ old\ key=true$，则节点可能往上调整</p><p>重复进行以下调整直至满足<strong>子父节点关系</strong></p><script type="math/tex; mode=display">if\ parnet_{key}\circ node_{key}=false</script><script type="math/tex; mode=display">swap(node,parent)</script><p>利用传递性规则可以证明每一步以$node$为根的堆都满足堆序</p><p>注意，$node$兄弟节点$bother$也会满足堆序，所以不可能有下滤</p><script type="math/tex; mode=display">\begin{align}parent &\circ bother=true\\\\node &\circ parent=true\\\\node &\circ bother=true\end{align}</script><h4 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h4><p>若$key\circ old\ key=false$，则节点可能往上调整</p><p>和上滤不同的是，这里需要<strong>确定所有子节点</strong>的首序元素$maxchild$，这也是叉树不同带来的影响，这里只考虑二叉堆，只需要一次$\circ$操作，如果叉树较大，可以展开为堆或者排序</p><p>总结为重复一下操作</p><script type="math/tex; mode=display">if\ node_{key}\circ maxchild_{key}=false</script><script type="math/tex; mode=display">swap(node,maxchild)</script><p>显然不会做上滤</p><p>综上，任意一次操作只会引起上滤或下滤，在<strong>二叉堆中</strong>，因为是<strong>完全二叉树</strong>，所以<strong>调整操作</strong>的时间复杂度度为$O(h)=O(\log^{n-1})$</p><hr><h4 id="初始化复杂度紧确界"><a href="#初始化复杂度紧确界" class="headerlink" title="初始化复杂度紧确界"></a>初始化复杂度紧确界</h4><p>因为任何堆的子树也是堆，所以从树叶到树根进行<strong>下滤</strong>操作可以获得这棵树元素组成的堆，时间复杂度为$O(N\log N)$，其中$N$为节点数量 ，但是这个界不是紧确的</p><ul><li><p>有$n$个节点的非空二叉堆的高度为$\lfloor\log(n)\rfloor$，可以根据$2^{h}-1\le n&lt;2^{h+1}-1$推导</p></li><li><p>在$n$个节点的二叉堆中，高度为$h$的堆节点最多有$\lceil\frac{n}{2^{h+1}} \rceil$个</p></li></ul><p><em>这里的高节是叶节点</em></p><p>则有时间复杂度</p><script type="math/tex; mode=display">\begin{align}\sum_{h=0}^{\lfloor\log n\rfloor}\lceil\frac{n}{2^{h+1}} \rceil O(h) &= O(n\sum_{h=0}^{\lfloor\log n\rfloor}\frac{h}{2^h})\\\\\sum_{h=0}^{\infty}\frac{h}{h^2} &= \frac{\frac{1}{2}}{(1-\frac{1}{2})^2}=2\\\\O(n\sum_{h=0}^{\lfloor\log n\rfloor}\frac{h}{2^h}) &= O(n\sum_{h=0}^{\infty}\frac{h}{h^2})=O(n)\end{align}</script><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="正确性验证"><a href="#正确性验证" class="headerlink" title="正确性验证"></a>正确性验证</h4><p><img src="https://s2.loli.net/2024/10/31/uvsP24cUCzNHZ6K.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Binary_Heap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line">vector&lt;T&gt; Heap;</span><br><span class="line"><span class="type">const</span> function&lt;<span class="keyword">auto</span>(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)-&gt;<span class="type">bool</span>&gt; op;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fa</span><span class="params">(<span class="type">size_t</span> idx)</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> (idx - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sa</span><span class="params">(<span class="type">size_t</span> idx)</span> -&gt; <span class="type">size_t</span> </span>&#123; </span><br><span class="line"><span class="type">size_t</span> sL = (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sL<span class="number">+1</span> == size)</span><br><span class="line"><span class="keyword">return</span> sL;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op</span>(Heap[sL], Heap[sL + <span class="number">1</span>]) ? sL : sL + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">up</span><span class="params">(<span class="type">size_t</span> hole)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> val = Heap[hole];</span><br><span class="line"><span class="keyword">for</span> (; hole &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">op</span>(Heap[<span class="built_in">fa</span>(hole)], val); hole = <span class="built_in">fa</span>(hole))</span><br><span class="line">Heap[hole] = Heap[<span class="built_in">fa</span>(hole)];</span><br><span class="line">Heap[hole] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">down</span><span class="params">(<span class="type">size_t</span> hole)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> val = Heap[hole];</span><br><span class="line"><span class="keyword">for</span> (; (hole &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt; size &amp;&amp; !<span class="built_in">op</span>(val, Heap[<span class="built_in">sa</span>(hole)]); hole = <span class="built_in">sa</span>(hole))</span><br><span class="line">Heap[hole] = Heap[<span class="built_in">sa</span>(hole)];</span><br><span class="line">Heap[hole] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Binary_Heap</span>(vector&lt;T&gt;::const_iterator begin, vector&lt;T&gt;::const_iterator end, <span class="type">const</span> function&lt;<span class="built_in">auto</span>(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)-&gt;<span class="type">bool</span>&gt; op)</span><br><span class="line">:<span class="built_in">Heap</span>(begin, end), <span class="built_in">size</span>(<span class="built_in">distance</span>(begin, end)), <span class="built_in">op</span>(op) &#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">1</span>) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">fa</span>(size - <span class="number">1</span>); i != <span class="number">0</span>; --i)</span><br><span class="line"><span class="built_in">down</span>(i);</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">top</span><span class="params">()</span> -&gt; T </span>&#123; <span class="keyword">return</span> Heap.<span class="built_in">front</span>(); &#125;<span class="comment">//返回值，请勿直接更改</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span>-&gt;<span class="type">void</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == Heap.<span class="built_in">size</span>())</span><br><span class="line">Heap.<span class="built_in">resize</span>((size &lt;&lt; <span class="number">1</span>) + <span class="number">16</span>);</span><br><span class="line">Heap[size] = val;</span><br><span class="line"><span class="built_in">up</span>(size++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pop</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">Heap.<span class="built_in">front</span>() = Heap[--size];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;是一种树形数据结构，它不按照严格的&lt;strong&gt;排序规则&lt;/str</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>蒙特卡洛路径追踪</title>
    <link href="http://example.com/2024/10/30/Monte-Carlo-path-tracing/"/>
    <id>http://example.com/2024/10/30/Monte-Carlo-path-tracing/</id>
    <published>2024-10-30T10:54:59.000Z</published>
    <updated>2024-11-03T10:41:03.019Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="从-BRDF-到渲染方程"><a href="#从-BRDF-到渲染方程" class="headerlink" title="从$BRDF$到渲染方程"></a>从$BRDF$到渲染方程</h4><p>$BRDF$定义下的反射方程为</p><script type="math/tex; mode=display">L_r(w_r)=\int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i</script><ul><li><p>这个方程是递归定义的，方程式左右两边都有辐射度$L(w)$，可以实现物体间的反射</p></li><li><p>引入物体的自发辐射度$L_e(w)$，<em>属于出射辐射度</em></p></li><li><p>引入表面法向量，则有$\cos\theta=n\cdot w$</p></li></ul><p>得到渲染方程</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)(n\cdot w_i)dw_i</script><p>表示像素$P$沿$w_r$方向的<strong>出射辐射度</strong>为：沿$w_r$的自发辐射度，和各个正球面立体角角接收到的<strong>衰减</strong>后的入射辐射度$\rho(w_i,w_r)\cdot L_i(w_i)$的加和</p><h4 id="渲染方程的解"><a href="#渲染方程的解" class="headerlink" title="渲染方程的解"></a>渲染方程的解</h4><p>渲染方程中$L_e(w_r),\rho(w_i,w_j)$和表面材质相关，所以他们是已知的，方程的未知项只有$L_i(w_i)$</p><script type="math/tex; mode=display">def\ K(w_i,w_r)=\rho(w_i,w_r)L_i(w_i)(n\cdot w_i)</script><p>$n$<em>法向和像素相关，这个方程使用对象是每个像素，所有</em>$n$<em>隐含其中</em>，则可以得到参数化的方程组</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\int_{\Omega^+}K(w_i,w_r)L_i(w_i)dw_i</script><p>这个方程的属于<strong>第二类弗雷德霍姆积分方程</strong>，目前实践中使用<strong>近似求解</strong></p><hr><h3 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h3><blockquote><p>蒙特卡洛积分（Monte Carlo Integration）是一种数值方法，用于求解难以通过解析方式得到的定积分。其基本思想是对函数值进行多次<strong>随机采样</strong>（这也是和黎曼积分的区别）然后求这些采样值的平均值作为积分的近似</p></blockquote><p>积分函数$f(x)$在采样分布$P(x)$的前提下，采样$N$个<strong>样点</strong>的蒙特卡洛积分值$MF_N$可以这样计算</p><script type="math/tex; mode=display">\begin{align}F &= \int_a^bf(x)dx\tag{Integral function}\\\\X &\equiv p(x_i)\tag{Probability density function}\\\\MF_N &=\frac{1}{N}\sum_{i=1}^N\frac{f(x_i)}{p(x_i)}\tag{Monte Carlo Integration}\end{align}</script><p>接下来证明分布函数$P(x)$对积分的影响</p><script type="math/tex; mode=display">\begin{align} \frac{1}{N}\sum_{i=1}^N\frac{f(x_i)}{p(x_i)} &= E(\frac{f(x_i)}{p(x_i)})\\\\E(\frac{f(x_i)}{p(x_i)}) &=\int_a^b(\frac{f(x_i)}{p(x_i)}p(x_i)+0\ast(1-p(x_i)))dx\\\\&= \int_a^bf(x_i)dx\end{align}</script><p>将蒙特卡洛采样用于渲染方程可得</p><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\frac{1}{N}\sum_{i=1}^{N}\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}</script><hr><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><blockquote><p>蒙特卡洛方法理论上是一种无偏估计，但是$N$值在复杂度增长会出现$N^N$的增长，路径追踪只考虑其中一条反射光线</p></blockquote><script type="math/tex; mode=display">L_r(w_r)=L_e(w_r)+\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}</script><p>此时，每个像素无论弹射多少次，只会有一条光线在场景中反射，解决方法是在更高层次(像素)增加采样率</p><p>若每个像素发出$M$条光线，则有渲染方程</p><script type="math/tex; mode=display">\begin{align}L_p &= \sum_{j=0}^M\alpha(j)L_j\\\\L_r(w_r) &= L_e(w_r)+\frac{\rho(w_r,w_i)L_i(w_i)(n\cdot w_i)}{p(x_i)}\end{align}</script><blockquote><p>$tips$ 这个方程对于单个像素不再是纯递归的</p></blockquote><p>形式化的讲，原本的渲染方程</p><script type="math/tex; mode=display">for\ each\ Pixel\ call\ L_p=shader(Ray_p)</script><p>在像素级别增加采样率后</p><script type="math/tex; mode=display">for\ each\ Pixel\ call\ L_p=merge(P)</script><script type="math/tex; mode=display">merge:</script><script type="math/tex; mode=display">for\ i=1\ to M\ call\ L_p+=shader(Ray_i)</script><hr><h3 id="俄罗斯轮盘赌-Russian-Roulette"><a href="#俄罗斯轮盘赌-Russian-Roulette" class="headerlink" title="俄罗斯轮盘赌($Russian\ Roulette$)"></a>俄罗斯轮盘赌($Russian\ Roulette$)</h3><p>除了遇到光源的递归基外，还需要组合边界条件防止无线递归，比如弹射次数，能量衰减</p><p>蒙特卡洛路径追踪标准方法采用<strong>随机方法</strong>俄罗斯轮盘赌($Russian\ Roulette$)</p><p>除了递归入口外，对每一步递归函数实例过程做动态判断，它是否为还应递归下去</p><p>形式化的讲</p><ul><li><p>每一个$shader(Ray)$都关联一个随机数$P\in[0,1]$，$P_d$的值从$1$随着递归变深减小</p></li><li><p>若一个$shader$函数实例没有到达显示的递归基(射向光源，场景边界)，则需要生成随机数$p\in (0,1]$</p></li><li><p>若有$p\le P$，则返回$0$，<em>这个像素采样点映射的物体没有被光源照射</em></p></li></ul><h4 id="贡献分配"><a href="#贡献分配" class="headerlink" title="贡献分配"></a>贡献分配</h4><blockquote><p>当应用俄罗斯轮盘赌策略时，如果一条光线被决定继续其路径，它的贡献值需要通过除以$P_d$来放大，这一过程是为了补偿那些按照规则被提前终止的光线可能带来的贡献</p></blockquote><p>形式化的讲</p><script type="math/tex; mode=display">E=\sum_{d=1}^{maxD}(P_d(L_d/P_d)+((1-P_d)\ast 0))=\sum_{d=0}^{maxD}L_d=L_p</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;从-BRDF-到渲染方程&quot;&gt;&lt;a href=&quot;#从-BRDF-到渲染方程&quot; class=&quot;headerlink&quot; title=&quot;从$BRDF$到渲染方程&quot;&gt;&lt;/a&gt;从$BRDF$到渲染方程&lt;/h4&gt;&lt;p&gt;$BRDF$定义下的反射方程为&lt;/p&gt;
&lt;scri</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>辐射度量</title>
    <link href="http://example.com/2024/10/30/Radiometry/"/>
    <id>http://example.com/2024/10/30/Radiometry/</id>
    <published>2024-10-30T05:01:40.000Z</published>
    <updated>2024-11-04T16:47:08.244Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="光与颜色"><a href="#光与颜色" class="headerlink" title="光与颜色"></a>光与颜色</h3><h4 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h4><p>电磁频谱是指电磁辐射按照<strong>频率</strong>$f$或<strong>波长</strong>$T$的顺序排列所形成的连续范围。它涵盖了从极低频的无线电波到极高频的伽马射线</p><ul><li><p>$T$（$s$）是电磁波上相继的两个具有相同<strong>振幅</strong>的点之间的时间，<strong>频率</strong>$f=\frac{1}{T}$（$s^{-1}$）</p></li><li><p>电磁波在单个周期中<strong>传播距离</strong>$\lambda=\frac{c}{f}$</p></li><li><p>在真空中，光速$c=3\times 10^8ms^{-1}$</p></li></ul><blockquote><p>$tips$ 波长的国际单位是$nm,1nm=10^{-9}m$</p></blockquote><p>在电磁辐射的<strong>波动</strong>模型中，光被描述为在空间中横向振荡传播的电场和磁场</p><p><strong>可见光</strong>（$Visible\ light$）：波长范围大约从$750nm$到$400nm$，这是人类眼睛能够感知的电磁辐射范围，每一种<strong>波长</strong>对应一<strong>光谱颜色</strong></p><hr><h4 id="颜色心理学特征"><a href="#颜色心理学特征" class="headerlink" title="颜色心理学特征"></a>颜色心理学特征</h4><p>人对光的感知主要由以下因素影响</p><ul><li><p><strong>主频率</strong>：人眼接收光波的主要可见光频率段</p></li><li><p><strong>亮度</strong>：人眼接收到的光能量，这会在<strong>辐射度量</strong>中详细介绍</p></li><li><p><strong>饱和度</strong>：色彩理论术语，这里只考虑光中包含的波长范围较窄，实际还有很多影响因素，比如对比度，亮度</p></li></ul><hr><h3 id="辐射度量光照模型"><a href="#辐射度量光照模型" class="headerlink" title="辐射度量光照模型"></a>辐射度量光照模型</h3><p>基本的光照模型利用经验来近似光照效果，而辐射度光照模型以<strong>辐射度量学</strong>定量分析光的传播</p><p>尽管后序的渲染还需要对这一过程做近似处理</p><p>这里简单将<strong>辐射</strong>定义为：<strong>大量光子的集合</strong></p><hr><h2 id="辐射度量术语"><a href="#辐射度量术语" class="headerlink" title="辐射度量术语"></a>辐射度量术语</h2><h3 id="辐射能量（-Radiant-Energy-）"><a href="#辐射能量（-Radiant-Energy-）" class="headerlink" title="辐射能量（$Radiant\ Energy$）"></a>辐射能量（$Radiant\ Energy$）</h3><p><em>可以用符号</em>$E$或$Q$<em>表示，避免符号冲突，这里用</em>$Q$</p><p>在光的量子模型中，光的<strong>辐射能量</strong>由<strong>光子</strong>携带，由普朗克-爱因斯坦关系式，可得频率为$f$的<strong>光子能量</strong>$e=h\frac{c}{\lambda}$</p><p>其中$h$为普朗克常量$6.6262\times 10^{-34}Js^{-1}$</p><p>则<strong>辐射能量</strong>可以表示为</p><script type="math/tex; mode=display">Q\equiv\sum_{\lambda}h\frac{c}{\lambda}</script><p>特定波长的<strong>光谱能量</strong>为$E_{\lambda}\frac{dQ}{d\lambda}$，<em>名字具有误导性，它是一个密度函数</em></p><blockquote><p>$tips$ 之后的各种计量都可以把各种波长分开做成<strong>频谱</strong>来分析</p></blockquote><h3 id="辐射通量（-Radiant-Flux-）"><a href="#辐射通量（-Radiant-Flux-）" class="headerlink" title="辐射通量（$Radiant\ Flux$）"></a>辐射通量（$Radiant\ Flux$）</h3><ul><li>单位时间传递的辐射能量，也叫<strong>光通量</strong></li></ul><blockquote><p>其单位为$W$，出现在照明产品的说明书上，度量光源（产品）的发光能力</p></blockquote><script type="math/tex; mode=display">\phi\equiv\frac{dQ}{dt}</script><h3 id="辐射强度（-Radiant-Intensity-）"><a href="#辐射强度（-Radiant-Intensity-）" class="headerlink" title="辐射强度（$Radiant\ Intensity$）"></a>辐射强度（$Radiant\ Intensity$）</h3><ul><li>点辐射源在某一方向上单位立体角内传送的辐射通量，用$I$表示</li></ul><blockquote><p>度量光源在某个方向上的发出的辐射通量，通常用来计算表面的辐照度</p></blockquote><script type="math/tex; mode=display">I(w)\equiv\frac{d\phi}{dw}</script><blockquote><p>辐射强度不止和光源本身属性相关，和<strong>立体角</strong>$w$相关，所以这个函数有额外的输入$w$</p></blockquote><hr><h4 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h4><p>立体角是三维空间的角，参考二维平面上角的定义$\theta\equiv\frac{l}{r}$，其中$l$是圆弧，$r$是原半径</p><p>可以得到立体角定义</p><script type="math/tex; mode=display">\Omega\equiv\frac{A}{r^2}</script><p>下面是对立体角积分$dw$的推导</p><script type="math/tex; mode=display">\begin{align}dA &= (rd\theta)(r\sin\theta d\phi)=r^2\sin\theta\ d\theta\ d\phi\\\\dw &= \frac{dA}{r^2}=\sin\theta\ d\theta\ d\phi\end{align}</script><p><em>为了使表达更直观，符号乘法之间有间隙，但是意思没变</em></p><hr><h3 id="辐照度（-Irradiance-）"><a href="#辐照度（-Irradiance-）" class="headerlink" title="辐照度（$Irradiance$）"></a>辐照度（$Irradiance$）</h3><ul><li>单位面积上离开表面的辐射通量，这个量也称为<strong>辐出度</strong>（$H$）</li></ul><blockquote><p>$tips$ 这里不用射入来定义，因为当表示为”辐入度“时，隐含的是光线和表明垂直的标准化亮度</p><p>表现场景中表面的光照效果</p></blockquote><script type="math/tex; mode=display">E\equiv\frac{d\phi}{\cos\theta\ dA}</script><h3 id="辐射度（-Radiance-）"><a href="#辐射度（-Radiance-）" class="headerlink" title="辐射度（$Radiance$）"></a>辐射度（$Radiance$）</h3><ul><li>每单位立体角，每单位<strong>垂直</strong>面积的辐射强度</li></ul><blockquote><p>辐射度是一个描述面辐射源上某点在特定方向上辐射特性的物理量。它不仅考虑了辐射源的强度，还考虑了辐射在空间中的分布情况</p></blockquote><script type="math/tex; mode=display">L(w)\equiv\frac{d^2\phi}{\cos\theta\ dw\ dA}\equiv\frac{dE}{\cos\theta\ dw}</script><p>其中$\theta$为点$P$的法线和$-Ray$的夹角，若为负，则是内表面，定义为$0$</p><p>因为<strong>辐射能量的接收量会因入射角的不同而变化</strong>，所以需要矫正为<strong>标准化亮度</strong>，即垂直方向的面积</p><p>这里区分辐照度和辐出度</p><script type="math/tex; mode=display">L_{i}(w)\equiv\frac{dE}{\cos\theta\ dw}</script><script type="math/tex; mode=display">L_{r}(w)\equiv\frac{dH}{\cos\theta\ dw}</script><p>$L_{in}$表示表面的输入辐射率，$L_{out}$表示表面输出的辐射率</p><p>下面的推导证明了辐射度在光源和场景表面的桥梁关系</p><script type="math/tex; mode=display">\begin{align}L(w) &\equiv \frac{dE}{\cos\theta\ dw}\\\\dE(w) &\equiv L(w)\cos\theta\ dw\\\\E &\equiv \int_{\Omega^+}L(w)\cos\theta\ dw\end{align}</script><p>其中，最后一步积分是对所有来自表面上方的方向的辐射强度积分，则可以把立体角转换为上半球面坐标</p><p>代入立体角积分$dw=\sin\theta\  d\theta\  d\phi$</p><script type="math/tex; mode=display">E\equiv\int_{\theta=0}^{\frac{\pi}{2}}\int_{\phi=0}^{2\pi}L(w)\sin\theta\ \cos\theta\ d\theta\ d\phi</script><p>如果假设表面在各个方向接收到的入射辐射通量相同，即</p><script type="math/tex; mode=display">L(w)=L</script><p>那么可以直接积分得</p><script type="math/tex; mode=display">E=\pi L</script><hr><h2 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数($BRDF$)"></a>双向反射分布函数($BRDF$)</h2><blockquote><p>双向反射分布函数（Bidirectional Reflectance Distribution Function，简称BRDF）是一个用于描述表面如何反射光线的数学函数</p></blockquote><p>简单来讲，任何来自入射方向$w_i$的入射光线，都有一部分反射在反射方向$w_r$方向附近的立体角内</p><p>$BRDF$描述这样一个过程：表面元接受到某一方向辐射照度（$dE$）之后，向不同方向把能量辐射出去（$dL_r$）,这个过程的能量比值，即</p><blockquote><p>关于为什么这么定义，而不是$\frac{dL_i(w_i)}{dL_r(w_r)}$，是因为它所属的学科：辐射<strong>度量</strong>学：</p><ul><li>使用一个固定方向的点光源照射一块面积，测量一段时间该表面的能量变换$\Delta Q$。就有$E=\frac{\Delta Q}{\Delta t\Delta A}$</li><li>用同样的方法同时测量某个反射方向的表面，有$\Delta L_r(w_r)$</li></ul></blockquote><script type="math/tex; mode=display">\rho(w_i,w_r)\equiv\frac{dL_r(w_r)}{dE_i}\equiv\frac{dL_r(w_r)}{L_i(w_i)\cos\theta\ dw_i}</script><p>从中可以推导<strong>反射方程</strong></p><script type="math/tex; mode=display">\begin{align}dL_r(w_r) &= \rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i\\\\L_r(w_r) &= \int_{\Omega^+}\rho(w_i,w_r)L_i(w_i)\cos\theta\ dw_i\end{align}</script><p>反射方程表明，某一方向上的的反射光，是由所有不同方向上入射光线的辐射度贡献得到的</p><hr><h2 id="半球面方向反射系数-HDFR"><a href="#半球面方向反射系数-HDFR" class="headerlink" title="半球面方向反射系数$(HDFR)$"></a>半球面方向反射系数$(HDFR)$</h2><blockquote><p>半球面方向反射系数$R$（$Hemispherical\ Directional\ Reflectance\ Factor$），通常简称为$HDRF$，是描述表面在半球面上所有方向反射光能力的物理量。它是表面反射特性的一个度量，用来量化材料表面在受到光照时，向所有可能方向反射光的比例。</p></blockquote><p>根据定义和能量守恒，有$0\le R\le 1$</p><ul><li><p>$R=1$：理想的黑色体，吸收了所有光</p></li><li><p>$R=0$：理想的白色体，反射所有入射光</p></li></ul><p>在<strong>计算机图形学</strong>中，通常研究的变量是入射光方向</p><script type="math/tex; mode=display">R(w_i)\equiv\frac{E}{H_i}\equiv\int_{\Omega^+}\rho(w_i,w_r)\cos\theta_r dw_r</script><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><script type="math/tex; mode=display">\begin{align}L_r(w_r) &\equiv \frac{dE}{\cos\theta_rdw_r}\\\\\rho(w_i,w_r) &\equiv \frac{L_r(w_r)}{H_i}\\\\H_i\rho(w_i,w_r) &\equiv \frac{dE}{\cos\theta_rdw_r}\\\\\frac{dE}{H_i} &\equiv \rho(w_i,w_r)cos\theta_rdw_r\\\\\frac{E}{H_i} &\equiv \int_{\Omega^+}\rho(w_i,w_r)\cos\theta_r dw_r\end{align}</script><hr><h2 id="理想的漫反射-BRDF"><a href="#理想的漫反射-BRDF" class="headerlink" title="理想的漫反射$BRDF$"></a>理想的漫反射$BRDF$</h2><blockquote><p>理想的漫反射表面即为朗伯表面：$BRDF\rho(w_i,w_r)$为常量</p></blockquote><p>下面推导其$HDFR$特征</p><script type="math/tex; mode=display">\begin{align}R(w_i) &= \int_{\Omega^+}\rho\cos\theta_r dw_r\\\\&= \int_{\theta_r=0}^{\frac{\pi}{2}}\int_{\phi_r=0}^{2\pi}\rho\sin\theta_r\cos\theta_rd\theta_rd\phi_r\\\\&= \rho\pi\end{align}</script><p>所以有关于朗伯表面的结论</p><script type="math/tex; mode=display">\rho=\frac{R}{\pi}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;光与颜色&quot;&gt;&lt;a href=&quot;#光与颜色&quot; class=&quot;headerlink&quot; title=&quot;光与颜色&quot;&gt;&lt;/a&gt;光与颜色&lt;/h3&gt;&lt;h4 id=&quot;电磁频谱&quot;&gt;&lt;a href=&quot;#电磁频谱&quot; class=&quot;headerlink&quot; title=&quot;电磁频谱</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>切线空间的运用</title>
    <link href="http://example.com/2024/10/29/Tangent%20Space/"/>
    <id>http://example.com/2024/10/29/Tangent%20Space/</id>
    <published>2024-10-29T12:50:54.000Z</published>
    <updated>2024-10-29T15:26:04.134Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h2><p>首先定义切线空间的坐标轴</p><ul><li><p>切线（$T$）轴：纹理坐标中$U$坐标方向向量</p></li><li><p>副切线（$B$）轴：纹理坐标中$V$方向向量</p></li><li><p>法线（$N$）轴：纹理贴图所映射表面的法线</p></li></ul><p>从定义就可以立即得到$T_z=B_z=0$</p><p>设纹理贴图映射的对象表面中能确定一个平面的三点$P_0,P_1,P_2$和对应的纹理坐标$(u_0,v_0),(u_1,v_1),(u_2,v_2)$</p><p>则有</p><script type="math/tex; mode=display">\begin{align}P_1-P_0 &= (u_1-u_0)T+(v_1-v_0)B\\\\P_2-P_0 &= (u_2-u_0)T+(v_2-v_0)B\end{align}</script><p>展开为矩阵表达</p><script type="math/tex; mode=display">\left[\begin{matrix}x_1-x_0 & x_2-x_0\\\\y_1-y_0 & y_2-y_0\end{matrix}\right]=\left[\begin{matrix}T_x & B_x\\\\T_y & B_y\end{matrix}\right]\left[\begin{matrix}u_1-u_0 & u_2-v_0\\\\u_1-v_0 & v_2-v_0\end{matrix}\right]</script><blockquote><p>$tips_1$ 这里为了防止角标冗余，省略了$P$符号，比如$P_{1_x}$表达为$x_1$</p><p>$tips_2$ 通常还需要对$T,B$正交化，这会带来数值精度问题</p></blockquote><hr><h3 id="空间转换"><a href="#空间转换" class="headerlink" title="空间转换"></a>空间转换</h3><h4 id="将向量从世界空间转换到切线空间"><a href="#将向量从世界空间转换到切线空间" class="headerlink" title="将向量从世界空间转换到切线空间"></a>将向量从世界空间转换到切线空间</h4><p>定义世界坐标的向量$V(x,y,z)$，则对应的切线空间向量为</p><script type="math/tex; mode=display">V^\prime=xT+yB+zN</script><script type="math/tex; mode=display">\left[\begin{matrix}T_x & B_x & N_x\\\\T_y & B_y & N_y\\\\T_z & B_z & N_z\end{matrix}\right]\left[\begin{matrix}V_x\\\\V_y\\\\V_z\end{matrix}\right]=\left[\begin{matrix}V_x^\prime\\\\V_y^\prime\\\\V_z^\prime\end{matrix}\right]</script><h4 id="将向量从切线空间转换到世界空间"><a href="#将向量从切线空间转换到世界空间" class="headerlink" title="将向量从切线空间转换到世界空间"></a>将向量从切线空间转换到世界空间</h4><p>其变换矩阵只需要对逆变换的矩阵求逆</p><hr><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p><strong>法线贴图</strong>通过<strong>重写</strong>像素点的法线，无需对应的<strong>曲面</strong>模型而达到类型视觉效果</p><p>尽管在之前就扩大了纹理贴图的定义，但若单纯将<strong>模型空间</strong>的法线法线储存在内，其值需要和模型顶点做同样次数的变换，更为关键的是，纹理图不能在流水线中间过程更换</p><p>法线贴图的数据就存储在<strong>切线空间</strong>之下，在$RGB$模型中，每个通道储存一个向量分量，当前，会对其放缩到$[-1,1]$的范围</p><p>对于没有变动的法线向量就是$(0,0,1)$，而这恰巧也就解释了为什么法线贴图大部分都是蓝色的(因为大部分法线一般不变动)</p><hr><h2 id="高度贴图"><a href="#高度贴图" class="headerlink" title="高度贴图"></a>高度贴图</h2><p>高度贴图的目标和法线贴图一致，不过它不直接储存法线向量，而是储存<strong>相对高度</strong>$H$，间接计算出法线向量</p><p>高度贴图是一个<strong>灰度图像</strong>，其中每个像素的亮度代表了表面在该点的相对高度。白色通常表示最高点，黑色表示最低点，而灰色表示中间高度</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>为了扰动法线，我们需要计算高度贴图中每个像素在$U$（水平）和$V$（垂直）方向上的偏导数（即梯度）。</p><ul><li><p>$\frac{d_H}{d_U}$：高度在U方向的变化率</p></li><li><p>$\frac{d_H}{d_V}$：高度在V方向的变化率</p></li></ul><p>则在<strong>切线空间</strong>平面法向量为$N=\frac{d_H}{d_U}\times \frac{d_H}{d_V}=(-\frac{d_H}{d_U},-\frac{d_H}{d_V},1)$</p><p>偏导数会采用差分的方法近似求导，即在每一个纹理像素$P(u,v)$处计算</p><script type="math/tex; mode=display">\begin{align}\frac{d_H}{d_U} &= H(u+1,v)-H(u,v)\\\\\frac{d_H}{d_V} &= H(u,v+1)-H(u,v)\\\\\end{align}</script><p>而这个过程会引入边界问题，并且这里的计算只考虑了某个方向上的变化，而没有考虑其负方向</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;切线空间&quot;&gt;&lt;a href=&quot;#切线空间&quot; class=&quot;headerlink&quot; title=&quot;切线空间&quot;&gt;&lt;/a&gt;切线空间&lt;/h2&gt;&lt;p&gt;首先定义切线空间的坐标轴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;切线（$T$）轴：纹理坐标中$U$坐标方向向量&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Shading" scheme="http://example.com/tags/Shading/"/>
    
  </entry>
  
  <entry>
    <title>法线变换推导</title>
    <link href="http://example.com/2024/10/29/normal-transformation/"/>
    <id>http://example.com/2024/10/29/normal-transformation/</id>
    <published>2024-10-29T11:56:26.000Z</published>
    <updated>2024-10-29T12:26:00.476Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h3><blockquote><p>在对模型顶点做<strong>仿射变换</strong>时，对应法线不能做同样的变换</p><p>以下的分析都是基于线性代数，向量按列排列，仿射变换都是可逆过程</p></blockquote><p>设平面切线向量为$R$，法线向量为$N$，仿射变换矩阵$M$，则有</p><script type="math/tex; mode=display">\begin{align}R^TN &= 0\tag{I}\\\\MR &= R^\prime\end{align}</script><p>若变换后的表面法线为$N^\prime$，且假设$N^\prime=GN$，则有</p><script type="math/tex; mode=display">\begin{align}(R^{\prime})^TN^\prime &= 0\\\\(MR)^T(GN) &= 0\\\\R^TM^TGN &= 0\\\\R^T(M^TG)N &= 0\end{align}</script><p>若假设成立，则<strong>可以有</strong>$M^TG=I$，此时尾式代入$(I)$式，使得假设成立，也就是说，可以使用</p><script type="math/tex; mode=display">G=(M^T)^{-1}=(M^{-1})^T</script><p>这个式子也解释了法线变换再何时需要和顶点变换区别，即<strong>仿射变换包含非均匀缩放</strong>时</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;法线变换&quot;&gt;&lt;a href=&quot;#法线变换&quot; class=&quot;headerlink&quot; title=&quot;法线变换&quot;&gt;&lt;/a&gt;法线变换&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在对模型顶点做&lt;strong&gt;仿射变换&lt;/strong&gt;时，对应法线不能做同样的变换&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Rasterization" scheme="http://example.com/tags/Rasterization/"/>
    
  </entry>
  
  <entry>
    <title>曲面细分和曲面简化</title>
    <link href="http://example.com/2024/10/29/Surface-Subdivision-Smplication/"/>
    <id>http://example.com/2024/10/29/Surface-Subdivision-Smplication/</id>
    <published>2024-10-29T01:21:43.000Z</published>
    <updated>2024-11-03T10:44:37.542Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h2><blockquote><p>曲面细分（Surface Subdivision）通过在<strong>网格模型</strong>上<strong>递归</strong>运用<strong>细分规则使</strong>多边形网格变得更加<strong>平滑和精细</strong></p><p>$tips$ 这里隐含地说明了是对<strong>采样后</strong>的曲面操作，对象是一群顶点，而不是多项式函数</p></blockquote><p>细分规则主要有$Loop$细分，$Catmull-Clark$细分</p><p>因为生成的过程需要对不同类型的曲面顶点操作，所有定义</p><ul><li><p><strong>点规则</strong>：原始（递归每一步开始）网格顶$V$的操作</p></li><li><p><strong>边规则</strong>：原始边生成<strong>新点</strong>$E$的操作</p></li><li><p><strong>面规则</strong>：在网格中多边形面中生成点$F$如何操作</p></li></ul><blockquote><p>$tips_1$ 这里不使用<strong>顶点</strong>，而用<strong>点</strong>，表述曲线上的采样点，因为<strong>退化</strong>也是评判曲面细分技术的度量规则</p><p>$tips_2$ 虽然算法是递归进行的，但这里描述的算法不需要<strong>隔代递归层数据</strong>，用角标$\prime$表示新的网格点</p></blockquote><hr><h3 id="Loop-细分"><a href="#Loop-细分" class="headerlink" title="$Loop$细分"></a>$Loop$细分</h3><p>$Loop$细分运用的场景是<strong>三角形网格</strong>，在边上增加顶点，并且调整原始点位置</p><p>过顶点的重新定位，$Loop$细分能够生成$C^2$连续的曲面</p><h4 id="边规则"><a href="#边规则" class="headerlink" title="边规则"></a>边规则</h4><p>在每条边上生成新的点</p><script type="math/tex; mode=display">E=\frac{3}{8}(A+B)+\frac{1}{8}(C+D)</script><p>在不考虑边界条件的情况下，<strong>三角形网格</strong>中每条边是两个相邻三角形的公共边，$A,B$是边的端点,$C,D$是两个三角形剩下的顶点</p><blockquote><p>$tips$ 可能会有$C,D$是一环<strong>领居节点</strong>的说法，但是并不准确，因为$E$点也有会与$E$点连接，换句话说，是排除了$E$点的一环邻居节点</p></blockquote><h4 id="点规则"><a href="#点规则" class="headerlink" title="点规则"></a>点规则</h4><p>原始网格顶点$V$需要做调整</p><script type="math/tex; mode=display">V^\prime=(1-\alpha n)V+\alpha\sum P_1</script><p>其中$P_1$为$V$在新网格中<strong>一环邻居点</strong>，$n$是他们的总数，$\alpha\ often=\frac{3}{16}$为权重</p><hr><h3 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="$Catmull-Clark$细分"></a>$Catmull-Clark$细分</h3><p>$Catmull-Clark$细分能够处理各种多边形曲面，并且有$C^2$连续性</p><h4 id="面规则"><a href="#面规则" class="headerlink" title="面规则"></a>面规则</h4><script type="math/tex; mode=display">F^\prime=\sum_{i=0}^{n-1}V_i</script><blockquote><p>$tips$ 这里的$n$指的是某个的面顶点数，$V_i$也是在这个面定义的相对顺序</p></blockquote><h4 id="点规则-1"><a href="#点规则-1" class="headerlink" title="点规则"></a>点规则</h4><script type="math/tex; mode=display">V^\prime=\frac{n}{n-2}V+\frac{1}{n^2}\sum_{i=0}^{n-1}E_i+\frac{1}{n^2}F_i^\prime</script><p>虽然这个权重（系数）比较复杂，但是加和保证为$1$，并且经过一次$Catmull-Clark$细分后的网格，保证多边形都为<strong>四边形</strong></p><h4 id="边规则-1"><a href="#边规则-1" class="headerlink" title="边规则"></a>边规则</h4><script type="math/tex; mode=display">E=\frac{V_{left}+V_{right}+F_b+F_t}{4}</script><p>边点是所在边两端点和邻接面点的平均权重组合</p><hr><h2 id="曲面简化"><a href="#曲面简化" class="headerlink" title="曲面简化"></a>曲面简化</h2><blockquote><p>曲面简化在<strong>不显著损害曲面形状特征</strong>和视觉外观的前提下，减少曲面数学描述的复杂性或<strong>数据点的数量</strong></p></blockquote><p>曲面简化不单单是曲面细分的逆过程，它有多种实现途径</p><ul><li><p><strong>网格简化</strong>：<strong>坍缩</strong>（边/面）来<strong>减少点的数量</strong></p></li><li><p><strong>多分辨率建模</strong>：创建一系列细节层次逐步减小的模型</p></li><li><p><strong>近似</strong>：使用<strong>简单曲面模型</strong>（如平面、圆柱面、球面等）来近似原始曲面</p></li><li><p><strong>参数</strong>曲面：减少控制点数目</p></li></ul><p><em>实际过程可能会对网格做曲面细分再细致的坍缩，最小形状失真</em></p><hr><h3 id="QEM-网格简化"><a href="#QEM-网格简化" class="headerlink" title="$QEM$网格简化"></a>$QEM$网格简化</h3><blockquote><p>$tips$ 之后会存在符号复用</p></blockquote><p>$QEM$网格简化是在网格上<strong>坍缩合法边</strong>，它在<strong>全局</strong>边寻找<strong>最优点对</strong>，将其替换为一个点</p><hr><h4 id="误差度量"><a href="#误差度量" class="headerlink" title="误差度量"></a>误差度量</h4><p>在$QEM$网格简化方法中，替换的<strong>点$V$与相应局部原表面的距离的平方</strong>应该最小</p><p>若有边$V_1V_2$，则坍缩后的点$\hat{V}$满足</p><script type="math/tex; mode=display">\begin{align}def\ T^2_V &= \sum_{F\in F(V_1)\cup F(V_2)}distance(V,F)^2)\\\\T_{\hat{V}}^2 &= min(T_V^2)\end{align}</script><p>$T_{\hat{V}}^2$就是边$V_1V_2$的<strong>二次度量误差</strong></p><p>其中$F$是端点$V_1,V_2$所在的所有平面，换句话话说，考察的<strong>局部原表面</strong>过顶点$V_1,V_2$</p><p>定义平面的隐式方程F：$ax+by+cz+d=0(a^2+b^2+c^2=1)$，和点$V$：$(x,y,z,1)$</p><p>转化为矩阵表达：$F^T=[a,b,c,d],V^T=[x,y,z,1]$</p><p>则</p><script type="math/tex; mode=display">\begin{align}distance(V,F)^2 &= (V^TF)^2=V^TFF^TV\\\\\sum_{F\in F(V_1)\cup F(V_2)}distance(V,F)^2 &= V^T(\sum_{F\in F(V_1)\cup F(V_2)}FF^T)V\\\\&\approx V^T(\sum_{F\in F(V_1)}FF^T+\sum_{F\in F(F(V_2)}FF^T)V\end{align}</script><blockquote><p>$tips$ 在最后一步化简中<strong>扩大了考虑面片的范围</strong>，在每次坍缩中，每个点只需要计算一次$\sum FF^T$</p></blockquote><p>对于网格上每一点$V_i$</p><script type="math/tex; mode=display">def\ Q_i=\sum_{F\in F(V_i)}FF^T</script><p>则每条边$V_1V_2$的最优替换后的<strong>二次度量误差</strong>为关于点$V$的二次函数$V^T(Q_1+Q_2)V$取得最小值的<strong>极值</strong>点</p><hr><h4 id="合法点对"><a href="#合法点对" class="headerlink" title="合法点对"></a>合法点对</h4><p>除了原本的<strong>边</strong>坍缩，$QEM$网格简化还考虑距离<strong>很近的点</strong>，让很近的点退化，防止坍缩边时这一类边增长</p><p>也就是说，合法边的集合为</p><ul><li><p>网格原本的边</p></li><li><p>$\lVert V_1V_2\rVert&lt; t,t\ depened\ on EMQ$</p></li></ul><blockquote><p>$tips$ 这两个集合有交集，不过不影响结果</p></blockquote><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li>对原始网格所有点计算$Q$</li><li>对合法边计算<strong>二次度量误差</strong>$T_{\hat{V}}^2$，使用<strong>堆储存</strong>结构$(T_{\hat{V}}^2,(\hat{V},V_1,V_2))$</li><li>用堆堆首的$\hat{V}$替换网格中的$V_1,V_2$，更新网格的边结构，计算$\hat{V}$相关边的二次度量误差并<strong>入堆</strong></li><li>重复过程<strong>3</strong>直至网格点数量达到目标</li></ol><blockquote><p>$tip$ 堆储存的是$(key,val)$，第一个域是<strong>排序规则</strong>的对象，第二个域是相关值，不影响排序</p></blockquote><p>若要在有$N$个点，每个点的平均价（出入度）为$P$(一般为$4\to 6$)的网格中，坍缩掉$M$个点，并且使用<strong>二叉堆</strong>而非斐波那契堆，则时间复杂度为</p><script type="math/tex; mode=display">O(N*P+M*P*\log (N))=O(M*P*\log (N))</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;曲面细分&quot;&gt;&lt;a href=&quot;#曲面细分&quot; class=&quot;headerlink&quot; title=&quot;曲面细分&quot;&gt;&lt;/a&gt;曲面细分&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;曲面细分（Surface Subdivision）通过在&lt;strong&gt;网格模型&lt;/st</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Geometry" scheme="http://example.com/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>B样条</title>
    <link href="http://example.com/2024/10/28/B-spline/"/>
    <id>http://example.com/2024/10/28/B-spline/</id>
    <published>2024-10-28T04:27:49.000Z</published>
    <updated>2024-11-03T10:44:33.779Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>诸如<strong>贝塞尔曲线</strong>等，使用控制点来建立边界条件的样条，当其任意<strong>控制点更改</strong>，会触发连锁反应，需要重新生成新的曲线才能<strong>保持连续性</strong>，而<strong>B样条</strong>允许<strong>局部控制曲线/面</strong></p></blockquote><h3 id="B-样条定义"><a href="#B-样条定义" class="headerlink" title="$B$样条定义"></a>$B$样条定义</h3><hr><h3 id="基函数"><a href="#基函数" class="headerlink" title="基函数"></a>基函数</h3><p>$B$样条的基函数是递归得到的，有$n+1$个控制点，$0\le i\le n$的基函数定义为</p><script type="math/tex; mode=display">\begin{align}B_i^0(u) &=1\ ,if\ t_i\le u\le t_{i+1}\\\\B_i^0(u) &=0\ ,\ others\\\\B_i^p(u) &=\frac{u-t_i}{t_{i+p}-t_i}B_i^{p-1}+\frac{t_{i+p+1}-u}{t_{i+p+1}-t_{i+1}}B_{i+1}^{p-1}\end{align}</script><p>其中，<strong>节点序列</strong>是<strong>非降序</strong>的实数序列，$t_i$指第$i$个<strong>节点</strong></p><h4 id="解释递推关系"><a href="#解释递推关系" class="headerlink" title="解释递推关系"></a>解释递推关系</h4><ul><li><p>初始化：$0$阶$B$样条基函数$B_i^0$在的变量$u$在节点向量$t_i$和$t_{i=1}$之间为1，其他地方为0</p></li><li><p>递推步骤：高阶基函数$B_i^p$是低阶基函数$B_i^{p-1}$和$B_{i+1}^{i-1}$的<strong>线性组合</strong>，正比于$u$与$t_{i+p}$之间的距离，反比与$u$与$t_{i+p+1}$之间的距离</p></li></ul><h4 id="边界条件处理"><a href="#边界条件处理" class="headerlink" title="边界条件处理"></a>边界条件处理</h4><ul><li><p>定义可能出现在递推式中的$B_i^p=0,i&gt; n$</p></li><li><p>定义可能出现在递推式中的$B_i^{-1}=0$</p></li><li><p>$t$的索引是不会越界的，也就是说<strong>节点向量长度</strong>为$n+p+2$</p></li><li><p>若递归式系数的分母为$0$，该系数所在的<strong>基函数分量</strong>为$0$</p></li></ul><h3 id="B-样条曲线公式"><a href="#B-样条曲线公式" class="headerlink" title="$B$样条曲线公式"></a>$B$样条曲线公式</h3><hr><p>由$n+1$个控制点，次数为$d(2\le d\le n)$的多项式函数表示的$B$样条</p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^{n}P_nB_i^{d}(u),\ t_p\le u\le t_{n-p}</script><blockquote><p>$tips$ 基函数并没有严格的定义域，不过在这个范围外的值一定为$0$</p></blockquote><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li><p>$C^{d-1}$连续性</p></li><li><p><strong>凸包性质</strong>，$\sum_{i=0}^n B_i^d=1$，曲线不在控制点形成的凹包外</p></li><li><p><strong>局部性</strong>：基函数$B_i^d$只在节点序列$[t_i,t_{i+p}]$上非$0$，即样条曲线段受$d$个控制点影响</p></li></ul><hr><p>$B$样条按照<strong>节点序列</strong>分类为：均匀，开放均匀，非均匀</p><ul><li><p><strong>均匀</strong>：节点间距为常数，基函数具有周期性 </p></li><li><p><strong>开放均匀</strong>：在均匀的条件下，两端点的节点重复$d$次，它生成的曲线会经过端点控制点</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;诸如&lt;strong&gt;贝塞尔曲线&lt;/strong&gt;等，使用控制点来建立边界条件的样条，当其任意&lt;strong&gt;控制点更改&lt;/strong&gt;，会触发连锁反应，需要重新生成新的曲线才能&lt;strong&gt;保持连续性&lt;/strong&gt;，而&lt;stron</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Geometry" scheme="http://example.com/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>样条曲线</title>
    <link href="http://example.com/2024/10/28/Spline/"/>
    <id>http://example.com/2024/10/28/Spline/</id>
    <published>2024-10-27T23:49:30.000Z</published>
    <updated>2024-11-03T10:44:29.722Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>样条</strong>（$Spline$）在数学和图形学中指的是一种通过一系列<strong>控制点</strong>来生成平滑<strong>曲线</strong>或<strong>曲面</strong>的方法</p></blockquote><hr><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p><strong>分段定义</strong>：样条曲线通常由多个数学上<strong>多项式函数</strong>的<strong>曲线段</strong>组成，每一段曲线在其定义的区间内都是光滑的，且在控制点处与相邻的曲线段相接</p></li><li><p><strong>平滑性</strong>：样条曲线在控制点处具有连续的一阶甚至高阶导数，满足特定的连续性条件</p></li><li><p><strong>范围</strong>：大多数样条曲线在控制点形成的<strong>凸壳</strong>内</p></li></ul><hr><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p><strong>连续性</strong>可以定量分析曲线的平滑程度，简单来说，满足高阶的连续性条件的曲线更加平滑</p><blockquote><p>$tips$：高阶连续性建立在底阶连续性之上，满足高阶连续性的曲线一定也满足低阶连续性</p></blockquote><h4 id="参数连续性"><a href="#参数连续性" class="headerlink" title="参数连续性"></a>参数连续性</h4><blockquote><p><strong>参数连续性</strong>条件涉及到曲线或曲面在<strong>参数空间</strong>中的连续性，通常用$C^n$来表示，其中$n$是连续性的阶数</p></blockquote><ul><li><p>$C^0$<strong>连续性</strong>：相邻分段曲线/面段在它们的公共边界上具有相同的函数值。这个是最基本的，分段连接条件</p></li><li><p>$C^1$<strong>连续性</strong>：<strong>切向量</strong>的连续性，端点处的函数一阶导数值相同</p></li><li><p>$C^2$<strong>连续性</strong>：<strong>曲率</strong>的连续性，端点处的的函数二阶导数相同</p></li></ul><h4 id="几何连续性"><a href="#几何连续性" class="headerlink" title="几何连续性"></a>几何连续性</h4><blockquote><p><strong>几何连续性</strong>条件涉及到曲线或曲面在<strong>欧几里得空间</strong>中的连续性,通常用$G^n$来表示</p></blockquote><ul><li>$G^0$<strong>连续性</strong>：等同于$C^0$连续性，即位置连续性</li></ul><p>其他的高阶几何连续性只要求相交处的<strong>参数导数成比例</strong>，这为实际运用给出了更为宽松的条件</p><hr><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>插值样条</strong>：线精确地<strong>通过</strong>每一个控制点</p></li><li><p><strong>逼近样条</strong>：曲线不必精确地通过所有数据点，但需要在某种意义上尽可能地<strong>接近</strong>控制点</p></li></ul><hr><h2 id="样条表示"><a href="#样条表示" class="headerlink" title="样条表示"></a>样条表示</h2><ul><li>假设用最高<strong>次数</strong>为$4$，定义域为$0\le u\le1$的多项式</li></ul><script type="math/tex; mode=display">P(u)=au^3+cu^2+cu+d</script><p>其中$P$为曲线上的点，$a,b,c,d$是<strong>多项式参数</strong>，需要用样条的控制点和<strong>边界条件</strong>生成</p><p>转化为矩阵表达</p><script type="math/tex; mode=display">P(u)=\left[\begin{matrix}u^3 && u^2 && u && 1\end{matrix}\right]\left[\begin{matrix}a\\\\b\\\\ c\\\\d\end{matrix}\right]</script><blockquote><p>$tips$ 这里是用的向量表达，若把$x,y$坐标拆开，需要八个边界条件，不过一般来说边界条件也是用点来表示的</p></blockquote><ul><li>假设曲线由两个控制点$P_0\ ,\ P_1$控制，这里为了方便说明，引入额外条件：曲线在控制点处的斜率$D_{P_0}\ ,\ D_{P_1}$(这条曲线满足过端点的前提) 。则有边界条件</li></ul><script type="math/tex; mode=display">\begin{align}P(0) &= P(0)\\\\P(1) &= P(1)\\\\D_{P_0} &= P^\prime(0)\\\\D_{P_1} &= P^\prime(1)\\\\\end{align}</script><p>现在就可以得到方程组</p><script type="math/tex; mode=display">\left[\begin{matrix}P_0\\\\P_1\\\\D_{P_0}\\\\D_{P_1}\end{matrix}\right]=\left[\begin{matrix}0 & 0 & 0 & 1\\\\1 & 1 & 1 & 1\\\\0 & 0 & 1 & 0\\\\3 & 2 & 1 & 0\end{matrix}\right]\left[\begin{matrix}a\\\\b\\\\c\\\\d\end{matrix}\right]</script><p>求解</p><script type="math/tex; mode=display">\left[\begin{matrix}a\\\\b\\\\c\\\\d\end{matrix}\right]=\left[\begin{matrix}2 & -2 & 1 & 1\\\\-3 & 3 & -2 & -1\\\\0 & 0 & 1 & 0\\\\1 & 0 & 0 & 0\end{matrix}\right]\left[\begin{matrix}P_0\\\\P_1\\\\D_{P_0}\\\\D_{P_1}\end{matrix}\right]</script><blockquote><p>$tips$ 这个样条就是$Hermite$插值样条</p></blockquote><p>这样就得到了$n$次多项式表达曲线的矩阵形式</p><script type="math/tex; mode=display">P(u)=U_{1,n}\cdot M_{n,n}\cdot N_{1,n}</script><blockquote><p>$tips$ 矩阵表达可以实现样条曲线的多项式函数转换</p></blockquote><p>若边界条件全部由控制点坐标位置得到，则可以转化成更为工整的形式</p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^{n}P_iBF_i(u)</script><p>其中$BF_i$一般称为<strong>基函数</strong></p><p>此处的样条边界条件使用了额外的条件（$D_{p}$），无法使用$\sum$符号，使用基函数的常见表达有<strong>贝塞尔曲线</strong></p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^{n}P_iB_n^k(u)\ ,\ 0\le u\le 1</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;样条&lt;/strong&gt;（$Spline$）在数学和图形学中指的是一种通过一系列&lt;stro</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Geometry" scheme="http://example.com/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线</title>
    <link href="http://example.com/2024/10/27/beisier/"/>
    <id>http://example.com/2024/10/27/beisier/</id>
    <published>2024-10-27T05:24:16.000Z</published>
    <updated>2024-11-03T10:44:24.947Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="贝塞尔曲线多项式"><a href="#贝塞尔曲线多项式" class="headerlink" title="贝塞尔曲线多项式"></a>贝塞尔曲线多项式</h4><p>$n+1$个<strong>控制点</strong>序列$(P_0\ ,\ P_1\ ,\ \cdots\ ,\ P_{n})$定义的$n$次贝塞尔曲线多项式函数</p><script type="math/tex; mode=display">\begin{align}P(u) &= \sum_{i=0}^{n}P_iB_n(i\ ,\ u)\\\\B_n(i\ ,\ u) &= \bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}\end{align}</script><hr><h4 id="伯恩斯坦多项式"><a href="#伯恩斯坦多项式" class="headerlink" title="伯恩斯坦多项式"></a>伯恩斯坦多项式</h4><p><strong>伯恩斯坦多项式</strong>（Bernstein polynomial）就是贝塞尔曲线定义式中的函数</p><script type="math/tex; mode=display">B_n(i\ ,\ u)=\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}</script><p>其中$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)$为组合数$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)=\frac{n!}{i!(n-i)!}$，有递归式$\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)=\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)\frac{n-k+1}{k}$</p><p>它具有以下性质</p><ul><li><strong>归一性</strong> 对于任意的$u$，有$\sum_{i=0}^{n}B_n(i\ ,\ u)=1$</li></ul><p>使用<strong>数学归纳法证明</strong></p><ul><li><p><strong>基础步骤</strong> $\bigl(\begin{smallmatrix}n\\\\ 0\end{smallmatrix}\bigr)(u)^0(1-u)^{0}=1$</p></li><li><p><strong>归纳假设</strong> 假设对于任意的$u$，有$\sum_{i=0}^{n}B_n(i\ ,\ u)=1$</p></li><li><p><strong>归纳证明</strong> 对于$n+1$的情形</p></li></ul><script type="math/tex; mode=display">\begin{align}B_{n+1}(i\ ,\ u) &= \bigl(\begin{smallmatrix}n+1\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i+1}\\\\&= \biggl(\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)+\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)\biggr)u^i(1-u)^{n-i+1}\\\\&= (1-u)\bigl(\begin{smallmatrix}n\\\\ i\end{smallmatrix}\bigr)u^i(1-u)^{n-i}+u\bigl(\begin{smallmatrix}n\\\\ i-1\end{smallmatrix}\bigr)u^{i-1}(1-u)^{n-i+1}\\\\&=(1-u)B_n(i\ ,\ u)+uB_n(i-1\ ,\ u)\end{align}</script><p><em>将假设代入即可证明</em></p><blockquote><p>这个性质证明了曲线上任意一点都是不同权重的控制点线性组合成</p></blockquote><ul><li><strong>非负性</strong> $B_n(i\ ,\ u)\ge 0$</li></ul><blockquote><p>这个性质进一步证明了曲线上任意一点都在控制点的<strong>凸集</strong>内（或边上）</p></blockquote><hr><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p>为了证明贝塞尔曲线由控制点定义，并通过这些点生成<strong>平滑的曲线</strong>，需要证明贝塞尔曲线多项式函数在定义域$[0\ ,\ 1]$连续</p><ul><li><p>伯恩斯坦多项式的连续性：幂函数的积连续</p></li><li><p>多项式和的连续性：求和连续</p></li><li><p>控制点的影响：常数对连续性无影响</p></li></ul><hr><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>在$n+1$个<strong>控制点</strong>序列$(P_0\ ,\ P_1\ ,\ \cdots\ ,\ P_{n})$定义的$n$次贝塞尔曲线中，将控制点定义为<strong>0阶过程点</strong>$P_i^0=P_0$</p><p>则有$k+1$阶过程点$P_i^{k+1}=(1-u)P_i^k+uP_{i+1}^k$，第$n-1$阶过程点只有一个，它对应贝塞尔曲线多项式系数为$u$生成的点</p><blockquote><p>$tips$ 这里$u$是被生成过程点到线段左端点的比例，这里的$u$和$1-u$换位了，不过不影响结果</p></blockquote><p><em>证明需要解n阶多项式方程</em></p><p>这个式子的几何意义可以理解为，使用低阶过程点和统一参数$u$的<strong>参数线段方程</strong>生成高阶过程点</p><p><img src="https://s2.loli.net/2024/10/27/JesLCygMrh3u6xK.png" alt=""></p><p>这是一条$4$个控制点生成的贝塞尔曲线图示（$u$可能有偏差），因为曲线上的点不可能超过越过线段，所有证明了<strong>凹包包围</strong></p><p>同时，$P(u)=P_0\ ,\ P(1)=P_1$<strong>曲线上的点过控制点两端</strong></p><hr><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>贝塞尔曲线是贝斯尔曲面的三维扩展，它<strong>使用一个方向的控制点作为另一个方向的控制点</strong>，这样就综合了所有控制点</p><p>在笛卡尔坐标系中，定义$n+1&gt;3$为$x$方向上的控制点个数，有$m+1&gt;3$列($y$)这样的控制点（每一列都有$n+1$个控制点，虽然没有也能做）</p><p>则曲面上的点</p><script type="math/tex; mode=display">P(u\ ,\ v)=\sum_{i=0}^{n}\sum_{j=0}^{m}P_{ij}B_n(i\ ,\ u)B_m(j\ ,\ v)</script><p>其中$0\le u\le 1\ ,\ 0\le v\le 1\ ,\ P_{ij}$为坐标系中第$i$第$j$个元素</p><blockquote><p>$tips$ 这里把点放在二维坐标系中只是为了定义他们的相对顺序（空间序列），这对去曲线生成有影响，实际上控制点都是在三维空间的</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;贝塞尔曲线多项式&quot;&gt;&lt;a href=&quot;#贝塞尔曲线多项式&quot; class=&quot;headerlink&quot; title=&quot;贝塞尔曲线多项式&quot;&gt;&lt;/a&gt;贝塞尔曲线多项式&lt;/h4&gt;&lt;p&gt;$n+1$个&lt;strong&gt;控制点&lt;/strong&gt;序列$(P_0&#92; ,&#92; P_1</summary>
      
    
    
    
    <category term="计算机图形学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Geometry" scheme="http://example.com/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>ST表</title>
    <link href="http://example.com/2024/10/26/ST-table/"/>
    <id>http://example.com/2024/10/26/ST-table/</id>
    <published>2024-10-26T13:44:03.000Z</published>
    <updated>2024-11-03T10:37:47.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>$tips$ $ST$表是一个离线的算法，他不止能做RMQ问题，比如序列$gcd$</p></blockquote><p>定义运算元素集$(a\ ,\ b\ ,\ c\ ,\ \cdots)$在其上的运算$*$存在以下性质</p><ul><li><p>$(a<em>a)^n\ ,\ n\ge1$，<em>*可重复贡献</em></em></p></li><li><p>$a<em>b=b</em>a$，满足<strong>交换律</strong></p></li></ul><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>定义运算元素序列$nums=(a_1\ ,\ a_2\ ,\ \cdots\ ,\ a_{n-1})$和运算符$DP$和$F$（这里使用两种符号是因为接下来要递归分析）</p><p>$DP$作用于区间，表示为$DP[i\ ,\ j]$，代表着对序列$nums$区间$[i\ ,\ i+2^j-1]$内的元素至少做一次运算$DP$后产生的结果</p><p>特别的，当$DP$作用于两个元素时，使用符号$F(a\ ,\ b)$区分</p><p>则有递归式</p><ul><li><p>$DP[i\ ,\ j]=F(DP[i][j-1]\ ,\ DP[i+2^{j-1}][j-1])$</p></li><li><p>基准情况$F(a\ ,\ a)$视运算规则</p></li></ul><p><em>把上面的区间规则代入就能证明</em></p><h4 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h4><p>因为$i\ ,\ j$都是正整数，储存$DP$后就能快速查找长度为$2^j$的序列$F$运算结果</p><p>想要查询<strong>任意长度</strong>，需要再次利用可重复贡献的规则，若查询的序列区间为$[L\ ,\ R]$，将它表示为两个区间的组合，当然，中间可能会产生重叠</p><ul><li>使用区间长度计算$j$，$R-L+1=2^j\to j=\log_2(R-L+1)$</li></ul><p>这里不能保证$j$为整数（能保证也就没有说明的必要了），使用取整后的结果$j^\prime=\lfloor\log_2(R-L+1)\rfloor$，之后将会证明两个区间不会有间隙</p><ul><li><p>左区间为$L$，那么左区间的运算结果为$DP[L][j^\prime]$，右区间的右端点为$R$，那么右区间的左端点为$R-j^\prime+1$，右区间的运算结果为$DP[R-j^\prime+1][j^\prime]$</p></li><li><p>综上所叙$F(ange_{nums}[L,R])=F(DP[L][j^\prime]\ ,\ DP[R-j^\prime+1][j^\prime])$，其中$j^\prime=\lfloor\log_2(R-L+1)\rfloor$</p></li></ul><p>要证明没有漏元素，只需要证明<strong>左区间的右端点不在右区间左端点的左边</strong></p><p>即</p><script type="math/tex; mode=display">R-j^\prime+1>L+2^{j\prime}-1\to R\ge L</script><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>实现中，元素为$int$，运算规则为$max$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ST</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Log2;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; DP;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ST</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) :<span class="built_in">n</span>(nums.<span class="built_in">size</span>()), <span class="built_in">Log2</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>), <span class="built_in">DP</span>(nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">Log2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">Log2[i] = Log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">DP[i].<span class="built_in">resize</span>(Log2[n - i] + <span class="number">1</span>);</span><br><span class="line">DP[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Log2[n]; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="built_in">pow</span>(<span class="number">2</span>, j); ++i)</span><br><span class="line">DP[i][j] = <span class="built_in">max</span>(DP[i][j - <span class="number">1</span>], DP[i + <span class="built_in">pow</span>(<span class="number">2</span>, j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Q</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> j = Log2[right - left + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(DP[left][j], DP[right - <span class="built_in">pow</span>(<span class="number">2</span>, j) + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>$tips$ 递归式定义可知，$DP$表的外循环应该是序列区间从小到大</p></blockquote><hr><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>预处理</strong> 开销主要在建立$DP$表，因为没有覆写，时间复杂度和空间复杂度都是</li></ul><script type="math/tex; mode=display">O(\sum_{i=0}^{n-1}\lfloor\log (n-i)\rfloor)=O(n\log (n))</script><ul><li><strong>查询</strong> $O(1)$</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;$tips$ $ST$表是一个离线的算法，他不止能做RMQ问题，比如序列$gcd$&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="杂项" scheme="http://example.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
